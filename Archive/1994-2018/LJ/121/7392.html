<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
At the Forge</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;No modules, no SQL, no hassle. Create a&#10;blog with power features without even restarting the&#10;Web server.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x15b8580.0x16afab0"></a>
At the Forge</h1></div><div><h3 class="subtitle"><i>
Blosxom</i></h3></div><div><div class="author"><h3 class="author">
Reuven
 M. 
Lerner
</h3></div><div class="issuemoyr">Issue #121, May 2004</div></div><div><p>
No modules, no SQL, no hassle. Create a
blog with power features without even restarting the
Web server.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b0348"></a></h2></div></div><p>
Weblogs, or blogs, have grown dramatically in popularity over the
past few years. Only a few people wrote blogs in the mid- and
late 1990s, but now the blogging phenomenon is an overwhelming trend.
Indeed, blogging is becoming so widespread that the <span   class="emphasis"><em>New York
Times
Magazine</em></span> published an article about it earlier this year&mdash;concentrating on high-school students who write their own blogs.
</p><p>
For example, as I write this, the Democratic primaries currently
are in high gear, and every candidate has at least one official Weblog.
Professional and armchair political commentators have set up their own
blogs to analyze and counter claims the candidates make in their blogs
and elsewhere.
</p><p>
Last month, we looked at COREBlog, a Zope product that makes it easy
to create your own Weblog. Of course, COREBlog requires that you
have a copy of Zope at your disposal and that you can install and
modify products. Not everyone has this luxury, whereas almost
every Web hosting provider makes it possible to run CGI programs
written in Perl on your Web site. For this reason, many of the most
popular blogging packages are small programs that do not raise the
ire of an ISP.
</p><p>
This month, we look at Blosxom (pronounced blossom), a Weblog
package written in Perl and designed to be run as a CGI program on
a Web site. Blosxom was written by Rael Dornfest, a programmer at
O'Reilly and Associates. I initially wrote off Blosxom as an
unrealistic tool for blogging, assuming that its small size was
indicative of its abilities. But Blosxom's power is not only in its
strong feature set but in the way it allows us to mix and
match functionalities.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b05b0"></a>
Installation</h2></div></div><p>
Installing Blosxom should be a piece of cake for anyone with
experience working with a Web server. It consists of a
single CGI program written in Perl. In my case, all I had to do was
copy the file, blosxom.cgi, to /usr/local/apache/cgi-bin, and I was
up and running.
</p><p>
Of course, every piece of software requires at least a bit of
configuration, and Blosxom is no exception. All of the configuration
is handled by a few Perl variables at the top of the program.
Comments make the purpose of each variable relatively clear.
To configure Blosxom for my system, for example, I changed the
following variables:
</p><div class="itemizedlist"><ul type="disc"><li><p>
$blog_title: the title of the Weblog as it appears to
users and in the RSS syndication feed.
</p></li><li><p>
$blog_description: blog description that appears on the front page
and in the RSS feed.
</p></li><li><p>
$datadir: each entry in a Blosxom Weblog actually is a text file
on disk somewhere; $datadir defines where those files should
reside.
</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b0978"></a></h2></div></div><p>
With those three elements defined, my Weblog was up and running.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b0a80"></a>
Adding Entries</h2></div></div><p>
I tested Blosxom by creating a simple text file in $datadir,
introduction.txt:

<pre     class="programlisting">

This is a test entry.

&lt;p&gt;Hello!&lt;/p&gt;

</pre>
</p><p>
As Weblog entries go, this one was pretty boring. But it was
interesting to see how this entry appears in my Weblog, preceded by a
date, followed by a timestamp and a permanent link and with the first
line boldfaced, as if it were a headline or title.
</p><p>
In other words, you can add entries to a Blosxom
Weblog simply by creating new text files in the
data directory. Any file ending with the value of
$file_extension, which is txt by default, is
considered a Weblog entry. This way, Emacs backup files,
which end with ~, never are considered entries.
But, if you are like me and have the habit of
saving often while writing, you might be surprised
to discover that your Weblog is being updated as
you write it, live and for the whole world to see.
If you want to work in the background, simply leave the
.txt extension off the filename until you're ready
to publish it.
</p><p>
On my workstation, where I installed Blosxom in the main cgi-bin
directory, I can see my Blosxom blog as
http://localhost/cgi-bin/blosxom.cgi.
</p><p>
Blosxom assigns a date and time to an entry based on the
timestamp of the file that was created. Because I created the file on
February 11, at 4PM, the Weblog entry was timestamped with that
time. This means you can change the timestamp of a
file retroactively with the touch command, as in:


<pre     class="programlisting">
touch -t 200401011500 testing.txt
</pre>
</p><p>
The above command modifies the date of the file testing.txt to 3PM on January 1, 2004. (If testing.txt does not exist already, it
is created.) Although this might go against the etiquette of the
Weblog universe, it certainly is possible.
</p><p>
More interestingly, you can modify the time of a Weblog entry to be in
the future, using the same touch command on the command line. If
the $show_future_entries configuration variable is set to 1,
entries with such future dates are displayed all of the time. But
in the default configuration, entries are displayed only when their
date matches the current date. This means you can time-bomb
your entries to be displayed on a particular time and date.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b0ea0"></a>
Flavours</h2></div></div><p>
If this were all that Blosxom provides, I would not
be too impressed. But after examining it a bit more
closely, I see that it contains a great deal of power.
That power is there thanks to the combination of
display templates (known as flavours, using the
British spelling) and the ability to accept any
number of plugin programs. The combination of these
two features makes Blosxom quite extensible.
</p><p>
Blosxom comes with two flavours built-in, the default HTML
flavour and the optional RSS flavour for the RSS syndication feed.
You can view the RSS feed yourself by tacking
<tt  >?flav=rss</tt> onto the
end of your blog's URL. So, if you normally view your Weblog at
http://localhost/cgi-bin/blosxom.cgi, you can view the RSS feed for the
site at http://localhost/cgi-bin/blosxom.cgi?flav=rss.
Alternatively, you can specify your preferred flavour by changing the
suffix of the page you retrieve. Thus, we can see RSS with
http://localhost/cgi-bin/blosxom.cgi/index.rss.
</p><p>
A complete flavour registry is available on the Blosxom Web site. But
the basic idea is easy to grasp: in your data directory, alongside
your Weblog entries, you create an HTML file whose name reflects the
part of Blosxom's output you want to change.
</p><p>
The filename's suffix is the same as the flavour you want to modify.
Thus, the file header.html changes the way the Weblog's header
is displayed in the HTML flavour, and date.blah changes Blosxom's
display of dates in the blah flavour. Users can set the flavour in
the URL by adding the flav name-value pair (as we saw before), and
the default is set in blosxom.cgi itself, with the variable
$default_flavour. Because blog entries have a .txt suffix, you
cannot have a txt flavour.
</p><p>
Each flavour file consists of an HTML snippet, along with Perl
variable names that might be instantiated into the particular file.
For example, story flavour files receive the variables $title and
$body, among others. (A full list is available on the Blosxom Web
site.) I thus can change my blog's output such that headlines are
huge and right-aligned, followed by the body:

<pre     class="programlisting">

&lt;p&gt;
&lt;H1 align="right"&gt;$title&lt;/h1&gt;
&lt;br /&gt;
$body
&lt;/p&gt;

</pre>
</p><p>
The above flavour inserts the $body variable, the contents
of our blog story, verbatim into the HTML. This is fine if the blog
author knows HTML and is willing to enter paragraph tags manually.
But if we want to let people separate paragraphs with blank lines, we
need to run a program on our story. Luckily, Blosxom makes it
easy to write such programs with an extensible plugin architecture.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b1210"></a>Plugins</h2></div></div><p>
Each plugin is a Perl program loaded with the require
function, which reads and evaluates code in a particular file. So
<tt  >require foo.pl</tt> opens foo.pl and evaluates the code it contains.
I normally suggest that people avoid <tt  >require</tt> in
favor of <tt  >use</tt>,
which executes a number of commands, including require. However,
because require executes at runtime, whereas use executes during
the compilation phase, it is far easier to work with it here.
</p><p>
Blosxom assumes that any file in the plugin directory, defined by the
optional $plugin_dir variable, is a plugin. Plugins are both loaded
and applied in alphabetical order, which means if you want to
make sure a particular plugin is applied first or last, you
might need to rename it.
</p><p>
Each plugin is nothing more than a simple Perl program that defines
one or more subroutines. Every plugin must define the start
subroutine, which simply returns 1. This allows Blosxom to
determine that the plugin is alive, ready and willing to be invoked.
A number of other plugin subroutines are available that each plugin
optionally may define, ranging from entries (which returns a list of
entries) to story (which allows you to modify the contents of a
story). By breaking things down in this way, Blosxom allows for a
tremendous amount of customization and sophistication, while keeping
the core code small and compact.
</p><p>
So, what sorts of features can plugins provide? There seems to be
only a few restrictions. You can change the source from which Weblog
entries are retrieved, the way in which this list of entries is
filtered, the templates used to display the entries and the
contents of the entries themselves.
</p><p>
A large number of plugins are available from the Blosxom Web site.
Some of them depend on other plugins, while others, such as the
calendar, appear only if you are using a flavour that supports
the plugin. Other plugins work immediately and merely need to be dropped
into your plugin directory.
</p><p>
A simple example of a plugin that works out of the box is atomfeed,
which provides an Atom syndication feed. Atom is a competitor to RSS
that has been promoted by a number of heavy-hitting bloggers and
programmers, in no small part because of the competing standards now
evident in the RSS world. To get an Atom feed, simply copy the
atomfeed plugin to your plugins directory. You then can retrieve
your Atom feed with http://localhost/cgi-bin/blosxom.cgi?flav=atom
or http://localhost/cgi-bin/blosxom.cgi/index.atom.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b15d8"></a>
Writing Plugins</h2></div></div><p>
Listing 1 contains a simple filter, called egotrip,
to make my name appear in boldface whenever it appears in a Weblog entry. Notice
how the plugin must define its own package; this ensures that each
plugin's subroutines are kept in a separate namespace and makes it
possible for Blosxom to determine whether a package contains a particular
method name.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b16e0"></a></h2></div></div><div class="sidebar"><p class="title"><b>Listing 1. egotrip.pl</b></p><pre     class="programlisting">


#!/usr/bin/perl

use strict;
use warnings;
use diagnostics;

package egotrip;

# Returns 1 to indicate the plugin is active
sub start
{
    return 1;
}

# Boldfaces my name
sub story {
    my ($pkg, $path, $filename, $story_ref,
        $title_ref, $body_ref) = @_;

    $$body_ref =~ s|Reuven|&lt;b&gt;Reuven&lt;/b&gt;|g;
    1;
}

1;

</pre></div><p>
The actual work is done in the story subroutine, which is passed six
arguments when invoked by Blosxom, corresponding to a number of items
having to do with the entry. In our case, we care about changing
only the body of the entry, which is in the final variable, known as
$body_ref. As its name implies, this is a scalar reference, which
means we can access or modify its contents by dereferencing it,
using two $$ signs. With that in mind, it should not come as a
surprise that we can boldface every instance of my name with:

<pre     class="programlisting">

$$body_ref =~ s|Reuven|&lt;b&gt;Reuven&lt;/b&gt;|g;

</pre>
</p><p>
Of course, we could make this step even more sophisticated and insert
automatic hyperlinks to a number of different items:

<pre     class="programlisting">
$$body_ref =~ s|(Reuven Lerner)|
&#8618;&lt;a href="http://www.lerner.co.il/"&gt;$1&lt;/a&gt;|g;
$$body_ref =~ s|(Linux Journal)|
&#8618;&lt;a href="http://www.linuxjournal.com/"&gt;$1&lt;/a&gt;|g;
</pre>
</p><p>
Indeed, a plugin of this sort already exists; it automatically
creates links to the community-driven Wikipedia. Any text placed
within [[brackets]] automatically is turned into a link to that on-line
reference book.
</p><p>
Notice how flavours are HTML templates into which we can instantiate
Perl variable values, whereas plugins are Perl programs. This
division between display and actions takes a little bit of time to
grasp, but it shouldn't be too difficult.
</p><p>
As for our paragraph-separating problem from before, there's no need
to reinvent the wheel. You simply can download a plugin, Blox, that allows
you to separate paragraphs with blank lines when writing your blog
entry. The plugin then separates paragraphs with the HTML of your
choice. Blox is listed on Blosxom's plugin registry (see the on-line
Resources section).
</p><p>
The fact that Blosxom keeps all entries and flavours in a single
directory is a bit disturbing to me and makes me wonder about the
program's scalability. Even if my filesystem and Perl can handle
that many files without too much trouble, do I really want to wade
through them all? If and when this becomes a problem, an entries
plugin probably can provide the right solution, scooping up files from
multiple directories and returning an appropriate hash to Blosxom.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x15b8580.0x16b1c08"></a>
Conclusion</h2></div></div><p>
Blosxom is a powerful tool for creating a Weblog; it's more than it might
appear at first glance. Blosxom consists of an
easy-to-install, easy-to-configure CGI program written in Perl, but its
true power lies in the fact that it lets you change every part of the
display through a combination of flavours (display templates) and
plugin routines. By mixing and matching existing flavours and
templates with something of your own, it can be easy to create your
own Weblog.
</p><p>
<span   class="bold"><b>Resources for this article:</b></span> <a href="../121/7454.html" target="_self">/article/7454</a>.
</p></div></div>
<div class="authorblurb"><p>
Reuven M. Lerner, a longtime consultant in Web/database programming,
now is a graduate student in Learning Sciences at Northwestern
University in Evanston, Illinois. You can reach him at
<a href="mailto:reuven@lerner.co.il">reuven@lerner.co.il</a>.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../121/toc121.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>