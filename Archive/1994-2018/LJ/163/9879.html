<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
/var/opinion</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;The demands of parallel processing may be met more easily in a language&#10;we already know.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x2136580.0x222dab0"></a>
/var/opinion</h1></div><div><h3 class="subtitle"><i>
Is Hardware Catching Up to Java?</i></h3></div><div><div class="author"><h3 class="author">
Nicholas
 
Petreley
</h3></div><div class="issuemoyr">Issue #163, November 2007</div></div><div><p>
The demands of parallel processing may be met more easily in a language
we already know.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2136580.0x222e348"></a></h2></div></div><p>
I had a wonderful experience chatting with the folks at RapidMind.
The company provides C/C++ programmers with a very clever tool to help
them exploit the parallel processing capability of multiple core CPUs. The
idea is to make parallel processing at least somewhat transparent to
the programmer. Programmers can use RapidMind to improve multicore
performance of existing applications with minimal modifications to their
code and build new multicore applications without having to deal with
all of the complexities of things like thread synchronization.
</p><p>
RapidMind and any other solutions like it are invaluable and will remain
so for a long, long time. C/C++ is an extremely well-entrenched legacy
programming platform. I can't help but wonder, however, if the trend
toward increased parallel processing in hardware will create a slow
but steady shift toward inherently multithreaded, managed programming
platforms like Java.
</p><p>
The inherent trade-off to adding cores to a CPU poses an interesting
problem for any programming platform. As you add cores, you increase
power consumption, which generates more heat. One way to reduce heat is
to lower the processing speed of the individual cores, or at the very
least, keep them from advancing in speed as quickly as they might have
if history could have continued along its current path.
</p><p>
As a result, any single thread of execution would run faster on a
speedy single-core CPU than it would on a slower core of a multicore
CPU. The seemingly obvious answer is to split up the task into multiple
threads. Java is multithreaded by nature, right? Therefore, all other
things being equal, a Java application should be a natural for multicore
CPU platforms, right?
</p><p>
Not necessarily. If Java was a slam-dunk superior way to exploit parallel
processing, I would have posed this shift to Java as a prediction, not a
question. It's not that simple. For example, don't let anyone tell you
that Java was built from the ground up to exploit multiple processors
and cores. It ain't so. Java's famous garbage collection got in the way
of parallel programming at first. Java versions as late as 1.4 use a
single-threaded garbage collector that stalls your Java program when
it runs, no matter how many CPUs you may have.
</p><p>
But Java's multithreaded design more easily exploits parallel processing
than many other languages, and it ended up lending itself to improvements
in garbage collection. JDK 5.0 includes various tuning parameters that may
minimize the impact of garbage collection on multiple cores or CPUs. It's
not perfect, and you have to take into account the way your application
is designed, but it is a vast improvement, and the improvement is made
possible by the fact that Java was well conceived from the start.
</p><p>
Obviously, these features aren't enough. IBM builds a lot of additional
parallelism into its WebSphere application server. In addition, IBM
and other researchers are working on a Java-related language X10,
which is designed specifically to exploit parallel processing (see
<a href="http://x10.sourceforge.net/x10home.shtml" target="_self">x10.sourceforge.net/x10home.shtml</a>).
</p><p>
It is also interesting to note that when Intel boasts about its quad-core
performance on Java, its numbers are based on using the BEA jRockit JVM,
not the Sun JVM. See <a href="http://www.intel.com/performance/server/xeon/java.htm" target="_self">www.intel.com/performance/server/xeon/java.htm</a>
for the chart and more information. I suspect Intel used this JVM 
because the BEA JVM employs garbage collection algorithms that are more
efficient for use on multiple cores.
</p><p>
The fact that Intel used a non-Sun JVM makes this whole question of
the future of Java on multicore CPUs interesting. I won't discount
the possibility that Intel may have tuned its code to work best with
the BEA JVM. But it is a significant plus for Java that you can choose
a JVM best suited for the hardware you have. The big plus is that you
still have to learn only one language, Java, and this does not limit
your choice of architecture or platforms. If you run your application
on a multicore platform, you can choose between JVMs and JVM-specific
tuning parameters to squeeze extra performance out of your application.
</p><p>
Now, think a bit further into the future. Imagine parallelism showing up
in a future generation of cell phones or other small devices. What better
language than a platform-neutral one to take advantage of this future?
</p><p>
Some disclaimers are in order, though. First, I don't think any tool or
language will soon make optimal programming for multiple cores or CPUs
totally transparent. Java has the potential to exploit multiple cores
with less impact to the programmer than many other languages, however,
which is why I think Java's future is getting even more promising with
this new hardware trend. Second, although I think Java has the edge, other
managed, multithreaded languages will no doubt ride this same wave.
Python, Ruby and your other favorite language in this genre probably
have an equally bright future.
</p></div></div>
<div class="authorblurb"><p>
Nicholas Petreley is Editor in Chief of <span   class="emphasis"><em>Linux
Journal</em></span> and a former programmer, teacher, analyst and
consultant who has been working with and writing about Linux for more
than ten years.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../163/toc163.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>