<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>OpenGL Programming on Linux</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Use Linux and get good grades? Read on to learn how&#10;    Linux helped one student with a major school project.&#10;    "><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x2521580.0x2618ab0"></a>OpenGL Programming on Linux</h1></div><div><div class="author"><h3 class="author">Vincent S. Cojot</h3></div><div class="issuemoyr">Issue #31, November 1996</div></div><div><p>
    Use Linux and get good grades? Read on to learn how
    Linux helped one student with a major school project.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x2619298"></a></h2></div></div><p>This article is not intended to be an
OpenGL tutorial or introduction. There are people far more
competent in this area than myself, and they have written a number
of articles and even books about this subject. Also, even though
the project discussed in this article was written and built mostly
using Xinside's OpenGL, it is not my intention to discuss the
superiority of any of the Linux OpenGL ports or implementations
over another. This article tells a cool story about using Linux,
and I thought it was worth contributing to the Linux community.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x26193a0"></a>Introduction</h2></div></div><p>&ldquo;And, thus,&rdquo; the professor concluded, &ldquo;Instead of working
on perfecting our home-made ray-tracer&mdash;something we have been
doing for years&mdash;this semester, we'll start something new. You will
have to build a 3D, network-capable tank game using OpenGL. You'll
be in teams of two or three students. For that, you'll use the
RS/6000 workstations we have here, and we'll give you an
introduction to OpenGL.&rdquo;</p><p>My ears! They could not believe what I had just heard. As a
student in Computer Engineering at the Polytechnical School of
Montr&eacute;al and a computer graphics fan with a good background in
ray-tracing, I had been waiting for years to be advanced enough in
my studies to be able to take that course in advanced computers
graphics. That semester I had finally been able to take the
difficult 4th year course, and I had just heard, to my immense
disappointment, that instead of working with a ray-tracer and
producing high-quality ray-traced pictures, I would have to work on
OpenGL. My morale was not high, and fear was making its way along
my stomach as I realized I knew a lot less about OpenGL than about
ray-tracing. But as one LinuxDoom aficionado would put it: &ldquo;Armed
solely with my Linux Box and my OpenGL Beta product, I plunged into
the hostile mass of GL intrinsics, prepared to fight with every
last GLfloat variable I had.&rdquo;</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x2619500"></a>What is OpenGL?</h2></div></div><p>More seriously, OpenGL is a graphics library designed from
the start as a hardware-independent interface to be implemented on
many different platforms. It uses a client-server approach, similar
to the X client-server approach, to provide display of graphics
primitives on the chosen windowing system. The server sends
commands to the client, and the client displays them.</p><p>On X-capable Unix workstations, OpenGL has an extension to
the X server named GLX. You can run your OpenGL program on one
computer and display it on another, but it requires that the server
machine has the needed OpenGL libraries and that the client has the
GLX extension. Since those two packages usually come together, this
means that both the server and client must be
&ldquo;OpenGL-capable&rdquo;.</p><p>In short, OpenGL is capable of displaying simple geometric
objects, showing orthogonal and perspective projections, performing
back face removal, doing shading and anti-aliasing, and applying
textures to objects. If you want to do something complex&mdash;like
display a car or a plane&mdash;you have to build those objects yourself,
and use OpenGL to render them the way you like.</p><p>On Linux, to my knowledge, you have the choice of several
commercial implementations and one free implementation:</p><div class="itemizedlist"><ul type="disc"><li><p>Xinside's and Metrolink's OpenGL ports for Linux,
each of which requires that you install its own X server to provide
the GLX extension and generally higher performance.</p></li><li><p>Portable Graphics, whose product runs directly on
XFree86.</p></li><li><p>Brian Paul's Mesa library, which is GPLed and
available for free, but has no GLX extension. It's impressive and
affordable.</p></li></ul></div><p>My personal experience was that the product I was using
(Xinside's OpenGL second beta, and later, the final product, which
was even faster) was of very high quality. It was faster and more
compatible than Mesa. Speaking about commercial applications
running on a free operating system is a sensitive and slippery
issue, especially when there are freely available equivalents
(Mesa) and even more so when you happen to find yourself very (or
at least more) satisfied by a commercial tool. I found Mesa to be
an impressive piece of software, but Xinside's OpenGL beta was
noticeably faster and more OpenGL-compatible, since it is a true
OpenGL implementation.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x26199d0"></a>Back to a Dearly Loved Linux Box</h2></div></div><p>So, here I was, a few days later, in front of an RS/6000
workstation, writing the first few lines of code of that soon-to-be
tank game and wondering if it was going to run on my Linux box. You
see, I had subscribed to Xinside's OpenGL beta program a few months
before as a means to remotely run OpenInventor from my Linux box,
and thus, I found myself with an OpenGL-capable Linux computer.
Later that same day I went home&mdash;while my Linux box was retrieving
the sample code by FTP&mdash;and got ready to compile it under
Linux.</p><p>The project we were building was using a freely available
auxiliary library named libaux. &ldquo;Fine,&rdquo; I thought, and I FTPed
its source code from the RS/6000 lab and compiled it on my Linux
box. It's also available from ftp.sgi.com under the OpenGL
sub-directory, along with all the examples from the OpenGL
programming guide. With a lot of hope and increasing excitment I
got ready to start the sample code and...it crashed, generating a
panic file and killing the X server.</p><p>The team later figured that this problem was caused by a
small bug in the Beta OpenGL release I was using which caused it to
misbehave when using a color-indexed color mode and
single-buffering. The program, however, ran fine as soon as I
switched to use RGBA (for Red, Green, Blue and Alpha) color
mode&mdash;it even ran slightly faster than on the older RS/6000
workstations we were using!</p><p>Granted, those RS/6000 were basic entry-level workstations,
and their age (about two years), combined with poor 3D hardware
accelerated video cards, proved they were no real match for my P133
with its Matrox Millennium (although OpenGL on Linux only provided
software 3D acceleration). For someone who has been used to &ldquo;This
hot stuff runs on workstations&mdash;W-o-r-k-S-t-a-t-i-o-n-s&mdash;don't even
think about running it on your home PC!&rdquo; this OpenGL on Linux
experience was like a dream come true.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x2619be0"></a>To Port or Not to Port, That Was No
Question</h2></div></div><p>The days went by, and we started incorporating more and more
code into the project. My team-members had more course work than I
did, so I found myself leading the team&mdash;writing most of the code
in the first part of the project and all of it in the second and
third parts. Of course, I was writing it all on Linux&mdash;but always
verifying later that it ran on the RS/6000 workstations (Murphy,
you know?).</p><p>Of course, that did not go unnoticed, and some of the
students in the class started exploring ways to build and develop
their own projects at home on their PCs using NT or that
OS-with-an-expiration-date-in-its-name (Windows 95). Others
followed my advice that it would probably be better to use a Unix
because of portability problems (I thought...er envisioned...er
imagined that the Win32 API could be quite different from that of
most Unices) and got Mesa running. After all, if you have the
choice and if you can do the same things you do at your university
at home, would you rather spend nights in a freezing-cold computer
lab with armless wooden chairs or work on your home
computer?</p><p>Problems started to appear just a few weeks after that when
we were required to implement and use a timer within the game. That
was the first blow for the NT/95 people because, unless you're
familiar with the Windows API or have some sample source code,
changing Unix's gettimeofday() to a Windows API call is not
trivial. After all, if your virtual tank is going at 10 m/s, it
should do so no matter what hardware you have, be it a 16 CPU SGI
workstation or a poor 80486. Some people got tired of putting
<b  >#ifdef</b>s and <b  >#ifndef</b>s in their
code and decided to spend nights in the lab instead.</p><p>Then came the network daemon. The idea (mostly at my
suggestion) was that the game client running on a particular
workstation would <b  >fork()</b> a daemon at
initialization. The daemon would share one or more memory segments
with the client and would have the task of listening on certain
ports for broadcast messages sent by other possible network
players. Needless to say, these Unix intrinsics marked the end of
the Windows port; even if you could run a part of the 3D engine on
Win32, you'd still have to do all the network and final debugging
on the RS/6000 workstations at school.</p><p>But during all this time there was at least one happy Linux
user who did not change a single line of code when sending it from
his home Linux box to the Risc workstations. And the only time he
actually had to put an <b  >#ifdef</b> was when the
endianness difference between the Pentium and the RS/6000 processor
started to show in the byte ordering of the TARGA files he was
loading and using for textures. Rumour even has it that he debugged
his network code without actually entering the computer lab: in the
darkest hours of the night he used two workstations to run his
program on and exported the
display to his Linux box (which was slow, but functional enough to
track down some bugs).</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x2619fa8"></a>Performance: Hardware and Software</h2></div></div><p>Speaking about performance in OpenGL is, for those of us who
don't use a middle to high-end SGI workstation at home or at work,
about as important as speaking about OpenGL itself. In our case,
around the middle of the semester, it became obvious to both
professors and students alike that the RS/6000 workstations we were
using were not fast enough for what we were doing with them.</p><p>Eventually we switched to another lab of RS/6000 workstations
which belonged to the Mechanical Engineering Department. People
there ran CATIA&mdash;like AutoCad but with ten times the features and
the memory requirements. Those workstations were still not
inherently faster than a good Linux Pentium PC with enough RAM;
most tests, gcc, xv, etc, showed my P133 was about 50-60% faster
doing generic operations. But their hardware-accelerated OpenGL
graphics allowed my game to run on them at 25 frames per second
with 512x384 pixels. By comparison, I was getting a maximum of only
9-10 frames per second with 320x240 pixels on my Linux box, where
OpenGL rendering was done by software alone on the main CPU and
FPU.</p><p>The program still ran, and
it was fast enough to allow me to work out most of the bugs and
implement new features, but I would personally have enjoyed it a
lot more if the Linux OpenGL port I was using had been able to take
advantage of the 3D features on my video card to make my programs
run even faster. On my end, I tried removing as much un-optimized
stuff as possible from the game's main loop to make it run as fast
as possible on all platforms.</p><p>Here are some stats about the project:</p><div class="itemizedlist"><ul type="disc"><li><p>Lines of code: about 7600 (game and daemon) + 900
(explosions renderer)</p></li><li><p>Number of textures and ray-traced rendered
explosions: 34</p></li><li><p>Number of different object lists used: 38</p></li><li><p>Number of possible network players or automated
opponents: 20</p></li><li><p>Features only available on Linux: basic
sound!</p></li><li><p>Time spent pulling our hair out on that game:
around 200-250 man-hours</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x261a630"></a>Conclusion</h2></div></div><p>The project, for all the work-teams in our course, is now
finished as far as it involved students working on a
programming project whose results
professors would evaluate. I finished the final
&ldquo;product&rdquo; pretty much alone and
about a week before all the other teams. In the end, our
game client probably had the
greatest number of features, the most complex graphics, the nicest
explosions and the most reliable motion engine&mdash;and we got the
highest marks possible on the final evaluation by the professors.
Somehow, I think that if I had not been able to run everything on
my home Linux machine, and do everything when I wanted it and how I
wanted it, I probably would not have reached this level of
achievement.</p><p>Other than showing that some Computer Engineering students
are definitely more productive on their home machines than on most
computers you can give them access to, this somewhat extraordinary
adventure shows that some fields&mdash;which, until now, were reserved
for high-end workstations&mdash;can be explored with something as simple
as a good Linux box and some relevant software.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2521580.0x261a790"></a>Future Directions</h2></div></div><p>UPDATE: 11/29/2006</p><p>If you want to see the pictures and code relating ot this article go to this link: <a href="http://www.step.polymtl.ca/~coyote/graphics_tank.html" target="_self">www.step.polymtl.ca/~coyote/graphics_tank.html</a></p></div></div>
<div class="authorblurb"><p>
      <span   class="bold"><b>Vincent Cojot</b></span>
      is a student in Computer Engineering at the
      Polytechnical School Of Montr&eacute;al. He enjoys Computer Graphics,
      Xview/OL programming (under Linux, of course) and miniatures
      painting.
    </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../031/toc031.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>