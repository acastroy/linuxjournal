<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>An Introduction to IC Design Under Linux</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    A discussion of various Linux tools for integrated circuit&#10;    board design.&#10;    "><meta name="keywords" content="integrated, circuit"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xf1f580.0x1016ab0"></a>An Introduction to IC Design Under Linux</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author">Toby Schaffer</h3></div><div class="author"><h3 class="author">Alan W. Glaser</h3></div><div class="issuemoyr">Issue #39, July 1997</div></div></div><div><p>
    A discussion of various Linux tools for integrated circuit
    board design.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1017818"></a></h2></div></div><p>As everyone knows, computers are composed
of two main elements, hardware and software. There are many
well-known, powerful tools for developing software under Linux.
What's not so well-known is that there are also tools available for
developing hardware. This article introduces some of the
freely-available tools you can use to create integrated circuits
(ICs). These tools include: Magic, an IC layout editor; SPICE, an
analog circuit simulator and Sigview, a graphical signal viewer.
When these programs are used in concert, Linux becomes a platform
that can be used to create real-world, working chips.
</p><p>We'll start by by briefly describing the layout and
simulation that are the basis of IC design. Next, we'll cover where
and how to get the tools. Then we'll go into more detail about what
a chip layout represents. We'll also touch on Magic's technology
file, and finish by presenting a complete design example to tie
everything together.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1017978"></a>What Is Magic?</h2></div></div><p>In a nutshell, Magic is a graphical tool that a circuit
designer uses to specify how an IC should be constructed. This
specification is created by drawing rectangles which represent
wires and transistors&mdash;the building blocks of most ICs. The
rectangles are drawn in various colors and fill patterns which
represent the layers used to manufacture the chip. (The &ldquo;layer&rdquo;
concept is explained in more detail below.) The final drawing is
usually referred to as the <span   class="emphasis"><em>layout</em></span> of the
chip.</p><p>Don't be fooled&mdash;there's much more to designing an IC than
simply making rectangles; otherwise, most any drawing program could
do the job. IC design requires further assistance from the
software. To that end, Magic is equipped with tools that make IC
design easier. For example, it enforces <span   class="emphasis"><em>design
rules</em></span> which guarantee that the circuit, as drawn, can be
manufactured correctly, and it can <span   class="emphasis"><em>extract</em></span> a
list of circuit components and how they're connected (a
<span   class="emphasis"><em>netlist</em></span>) from a layout.</p><p>These capabilities help provide a basic introduction to Magic
and how it's used to do real-world designs. In particular, we'll
develop a simple digital circuit&mdash;an <span   class="emphasis"><em>inverter</em></span>,
which is a ubiquitous building block for complex digital
chips.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1017ce8"></a>What is SPICE?</h2></div></div><p>Magic is used to draw the rectangles in a layout, but how do
we know that the circuit corresponding to these rectangles performs
as desired? <span   class="emphasis"><em>Simulation</em></span> is a way to verify that
the design you've drawn is actually the design you want&mdash;it's very
much like using a debugger on a piece of software that you're
developing. Why bother with simulation? Why not just draw it, build
it, and see if it works? Simulation is necessary, because
fabricating a chip is costly in a variety of ways. The
manufacturing process itself is very expensive, so you want to
minimize the number of times you must re-manufacture a defective
design. It is also time-consuming, so you want to avoid missing a
market window as a result of too many re-manufacturing cycles.
Because of these costs, time invested in verifying a design through
simulation pays back tremendous dividends.</p><p>One tool used to simulate circuit performance is SPICE
(Simulation Program with Integrated Circuit Emphasis). Developed at
the University of California at Berkeley in the mid-1970's, SPICE
and its derivatives, notably PSpice from MicroSim Corporation and
HSPICE from Meta-Software, are the most widely-used examples of
<span   class="emphasis"><em>analog circuit simulators</em></span>. Using detailed
models of the individual circuit components, these programs provide
an accurate picture of the device's operation and can analyze many
different aspects of a circuit's behavior. Later, we'll look at one
aspect that is particularly useful in digital circuit
design.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1017ef8"></a>Installing Magic</h2></div></div><p>Magic has a WWW page (maintained by Bob Mayo of DEC's Western
Research Laboratory) from which you can get source code and browse
other relevant information. Point your favorite Web browser to
http://www.research.digital.com/wrl/projects/magic/magic.html and
follow the &ldquo;Getting the program and manuals&rdquo; link. Version 6.5
should be available and out of beta by the time you read this
article.</p><p>Magic is installed in either the home directory of the user
&ldquo;cad&rdquo; or the directory pointed to by the environment variable
<b  >$CAD_HOME</b>. You must either create a &ldquo;cad&rdquo; user
and make its file space world-readable (assuming you want everyone
to be able to run the tools), or designate a directory for the
tools and set <b  >$CAD_HOME</b> to point to it. We
assume you'll choose the second method and refer to the directory
specified by <b  >$CAD_HOME</b> as the root of the
directory tree in which the tools are installed.</p><p>After setting <b  >$CAD_HOME</b>, untar
<b  >magic-6.5.tar</b>. Go to the
<b  >magic-6.5</b> directory and enter <b  >make
config</b>. Choose options <b  >1</b> (X11),
<b  >4</b> (Linux), <b  >5</b> (Intel based
systems, assuming you're on an Intel). Next is a list of optional
modules. Leaving them out trades functionality for smaller
executable size and compile time. For now, just accept all the
optional modules. You can always recompile later if you find you
don't use one feature or another. Then, following the instructions
on the screen, do a <b  >make force</b> to compile
everything. After this compile finishes successfully, <b  >make
install</b> installs everything in the correct location.
Don't skip this last step, because Magic depends on having all its
support files in the right place.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x10184d0"></a>Installing SPICE</h2></div></div><p>The latest freely-available version of SPICE is 3f4.
Linux-ready sources for SPICE3f4 are available at
ftp://ftp.sunsite.edu/pub/Linux/apps/circuits/spice3f4.tar.gz.
Compilation and installation instructions are in
<b  >spice3f4.readme</b>. Note that you must have at
least version 1.14.5 of BASH in order to compile. When we compiled
ours, we made only one change. We removed the
<b  >-dWANT_X11</b> from the
<b  >conf/linux</b> file, and so did not get the X
interface but did get smaller binaries. Since we are using Sigview
to look at the the outputs, we don't need this interface anyway. If
you don't feel like compiling, an a.out format binary is available
at ftp://ftp.eos.ncsu.edu/pub/vlsi/software/Linux/spice3/.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x10186e0"></a>Installing Sigview</h2></div></div><p>Sigview, developed by Lisa Pickel at MCNC, is an X11-based
program for viewing the output of various simulators, including
SPICE. By the time this article appears, it should be available at
<b  >ftp://ftp.sunsite.edu/pub/Linux/apps/circuits/sigview31.tgz</b>.
After untarring this file, <b  >cd sigview</b> and edit
the Makefile. As noted in the instructions at the top, you might
need to define <b  >SIG_DEV_FILE</b> and
<b  >SIG_TMP_PATH</b> to point to appropriate places on
your system. If they are already set correctly, you can simply use
the included (a.out format) executable. If not, a simple
<b  >make</b> will do the job. You can then place the
executable in <b  >$CAD_HOME/bin</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x10189f8"></a>Layout Concepts</h2></div></div><p>Before getting into the details of designing with Magic, it's
very helpful to have a basic understanding of the physical
structure of an IC and the process by which it's constructed. There
are many different types of process technologies&mdash;CMOS, GaAs,
bipolar and BiCMOS are common ones. Today, CMOS (Complementary
Metal Oxide Semiconductor) is the dominant technology for
high-density, low-power, low-cost digital circuits; accordingly,
we'll focus our examples on designing for CMOS. However, the
concepts presented apply equally well to any process.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1018b00"></a>The Mask</h2></div></div><p>ICs are constructed by depositing, implanting or growing
various materials in patterned layers on a silicon base. Several
layers are stacked vertically atop one another; each is separated
from the layer immediately above and below by a thin layer of
insulating material. It's important to note that a layer can
contain many separate objects&mdash;for example, it can contain
thousands of wires, none of which touch one another.</p><p>How do IC manufacturers form the patterns? Typical
manufacturing processes are similar to spray-painting, in that they
coat the entire IC surface with the material used to make the
layer; this obviously precludes the formation of distinct shapes or
patterns. If you've ever used a template to spray-paint letters
onto a poster or wall, you know that the solution to this problem
is to get a piece of shielding, called a <span   class="emphasis"><em>mask</em></span>,
cut out the areas you want to paint, and spray through the
resulting holes. IC process engineers do the same thing on a vastly
smaller scale.</p><p><a href="1317f1.jpg" target="_self"><span   class="bold"><b>Figure 1. Two
Layer Chip Layout</b></span></a></p><p>Each step in the fabrication process uses a different mask.
Suppose we have a chip with two layers of metal wiring. We'll call
the layer closest to the silicon base &ldquo;m1&rdquo; and the layer closest
to the top &ldquo;m2&rdquo;. Because m1 and m2 are different layers, m2 wires
can cross over m1 wires without making electrical contact. This is
like a high road using an overpass to cross a low road. The left
side of Figure 1 illustrates, in both an aerial and cross-sectional
view, a vertical m2 wire overlapping a horizontal m1 wire. Note
that the two are electrically separate. Suppose now that we want to
create a point where a signal <span   class="emphasis"><em>can</em></span> cross from
m1 to m2. To build this structure, we need a mask for m1, a mask
for m2, and a mask for <span   class="emphasis"><em>via</em></span>s. A via is a hole
in the insulating layer, which separates m1 from m2 and allows m2
to flow downward and contact m1, forming an electrical connection.
This is shown on the right side of Figure 1; the black square is
the via, which connects the two layers. Transistors are more
complicated, requiring more masks and different materials.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1411118"></a>Abstract Layers</h2></div></div><p>Magic makes work easier for the designer by hiding much of
this underlying physical complexity. Rather than work with mask
layers directly, you manipulate abstract layers which implicitly
represent one or more masks. For example, to create an m1 to m2
via, rather than draw three shapes on separate mask layers (the m1
layer, the hole layer and the m2 layer), you simply draw one shape
on the abstract &ldquo;via&rdquo; layer, which has all three mask layers
&ldquo;built-in&rdquo;. There are also abstract layers having a one-to-one
correspondence to mask layers; m1 and m2 are examples. In general,
an abstract layer can represent an arbitrary number of mask layers,
permitting a great simplification in design.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1411220"></a>Lambda Rules and Scalability</h2></div></div><p>In order to cram as much as possible onto the IC, modern
processes define design rule measurements in microns,
<b  >m</b>m. A micron is one millionth of a meter. For
example, in one particular CMOS process m1 wires must be at least
0.8<b  >m</b>m apart from each other and at least
0.6<b  >m</b>m wide. Each rule is independent of the
others and is specified in fractions of microns.</p><p>Magic design rules, on the other hand, are expressed not in
microns but in multiples of a unit called
<span   class="emphasis"><em>lambda</em></span>, <b  >l</b>. Introduced in
Carver Mead and Lynn Conway's classic book <span   class="emphasis"><em>Introduction
to VLSI Systems</em></span>, lambda is the &ldquo;quantum&rdquo; for the
rules&mdash;all spacings and widths must be multiples of lambda. The
previous rules concerning m1 spacing and width would be expressed
in terms of lambda as 3&lt;&lt;tt&gt;l and 2[lambda] respectively,
where &lt;&lt;tt&gt;l = 0.3&lt;&lt;tt&gt;mm.</p><p>Note that using lambda rules is a little costly in terms of
area. The spacing rule is now effectively 0.9~&lt;&lt;tt&gt;mm
instead of 0.8~&lt;&lt;tt&gt;mm; however, basing rules on lambda
allows for <span   class="emphasis"><em>scalable</em></span> designs. The scalable
rules allow us to create one design and be confident that it is
valid (i.e., it violates no design rules) regardless of the value
of lambda. For example, the MOSIS service, which is a low-cost,
low-volume IC prototyping service, fabricates chips through several
different vendors in various processes. These processes have values
of lambda ranging from 0.3&lt;&lt;tt&gt;mm to 1.0&lt;&lt;tt&gt;mm;
MOSIS basically has one set of design rules which covers all of
these processes. In reality, once lambda starts getting below
0.5~&lt;&lt;tt&gt;mm, even scalable rules change somewhat, but this
is a detail. These rules are referred to as the SCMOS (Scalable
CMOS) rules, and we use them in our design example.</p><p><a href="1317s1.html" target="_self">What the Numbers Mean</a></p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x14116f0"></a>The Technology File</h2></div></div><p>As mentioned earlier, there are several different IC process
technologies. Magic is technology-independent and can be used with
all. The information that Magic needs about the target process
resides in an external file called the <span   class="emphasis"><em>technology
file</em></span> (tech file), which Magic reads when the program
starts. By default Magic looks in
<b  >$CAD_HOME/lib/magic/sys</b> for the file
scmos.tech27. Both the location and name of the tech file can be
specified on the command line with the <b  >-T</b>
switch, although the name of the tech file must end with a
&ldquo;.tech27&rdquo; extension. For example, to use the scmos-sub.tech27
tech file, you type <b  >magic -T scmos-sub</b>.</p><p>Included with the Magic distribution in the
<b  >scmos</b> directory are multiple tech files for
various processes offered by MOSIS. As mentioned above, when lambda
gets very small, the design rules begin to change. MOSIS provides
different tech files to account for this.</p><p>Items defined in the tech file include:</p><div class="itemizedlist"><ul type="disc"><li><p>layer definitions (e.g., names, colors) and how
layers interact with one another</p></li><li><p>design rules</p></li><li><p>device (transistor) geometry and parasitics</p></li><li><p>instructions on how to convert Magic's abstract
layers to mask layers and vice versa</p></li></ul></div><p>Knowing the tech file internals isn't necessary to use Magic;
in fact, unless you're writing a tech file for a new process or
modifying one for an existing process, you can think of the tech
file as a &ldquo;black box&rdquo;. If you're interested, you can find a
complete discussion of the tech file format in <span   class="emphasis"><em>Magic
Maintainer's Manual #2: The Technology File</em></span>, located in
the <b  >doc</b> subdirectory of the Magic source
tree.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1411e80"></a>Design Example</h2></div></div><p>We now pull it all together with a real-world design
example&mdash;an inverter. An inverter simply flips a bit; it turns a
<b  >1</b> into a <b  >0</b> and a
<b  >0</b> into a <b  >1</b>. This may sound
trivial, but it's an essential building block for more complex
digital circuits.</p><p>First, we'll walk through the layout and design rule check
(DRC) of the inverter, explaining things as we go. Then we'll
extract the netlist and simulate the chip using SPICE. After we're
convinced the chip works properly, we'll construct the CIF file to
send to the foundry to have the chip fabricated.</p><p>Although this example is very rudimentary, you can find much
more complete documentation in the <span   class="emphasis"><em>Magic
Tutorial</em></span> series, located in the <b  >doc</b>
subdirectory of the Magic source distribution. These excellent
tutorials cover both the basics and more advanced usage (such as
hierarchical design, multiple windows and interactive routing) that
isn't covered here.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1412248"></a>Introductory Magic Commands</h2></div></div><p>First, invoke Magic from your shell prompt. Let's call our
example file &ldquo;inverter&rdquo;. We'll use the default tech file, so we
don't need to specify one with the <b  >-T</b>
switch.</p><pre     class="programlisting">
magic inverter
</pre><p>A new <span   class="emphasis"><em>layout window</em></span> appears in which you
design your chip; error messages and feedback appear in the window
in which you started Magic (the <span   class="emphasis"><em>command
window</em></span>). Magic handles window focus a little differently
than you might expect&mdash;even though the input focus remains on the
layout window, anything you type appears in the command window.
Many commands work regardless of which window has the focus. When
everything is ready, Magic displays a prompt in the command window.
</p><p>The first thing to do is &ldquo;paint&rdquo; the two metal wires that
supply current to the inverter&mdash;these wires are called the
<span   class="emphasis"><em>power rails</em></span>. To create the first rail, make
sure the focus is in the layout window, and type the following
commands (the colon in the first column is required):</p><pre     class="programlisting">
:grid
:box 0 0 4 5
:paint m1
</pre><p>The first command simply turns on the reference grid,
although we're zoomed too far out to see it right now. The second
command changes the shape of the <span   class="emphasis"><em>box</em></span> so that
the lower-left corner is at (<b  >0,0</b>) and the
upper-right corner is at (<b  >4,5</b>). The third
command fills the box with blue paint that represents the first
layer of metal. The box is the center of attention; most
operations, such as painting and erasing, affect only the area
within the box.
</p><p>Now zoom in to get a clearer picture:</p><pre     class="programlisting">
:box 0 0 12 32
</pre><p>Instead of typing a long command, we use a macro. Simply
press the <b  >z</b> <span   class="emphasis"><em>without</em></span> the
colon, and the layout window zooms to the box. Note that after
zooming the reference grid appears; each hash mark represents one
lambda. Shortcuts like this are very handy, so let's explore them
some more.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1412928"></a>Shortcuts&mdash;Macros and the Mouse</h2></div></div><p>A macro is a single keystroke not preceded by a colon. It can
represent any arbitrary sequence of typed commands; for example,
the <b  >z</b> above represents the <b  >:findbox
zoom</b> command. System-wide macros are read at start-up
from the file $CAD_HOME/lib/magic/sys/.magic. You can define you
own macros in a <b  >.magic</b> file in your home
directories. And you can define macros at any time by
entering:</p><pre     class="programlisting">
:macro &lt;key&gt; &lt;action to perform&gt;
</pre><p>The mouse provides a quick way to both move and resize the
box as well as paint. Move the cursor around the layout window and
click the left mouse button as you do. This action moves the box so
that its lower-left corner (the anchor point) is placed at the spot
where you clicked. Now move the cursor around while clicking the
right mouse button. The corner opposite the anchor point is placed
where you let the button up. Notice this might result in the anchor
point moving, since it's always the lower-left corner of the box.
</p><p>To see how the mouse makes painting easier, first
enter:</p><pre     class="programlisting">
:box 0 27 4 32
</pre><p>to move the box where we want the second rail. Normally,
you'd use the mouse to move and resize instead of typing a
<b  >box</b> command, but we want to make sure we all
have the box in the exact same location. Now instead of typing
<b  >:paint m1</b>, move the cursor over the existing m1
rectangle and click the middle mouse button (for those of you using
a 2-button mouse, click both buttons simultaneously). The box is
now filled with metal 1. Clicking the middle button fills the box
with whatever paint layers are underneath the cursor when you
click. This leads to a simple way to erase any paint in the
box&mdash;place the cursor over empty background and click the middle
button, which paints &ldquo;nothing&rdquo; into the box.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1412da0"></a>Arggh&mdash;I Made a Mistake</h2></div></div><p>Like any good editor, Magic has an undo facility for those
times when you make a mistake or just want to try something out
without having to commit. The <b  >u</b> macro undoes the
last action while the <b  >U</b> macro implements the
redo command. It's not unlimited; expect only the last 10 actions
or so to be undoable. However, it's more than enough to let you
erase a few rectangles and get them back.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1412f58"></a>Drawing the Inverter</h2></div></div><p>A CMOS inverter has two Field-Effect Transistors, one p-type
(PFET) and one n-type (NFET). Transistors are constructed by
drawing <span   class="emphasis"><em>polysilicon</em></span> (or poly, for short) over
<span   class="emphasis"><em>diffusion</em></span>. There are two types of diffusion, p
and n. A PFET is poly over p-diffusion; an NFET is poly over
n-diffusion.</p><p>Now let's start drawing the transistors. Position the box at
ll (lower left) = (<b  >4,19</b>), ur (upper right) =
(<b  >8,27</b>) and type:</p><pre     class="programlisting">
:pai pdiff
</pre><p>Magic understands abbreviations for commands, such as
<b  >pai</b> for <b  >paint</b>. The layer
<b  >pdiff</b> is p-type diffusion; each layer can have
multiple names defined in the tech file. In SCMOS, p-diffusion can
be called <b  >pdiffusion</b>, <b  >pdiff</b>
or <b  >brown</b>.
</p><p>Now it's time for the n-diffusion. Place the box at
ll=(<b  >4,5</b>) and ur=(<b  >8,9</b>) and
type:</p><pre     class="programlisting">
:pai ndiff
</pre><p>At this point your layout should look like the one in Figure
2. If not, you've gone astray; use the undo command and try again.
</p><p><a href="1317f2.jpg" target="_self"><span   class="bold"><b>Figure 2.
Layout Showing Diffusions Only</b></span></a></p><p>The transistors need poly running over the diffusion. In an
inverter, the two polys for the transistors are connected together.
This is the inverter's input&mdash;the signal driving the inverter is
connected to the poly. It's simplest, then, to draw a single piece
of poly which crosses both diffusions. Place the box at ll=(5,3)
and ur=(7,29) and type:</p><pre     class="programlisting">
:pai poly
</pre><p>Your layout should then look like Figure 3.
</p><p><a href="1317f3.jpg" target="_self"><span   class="bold"><b>Figure 3.
Layout Showing Polysilicon Crossing Diffusions to Define
Transistors</b></span></a></p><p><a href="1317s2.html" target="_self">For FETs, Size Does
Matter</a></p><p>There are a couple of important points to notice. First, the
area where the poly crosses the diffusion has a diagonally-striped
pattern different from both poly and diffusion. This area
represents the actual transistor, since FETs are constructed
wherever poly passes over diffusion. To see this, place the cursor
over the top transistor, and select it by pressing the
<b  >s</b> key. Now enter <b  >:what</b>, which
displays the names of the selected paint. Here, the selected area
is &ldquo;ptransistor&rdquo;; Magic actually changes the paint from
pdiffusion to ptransistor when poly crosses over it. The same
concept applies when poly crosses over n-diffusion to form an
&ldquo;ntransistor&rdquo;.</p><p>The other, very important thing to notice in Figure 3 is that
white dots suddenly appear. If you work with Magic, get used to
these dots&mdash;they indicate design rule violations, which Magic
always checks for whenever something changes. To see which rule has
been violated, place the box over the error dots, and use the
<b  >y</b> macro, which represents the <b  >:drc
why</b> command. Magic prints the reason for the error in the
command window:</p><pre     class="programlisting">
Diffusion must overhang transistor by at least 3 (MOSIS rule #3.4)
</pre><p>Since the overhang is only 1, we get design rule violations.
Notice the dots occur only in the area that causes the error.
</p><p>Now that we know what the problems are, let's fix them. Move
the box to ll=(<b  >2,19</b>) and
ur=(<b  >10,27</b>) to contain the upper error dots and
type <b  >:pai pdiff</b>. The error disappears. Now color
the area in ndiffusion to eliminate the remaining errors. The
layout now contains two &ldquo;DRC-clean&rdquo; transistors&mdash;no error dots
are now displayed.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1325a58"></a>Connectivity</h2></div></div><p>To see which components are connected to a particular
rectangle, place the cursor over it and press the
<b  >s</b> key twice quickly. The first key press selects
the rectangle; the second selects everything that's electrically
connected to it. Try this on either metal rail, and notice that
they are both electrically isolated from everything else. The top
rail must connect to the diffusion on one side of the PFET and the
bottom rail to the diffusion on one side of the NFET; otherwise, no
current can flow. Thus, we need what's called a diffusion-to-m1
contact, abbreviated <span   class="emphasis"><em>pdc</em></span> or
<span   class="emphasis"><em>ndc</em></span> depending on whether we're talking about p
or n diffusion respectively.</p><p>Place the box at ll=(<b  >0,5</b>),
ur=(<b  >4,9</b>) and type <b  >:pai ndc</b>.
Now make a pdc at ll=(<b  >0,19</b>) and
ur=(<b  >4,27</b>). Checking connectivity shows that the
rails are connected to both the adjacent contacts and the diffusion
right up to, but not including, the transistor. At this point,
check your layout against Figure 4.</p><p><a href="1317f4.jpg" target="_self"><span   class="bold"><b>Figure 4.
Layout with Electrical Connections Added</b></span></a></p><p>Now for the output. In a CMOS inverter, the output is made by
connecting together the sides of the transistors that are not
connected to a rail. Place the box at ll=(<b  >8,5</b>)
and ur=(<b  >12,9</b>) and paint an ndc (try doing this
using the middle mouse button). Then put the box at
ll=(<b  >8,19</b>) and ur=(<b  >12,27</b>) and
paint a pdc. To connect these two contacts together, we need m1
between them: put the box at ll=(<b  >8,9</b>) and
ur=(<b  >12,19</b>) and paint m1. Check the connectivity
of the output to verify that the two contacts are tied
together.</p><p>Congratulations. You've just drawn the layout for a
fully-functional CMOS logic gate&mdash;however, we're not quite
finished.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1326240"></a>Adding Labels</h2></div></div><p>Labeling assigns a name to a specified rectangle in the
layout and thereby to every rectangle electrically connected to it.
Labeling serves two purposes. First, it's like commenting code in
that it lets you know what signals are where. Second, it makes
simulation much easier when you pick sensible names rather than
generate them automatically; for automatically, &ldquo;input&rdquo; is much
easier to remember than &ldquo;a_43_n15#&rdquo;.</p><p>Let's label the rails first. Select the upper rail by moving
the cursor over it and pressing the <b  >s</b> key. Then
type:</p><pre     class="programlisting">
:label Vdd
</pre><p>&ldquo;Vdd&rdquo; should appear next to the rail. Select the other rail
and type <b  >:lab Gnd</b>. Notice the labels are placed
somewhat randomly. Now select the poly between the two transistors
and type <b  >:lab in center</b>. This places the label
in the middle of the selected rectangle. Finally, select the output
m1 and type <b  >:lab out center</b>. The now-finished
layout should look like Figure 5.
</p><p><a href="1317f5.jpg" target="_self"><span   class="bold"><b>Figure 5.
Completed Layout with Labels</b></span></a></p><p>To save your layout, type <b  >:save</b>. If you
want to save it under another name, simply type the name too; e.g.,
<b  >:save <i><tt>newcellname</tt></i></b>.
Magic automatically appends a <b  >.mag</b>
extension.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1326870"></a>Netlist Extraction</h2></div></div><p>The next step is to simulate the layout to verify that it
works correctly. Magic's <b  >.mag</b> files are stored
simply as a collection of various types of rectangles, but
simulators require a netlist of circuit components, such as
transistors and capacitors. Recall that a netlist is a list of
circuit components and how they're connected.</p><p>You use Magic itself to extract a netlist from a layout.
Magic's extractor recognizes various combinations of rectangles as
defined in the tech file and converts them into the appropriate
circuit elements. It also extracts connectivity between shapes,
thus making a complete netlist.</p><p>You must choose an &ldquo;extraction style&rdquo;, which tells Magic
how to interpret the shapes in the layout. To see the available
styles, type <b  >:extract style</b>. For our purposes,
the important part of the style name is the number, which refers to
the minimum transistor length. For example, in the
<b  >lambda=1.0(scna20_orb)</b> style we'll use, this
length is 2.0<b  >m</b>m. This should be the current
style; if it's not, enter:</p><pre     class="programlisting">
:extract style lambda=1.0(scna20_orb)
</pre><p>To complete the extraction, simply type
<b  >:extract</b>. Magic makes an
<b  >inverter.ext</b> file. This file is an intermediate
description of the circuit containing all the information necessary
to build a netlist for various simulators. We're now ready to begin
simulation, so quit magic by entering <b  >:quit</b>.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1326d40"></a>Simulation</h2></div></div><p>Before beginning a simulation, first create a SPICE file and
add transistor models and SPICE commands to it. Next, simulate the
inverter to verify that it was laid out correctly.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x1326e48"></a>Creating the SPICE File</h2></div></div><p>First, translate the <b  >inverter.ext</b> file
into something that SPICE can understand. The ext2spice program by
Stefanos Sidiropolous that comes with the Magic distribution
performs this translation. Simply enter:</p><pre     class="programlisting">
ext2spice -f spice3 inverter.ext
</pre><p>We specify &ldquo;spice3&rdquo; format output, because earlier SPICE
versions can't handle text strings for labels.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a1a68"></a>Transistor Models</h2></div></div><p>We now have a file that SPICE can understand, but it's
incomplete in an important way. For SPICE to simulate a device
correctly, it needs a <span   class="emphasis"><em>model</em></span>, a mathematical
description of the device's behavior. In particular, we now need
models for the two transistors (n-type and p-type) that we've used
in our design.</p><p>SPICE has a variety of built-in transistor models specified
in terms of sets of parameters. These parameters vary according to
the fabrication process used, so it's up to the user to specify the
correct parameters for the process being used. Fortunately, you
don't have to figure these out yourselves&mdash;you can get them from
MOSIS at ftp://ftp.mosis.edu/pub/mosis/vendors/orbit-scna20. This
FTP site contains a whole slew of data from past runs; we chose a
typical one from the &ldquo;Level 2 Parameters&rdquo; section. One minor
detail&mdash;note that you need to change the &ldquo;CMOSN&rdquo; and &ldquo;CMOSP&rdquo; to
match ext2spice's output, &ldquo;NFET&rdquo; and &ldquo;PFET&rdquo;.</p><p>After pasting in the transistor models, the inverter.spice
file should look like <a href="1317l1.html" target="_self">Listing
1</a>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a1cd0"></a>Digital vs. Analog</h2></div></div><p>We've drawn the inverter and extracted a netlist. Now we need
to simulate the chip to make sure it'll perform as expected when
the chip is fabricated. A simulator such as SPICE can do many
different types of circuit analysis. We will demonstrate two that
are very useful for the digital circuit designer.</p><p>It might seem curious to use an <span   class="emphasis"><em>analog</em></span>
circuit simulator for a <span   class="emphasis"><em>digital</em></span> circuit. We
think of digital circuits as being in one of two states,
<b  >0</b> or <b  >1</b>, while analog circuits
can take any of a continuous range of values. What's important to
realize is that a digital circuit is actually a special kind of
analog circuit. At the circuit level, a signal is either a voltage
or current, and these are really analog quantities. The
conventional <b  >0</b> and <b  >1</b>
representations of a bit are simply abstractions of two particular
voltage values; the actual values depend on the process in which
the chip is fabricated. With CMOS in particular, you can generally
ignore the currents and deal only with the voltages, due to the
FET's mode of operation. For example, in the particular process for
which we extracted our inverter, a <b  >1</b> corresponds
to 5 Volts (5V). In other processes, it might correspond to 3.3V or
2.5V. Happily enough, a <b  >0</b> generally means 0V. As
we all know, digital circuits don't switch instantaneously between
their two values. It takes time to change voltages, and this delay
is one of the things that makes your CPU run at 100MHz instead of
133MHz.</p><p>The upshot is that SPICE simulates analog behavior, but as
digital circuit designers, we will interpret the circuit's output
as digital bits rather than the analog voltages they actually
are.</p><p>Simulators specialized for digital circuits do not provide
the level of detail, that is, accuracy, that SPICE does, but they
are orders of magnitude faster. IRSIM, which is available through
the Magic WWW home page (see Resources at the end of the article)
is an example of such a simulator.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a21a0"></a>Transient Analysis</h2></div></div><p>Suppose we apply the test vector <b  >101</b> to
the inverter over a period of 75 nanoseconds (1 ns = 10-9 seconds).
How will the output change over this time interval? To answer this
question, SPICE can do a <span   class="emphasis"><em>transient analysis</em></span>.
In a transient analysis, you define the input signal(s) and tell
SPICE to simulate the circuit for a certain amount of time from the
circuit's point-of-view, not real time. A transient analysis
provides timing information, for example, how long the output takes
to switch from <b  >1</b> to <b  >0</b>. This
analysis is also useful for verifying the circuit's functionality;
you simply apply the test vector and check the output for
correctness.</p><p>Let's apply the vector <b  >101</b> to our
inverter. Add the following lines to the end of the
<b  >inverter.spice</b> file:</p><pre     class="programlisting">
Vpwr Vdd Gnd 5
Vgnd Gnd 0 0
Vinput in Gnd 0 PULSE( 0V 5V 0ns 2.5ns 2.5ns 25ns 50ns )
 .TRAN 0.1ns 75ns
 .end
</pre><p>Let's go over this specification line-by-line. Line 1 defines
a 5V voltage source between <b  >Vdd</b> and
<b  >Gnd</b>; this is the power supply. Line 2 is
necessary because of a SPICE artifact of always referring to ground
as <b  >0</b>. We simply tie <b  >Gnd</b> and
<b  >0</b> together (electrically speaking) by using a 0V
voltage source, i.e., a short-circuit. Line 3 defines a voltage
source between &ldquo;in&rdquo; and ground; this is the inverter's input.
Looking at the parameters in parentheses, we have a voltage source
whose initial voltage is 0V and &ldquo;pulsed&rdquo; voltage is 5V, and it
starts after a 0ns delay. It has a <span   class="emphasis"><em>rise time</em></span>
(i.e., the time required to switch from <b  >0</b> to
<b  >1</b>) of 2.5ns, and a <span   class="emphasis"><em>fall
time</em></span> (i.e., the time required to switch from
<b  >1</b> to <b  >0</b>) also of 2.5ns. The
width of each pulse is 25ns, and it repeats after 50ns have
elapsed. Line 4 means that we want to do a transient analysis with
a resolution of 0.1ns that lasts for 75ns. Line 5 ends the circuit
file. Save the file, then run the simulation by typing:
<pre     class="programlisting">
spice3 -r inverter.out &lt; inverter.spice
</pre>


Now, let's view the results by typing:
<pre     class="programlisting">
sigview inverter.out
</pre>


We're interested only in the top two signals, &ldquo;out&rdquo; and &ldquo;in&rdquo;,
as shown in Figure 6.
</p><p><a href="1317f6.jpg" target="_self"><span   class="bold"><b>Figure 6. SPICE
Inverter Output</b></span></a></p><p>From the digital point-of-view we see that the inverter
correctly produces a <b  >010</b> pattern; from the
analog point-of-view we see that the output's rise time is about
0.91ns and its fall time is about 0.89ns.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a2bf0"></a>Making the Masks</h2></div></div><p>At this point, the layout is completed and verified, and it's
time to send it off to the foundry to be manufactured. Since Magic
files don't contain any information about physical dimensions
(remember, all measurements are in terms of lambda), we need to
create a file that gives the layout's shapes definite sizes in
terms of microns. Also, since this file is used by the foundry to
pattern the masks used to make the chip, it specifies shapes in
terms of mask layers instead of Magic's abstract layers. Magic
understands two file formats for describing physical geometries,
CIF (Caltech Intermediate Format) and Calma GDS-II; MOSIS accepts
both. We arbitrarily chose CIF for our example.</p><p>Just as there are several extraction styles, there are
several CIF styles. The first thing we need to do is specify the
correct one. Launch Magic again with the inverter file (type
<b  >magic inverter</b> at the shell prompt), and then
type <b  >:cif ostyle</b> to see a list of available CIF
output styles. The current style should be
<b  >lambda=1.0(nwell)</b>; if it's not, make it so by
typing <b  >:cif ostyle lambda=1.0(nwell)</b>.</p><p>Creating the CIF file is simple; type <b  >:cif write
inverter</b>. This creates the file inverter.cif, which we'd
send to MOSIS. This process is referred to as &ldquo;tapeout&rdquo;, a term
coined before the advent of FTP when IC designs were stored on
magnetic tape. If this were a real design, you would now take to
your bed to make up for the fact that you hadn't slept in the last
three weeks.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a2f60"></a>Conclusion</h2></div></div><p>We've introduced three powerful tools for IC design under
Linux:</p><div class="orderedlist"><ol type="1"><li><p>Magic, for creating layouts</p></li><li><p>SPICE, for simulating circuits extracted from the
layouts</p></li><li><p>Sigview, for viewing the results of SPICE
simulations.</p></li></ol></div><p>With these tools, a designer can create working,
commercial-quality chips without spending lots of money on a
workstation and CAD software.</p><p>The design example we used to demonstrate these tools was
small but not useless. In fact, Figure 7 shows a 32,701-transistor
IC measuring 2.71mm by 6.15mm, designed with Magic, that uses
building blocks very much like the inverter we just made. (This may
sound like a lot of transistors, until you consider that current
commercial microprocessors are rapidly approaching 10
<span   class="emphasis"><em>million</em></span> transistors on a chip smaller than 2cm
by 2cm.)</p><p><a href="1317f7.jpg" target="_self"><span   class="bold"><b>Figure 7.
Magic-Designed IC</b></span></a></p><p>Thanks for making it this far. Obviously, there's a lot we've
left out about the complexities of hardware design. However, we
have demonstrated that Linux can be used for developing hardware as
well as software. Perhaps the &ldquo;SuperGizmo 6000&rdquo; will be designed
on the Linux boxes of the future.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf1f580.0x15a3538"></a>Further Reading</h2></div></div><p>We've barely scratched the surface of IC design. If you're
interested in exploring this area further, you'll want to consult
some references. We have used and can recommend the books listed in
the Resources box.</p><p><a href="1317s3.html" target="_self">Resources</a></p></div></div>
<div class="authorblurb"><p>
          <div       class="mediaobject"><img src="1317aa1.jpg"></div>
          <span   class="bold"><b>Toby Schaffer</b></span> is an electrical engineering
          student in the Ph.D. program at North Carolina State University. To
          impress women, he tells them his research is on clocking high-speed
          multi-chip module digital systems, which might explain why he
          doesn't have many dates. Article comments and questions are welcome
          at jtschaff@eos.ncsu.edu.
        </p><p>
          <div       class="mediaobject"><img src="1317aa2.jpg"></div>
          <span   class="bold"><b>Alan W. Glaser</b></span> is working toward his Ph.D. in
          electrical engineering at N. C. State University. He's interested
          in physical design of ICs and systems and is currently trying to
          nail down a dissertation topic so he can graduate. In his spare
          time, he likes to hang out with his wife and two cats. He can be
          reached at awglaser@eos.ncsu.edu.
        </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../039/toc039.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>