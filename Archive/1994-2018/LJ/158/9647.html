<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Beachhead</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;There's more to programming than Java.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xe08580.0xeffab0"></a>
Beachhead</h1></div><div><h3 class="subtitle"><i>
Languages&mdash;Some Dead and Some Still Kicking</i></h3></div><div><div class="author"><h3 class="author">
Jon
 "maddog" 
Hall
</h3></div><div class="issuemoyr">Issue #158, June 2007</div></div><div><p>
There's more to programming than Java.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xe08580.0xf003f8"></a></h2></div></div><p>
&ldquo;maddog&rdquo;, rang out the voice that I knew very well. It belonged to one
of my young friends, Eduardo. &ldquo;Why did you name your boat
<span   class="emphasis"><em>Agape</em></span>? Is
it because the boat is wide open?&rdquo;
</p><p>
I stopped sanding my little sloop and faced my young friend. &ldquo;No,
the word is not English, but Latin. It is not meant to rhyme with a
small fruit that is used in wine, but to speak of the highest form of
love.&rdquo;
</p><p>
Eduardo looked at me a moment and said, &ldquo;I did not know that you spoke
any languages other than English.&rdquo;
</p><p>
&ldquo;For the most part, I do not&rdquo;, I answered. &ldquo;I studied Latin and
French in grade school many decades ago, but by the time I understood
how valuable it was to know multiple languages, most of that training
had slipped away. Yet, having studied Latin and French does come in
handy from time to time, as I sometimes use that forgotten training to
understand new words both in foreign languages and my native English.
Now, the languages I study are mostly computer languages.&rdquo;
</p><p>
&ldquo;That is another thing&rdquo;, said Eduardo. &ldquo;Why are there are so many
languages when all you really need is Java?&rdquo;
</p><p>
I put down my sanding block, leaned up against the
<span   class="emphasis"><em>Agape</em></span> and thought
carefully for a little while.
</p><p>
FORTRAN was the first computer language I ever learned. It was in 1969,
and I learned FORTRAN by reading a book called <span   class="emphasis"><em>Programming the IBM
1130 in FORTRAN</em></span> and practicing on an IBM 1130 computer system that had
4,000 words of main memory and a card reader and punch. The system also
had a chain printer (you probably do not want to know what that was) and
a pen plotter. Notice that the name of the language was FORTRAN, in all
capital letters. That is how we wrote it in that day, for it stood for
FORmula TRANslator, just like COBOL stood for COmmon Business Oriented
Language. FORTRAN was for engineers and scientists, and COBOL was for
business people. Both languages did their jobs fairly well.
</p><p>
Because I was an engineering student and a co-op for the Western Electric
Corporation (a member of the Bell System), I learned FORTRAN. Somewhere
along the line, marketing people decided that people did not like all
capital letters in names, so the language became called Fortran. Through the
years, FORTRAN (which started in the early 1950s) became FORTRAN II,
FORTRAN III, FORTRAN IV and then started to use names related to the
years that it was updated. Today, work is being done for a
definition for Fortran 2008. Fortran is a good example of a language
(and not just a name) that changed to meet the needs of the time.
</p><p>
After returning to Drexel Institute of Technology (now Drexel
University) from my co-op period, I started seeking out more of those
devices known as computers. I found several Digital PDP-8
mini-computers in a computer lab of the Electrical Engineering
Department. Although these systems had a small language that was
FORTRAN-like, called Focal, the PDP-8 mini-computers at Drexel were
mostly programmed in assembly and/or machine language, the ones and
zeros that the machine used.
</p><p>
I was given some books on how to program the PDP-8 in
machine language, and I taught myself how to program using the most
fundamental language of the computer. Fortunately for me, the machine
language of the PDP-8 was a very simple one, having only eight basic
instructions and one main register that acted as an
&ldquo;accumulator&rdquo;. Each
instruction was the same length and matched the word size of 12
bits, so the PDP-8 was simple, though tedious, to program. The PDP-8
could not subtract (much less multiply or divide), so you had to add the
two's complement of the subtrahend in order to subtract.
</p><p>
The processors had switches and lights on the front panel, and by
toggling these switches you could input the program directly into the
memory of the system. More important, you could step through your
program one machine language instruction at a time, seeing the results
of each instruction on the accumulator of the machine and in the program
counter (also designated by lights on the console).
</p><p>
Most people did not enter their entire program through the switches, of
course; they used an ASR-33 Teletype to enter the source code of the
assembly languages into an editor, punched out a source-code paper
tape, input that tape to an assembler and (finally)
got an object-level tape punched that would contain the 1s and
0s to be fed into the computer.
</p><p>
One turnaround of your program typically took 45 minutes at a minimum.
It took five minutes to read in the editor (paper tape). Next, you typed
in your program, did a few edits and punched out your program onto new
paper tape. Then, you read in the three-pass assembler (15 minutes of
paper-tape reading), read in your source-code program (assuming your
paper tape did not rip) and punched out the binary (paper) tape that
contained your program.
</p><p>
Finally, you read your binary paper tape into the memory of the
computer, watched while the program probably over-wrote itself and
everything else in real memory, and then you started the whole process
over again (after cursing loudly at the programming gods).
</p><p>
But, it was fun and a challenge. And, it was the &ldquo;will of the
machine&rdquo;
versus the pure logic of 1s and 0s. I was hooked.
</p><p>
During this same period, I switched from being an Electrical Engineer to
a major that was both engineering and business, with a minor in what
became Computer Science. I studied several different languages:
Algol, Lisp, PL/I, SNOBOL and APL, each one with its own special niche
in the computer field.
</p><p>
I remember SNOBOL as a language for string processing, and although I do
not remember much of it, I do remember thinking that almost any string
of characters input into a SNOBOL compiler would generate some type of
syntactically correct program. I remember thinking that the only syntax
error that might be generated was the lack of the END statement.
</p><p>
APL, on the other hand, was an array programming language that was very
powerful. It even fostered its own special set of symbols that meant
you had to paint them on the side of the keys of your regular keyboard,
and (in the case of an IBM Selectric typewriter) use a print head
specially made for APL.
</p><p>
In a class on comparative language design, our professor gave us a
challenge of re-implementing a 40-line FORTRAN program in as few
lines of APL as possible. Most of us reduced the FORTRAN program to
three lines of APL, some to two lines of APL. And, one of the brightest
students in the class (David Erb) had stayed up the entire night
reducing the program to only one line of APL. It was a truly amazing
line of code.
</p><p>
After inputting the data to the program and seeing the correct result,
the professor (with a gleam in his eye) asked David to explain how the
program worked. David, having finished the program only hours before,
tried desperately to remember how it actually worked, but he could not
explain how he had come to that particular single line, or even how it
would produce the desired result.
</p><p>
As a class, we had experienced our first &ldquo;write-only&rdquo; language. It was a
lesson remembered over the next 38 years&mdash;never write a
program you could not easily change or re-use.
</p><p>
It was an interesting time in the days before Computer Science
degrees. It was more like &ldquo;Computer Black Magic&rdquo;, where the
computers were owned by the Math Department, the Electrical Engineering
Department, the Business school, the Physics Department and so forth. I even
had one professor who told me I never would be able to make a
living writing software. It has yet to be seen if he was correct.
</p><p>
And, as time went on and computers became more and more important to the
world, universities started granting Computer Science, Computer
Engineering, Network Engineering and Information Science
degrees. And, what we experienced as very painful steps toward
understanding these procedures became formalized into what we now call
(generally) Computer Science.
</p><p>
I eventually graduated from Drexel University, and in looking
for my first job, I was determined that I would not program in a
&ldquo;higher-level language&rdquo;, such as FORTRAN or COBOL. I wanted to program in assembly
language. I turned down many jobs, looking for that chance.
</p><p>
Eventually, that chance came to me: to program in the systems programming
group of Aetna Life and Casualty in Basic Assembly Language (BAL) for
the IBM 360 series computer&mdash;an assembly language and computer system I
had never seen before. They asked me if I could program it in assembly
language. I said, &ldquo;Sure, just show me the book.&rdquo;
</p><p>
Fortunately there was a book, <span   class="emphasis"><em>Programming the IBM 360 in
BAL</em></span>, and after reading it and practicing a few days at Aetna, I
started a four-year career of system programming there&mdash;a time in my
life where I learned many, many things.
</p><p>
The one &ldquo;language&rdquo;, if I may call it that, which sustained me over the
years, however, was the 1s and 0s of machine code.
</p><p>
It was machine code that allowed me to learn how compilers and
interpreters can translate different languages to what the machine can
follow. It was machine code that showed me how reentrant and recursive
languages worked, and how minute changes in the code of a program could
cut many minutes, if not hours or days, off a program's execution.
</p><p>
It was the study of machine code and machine architecture that allowed
me to know how the operating system really worked, and allowed me to
understand the protocols of networking. And, it was machine code and
looking at the sources of it that let me understand the issues of
big-endian versus little-endian and single-precision versus
double-precision.
</p><p>
And, it was the knowledge of machine language that allowed me to find
places where the compilers had made mistakes in doing the translation of
source code to those 1s and 0s. People who knew only higher-level
languages could have kept looking at the source code of those high-level
languages forever and would not have found the problems.
</p><p>
Nevertheless, other than brief excursions into teaching machine and
assembly language courses (the last time was in 1985 when I taught a
course in PDP-11 assembly language, another assembly language that I 
taught myself), I have not actually written in assembly or machine
language since I left Aetna in 1977.
</p><p>
The simple reason is that it takes too long to write in those low-level
languages, and it is too error-prone. Compiler optimization
techniques have gotten better, CPUs faster, memories cheaper and
people's time more expensive. Don't get me wrong; there still
are plenty of places where assembly language and machine code are used,
particularly in places that need absolutely the best performance or the
smallest size. But overall, the compilers are doing a pretty good job,
and the average person's mind does not adapt well to the tedious task of
writing in assembly.
</p><p>
Yet, when I do sit down and write a bit of code in some modern language, I
do two things:
</p><div class="itemizedlist"><ul type="disc"><li><p>
I think about whether there is a language that can do the
program better and in a clearer, more human-maintainable way.
</p></li><li><p>
I think about what that language may be generating in machine language
and whether changes to the source code or to the algorithm or to
the way the data is positioned in memory might affect the speed at which
the program runs.
</p></li></ul></div><p>
A friend of mine, David Mossberger, once did a study of multiplying two
very large arrays. One multiplication was done in the standard
linear-algebra &ldquo;textbook&rdquo; fashion of analyzing rows and columns. The
second multiplication took into account the cache of the CPU and memory,
knowing how the 1s and 0s were arranged. The second
multiplication took one-fortieth of the time on an Alpha processor
(which had large cache memories), and one-tenth of the time on an
Intel processor (with smaller cache memories).
</p><p>
During the years, I have been exposed to many new languages and many new
technologies. I have been able to understand each and every one because
I stop to think about what the 1s and 0s are doing. There have
been few new computer technologies that have stumped me in the past
38 years.
</p><p>
This is why I object to colleges and universities who feel that
high-level languages, such as Java (or Python, or PHP, or you name it) are
the only languages worth teaching, and that machine and assembly
languages are not worth teaching to students.
</p><p>
In the end, it all comes down to 1s and 0s, and if you do not
know what they are doing, and how the machine actually works, you
are at the mercy of others.
</p><p>
In a lot of ways, machine code and assembly language are like
Latin&mdash;perhaps little used, but still useful to know for the serious
language enthusiast and programmer.
</p><p>
Carpe diem from the <span   class="emphasis"><em>Agape</em></span>.
</p></div></div>
<div class="authorblurb"><p>
Jon &ldquo;maddog&rdquo; Hall is the Executive Director of Linux
International
(<a href="http://www.li.org" target="_self">www.li.org</a>), a nonprofit association of end users
who wish to support and promote the Linux operating system. During his
career in commercial computing, which started in 1969, Mr Hall has been
a programmer, systems designer, systems administrator, product manager,
technical marketing manager and educator. He has worked for such
companies as Western Electric Corporation, Aetna Life and Casualty, Bell
Laboratories, Digital Equipment Corporation, VA Linux Systems and SGI.
He is now an independent consultant in Free and Open Source Software
(FOSS) Business and Technical issues.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../158/toc158.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>