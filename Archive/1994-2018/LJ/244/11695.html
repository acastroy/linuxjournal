<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Promise Theory&mdash;What Is It?
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Mark Burgess describes the idea behind Promise Theory&mdash;the framework&#10;developed between Oslo University College&#10;and the University of Amsterdam during the past decade to solve the problem of&#10;configuring distributed systems and services.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xd7b580.0xe72ac0"></a>
Promise Theory&mdash;What Is It?
</h1></div><div><div class="author"><h3 class="author">
Mark
 
Burgess
</h3></div><div class="issuemoyr">Issue #244, August 2014</div></div><div><p>
Mark Burgess describes the idea behind Promise Theory&mdash;the framework
developed between Oslo University College
and the University of Amsterdam during the past decade to solve the problem of
configuring distributed systems and services.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe732a8"></a></h2></div></div><p>
During the past 20 years, there has been a growing sense of inadequacy
about the &ldquo;command and control&rdquo; model for managing IT systems. Years in
front of the television with a remote control have left us hard pressed to
think of any other way of making machines work for us. But, the truth is
that point-and-click, imperative scripting and remote execution do not
scale very well when you are trying to govern the behavior of a large
number of things.
</p><p>
IT installations grow to massive size in data centers, and the idea of
remote command and control, by an external manager, struggles to keep pace,
because it is an essentially manual human-centric activity. Thankfully, a
simple way out of this dilemma was proposed in 2005 and has acquired a
growing band of disciples in computing and networking. This involves the
harnessing of autonomous distributed agents.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe73510"></a>
From Imposing to Obtaining</h2></div></div><p>
Imagine that we want to implement a software design or enact a business
process. For cultural reasons, our first thought is to want to issue a list
of instructions to all the parts involved to carry out some kind of an
algorithm, but that might not be the best choice at scale. An algorithm is
just a story we tell ourselves about how we envisage the process in
our minds. Often we try to tell the same story to a computer or to a team
of people, in the form of a flow chart or scripted language. This is one
way of describing, building or processing the design. The algorithm might
involve a lot of detail and take the form of step-by-step instructions, but
other approaches use parallelism or non-linear stories to lay out the job
more efficiently. In either case, the instructor assumes that all of the
parts involved simply will do exactly as they are instructed. Alas, this is
not necessarily true. Remote parts of a system might be unable to comply
with these instructions, or even be unwilling to comply, depending on their
nature and their circumstances.
</p><p>
This command and control model is called an obligation model in computer
science. It has many problems. One of those problems is that it separates
intent from implementation, creating uncertainty of outcome. The place
where the instructions are determined is not the place where they must be
carried out, so the instructor does not have the information about
conditions where the local work needs to take place. If two different
instructors start issuing conflicting instructions to the same set of
parts, there would start a conflict, which no part of the system would be
able to resolve, because none of the parts would have the information in one
place: intent is not local to the point of action. The instructors might
not even be aware of each other to resolve the conflict.
</p><div       class="mediaobject"><a href="11695f1.large.jpg"><img src="11695f1.jpg"></a><div class="caption"><p>
Figure 1. Obligation Model vs. Promise Theory
</p></div></div><p>
Luckily, there is a complementary approach to looking at design that fixes
these deficiencies, not in terms of obligations, but in terms of promises.
</p><p>
In a promise-based design, each part behaves only according to the promises
it makes to others. Instead of instructions from without, we have behavior
promised from within. Since the promises are made by &ldquo;self&rdquo; (human self or
machine self), it means that the decision is always made with knowledge of
the same circumstances under which implementation will take place.
Moreover, if two promises conflict with one another, the agent has complete
information about those circumstances and conflicting intentions to be able
to resolve them without having to ask for external help.
</p><p>
A promise-oriented view is somewhat like a service view. Instead of trying
to remote-control things with strings and levers, one makes use of an
ecosystem of promised services that advertise intent and offer a basic
level of certainty about how they will behave. Promises are about
expectation management, and knowing the services and their properties that
will help us to compose a working system. It doesn't matter here how we get
components in a system to make the kinds of promises we need&mdash;that is a
separate problem.
</p><p>
Electronics are built in this way, as is plumbing and other commoditized
construction methods. You buy components (from a suitable supplier) that
promise certain properties (resistance, capacitance, voltage-current
relationships), and you combine them based on those expectations into a
circuit that keeps a greater promise (like being a radio transmitter or a
computer).
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe73a38"></a>
Example&mdash;CSS</h2></div></div><p>
To offer an example of a promise-oriented language, think of HTML and
cascading style sheets on the Web. One can break up a Web page into
labeled and tagged objects like titles and paragraphs, tables and images
and so on. Each of these may be tagged with a specific identity, simply a
type (like title, paragraph, link and so on). In a Promise Theory model, these
regions could be viewed as &ldquo;autonomous agents&rdquo;, which through CSS, make
promises about what color, font and spacing they will use to render their
content initially and over time. The HTML file has regions of the form:

<pre     class="programlisting">

&lt;h1&gt;Title...&lt;/h1&gt;
&lt;p&gt;Text....&lt;/p&gt;

</pre>
</p><p>
Although these are regions of a text file, this is not substantially
different from files on a disk. It is just a collection of containers. The
CSS promises look like this:

<pre     class="programlisting">
h1.main {color: red; font-size: 12px; }
p.main  {text-align:justify;}
</pre>
</p><p>
That is, a header h1 in section &ldquo;main&rdquo; would be red and use
12-point text.
Compare this to files. The configuration tool CFEngine for building and
maintaining computers, allows us to keep promises about what attributes
system resources will have. For example, instead of colors and fonts,
files can promise to have certain permissions, content and names. One would
write:

<pre     class="programlisting">
files:
 debian::
   "/etc/passwd"
      perms =&gt; mo("root", "644");
</pre>
</p><p>
The language looks superficially different, but it basically is the same kind
of declarative association between patterns of objects and what they
promise. The promise a region makes itself is the one it will render for
all time, until the promise has changed. So this is not a fire-and-forget
push-button command, but rather the description of a state to be
continuously maintained. In CFEngine style, we could write this alternative
form of the HTML style sheet:

<pre     class="programlisting">
html:
 main::
  "h1"
    font_size =&gt; "12px",
        color =&gt; "red";
  "p"
    text_align =&gt; "justify";
</pre>
</p><p>
From Promise Theory, we see that these patterns are basically the same;
thus, one could say that CFEngine is a kind of &ldquo;style sheet for
servers&rdquo;, in
this sense.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe73f60"></a>
Composition of Promises</h2></div></div><p>
Promise Theory deals with how to think, in this way, about a much wider
range of problems. It was proposed (by myself) in 2005 as a way to
formalize how the UNIX configuration engine CFEngine intuitively addressed
the problem of managing distributed infrastructure. Such formal models are
important in computer science to prove correctness. It has since been
developed by myself and Jan Bergstra, and it is being adopted by an increasing
number of others.
</p><p>
This complementary non-command way of thinking seems unnatural to us in the
context of infrastructure, but more usual in the context of Web pages. Its
strengths are that it applies equally to human and machine systems, and
that it enforces a discipline of documenting the information necessary and
sufficient to implement a design as promises. It is literally actionable
(executable) documentation. One can easily convert to a complementary
promise view by changing:

<pre     class="programlisting">
"YOU MUST (NOT)..." ---&gt; "I PROMISE TO (NOT) ..."
</pre>
</p><p>
A side effect of documenting the necessary and sufficient conditions for a
purpose is that one sees all of the possible failure modes of a design
enumerated as promises: &ldquo;what if that promise is not kept?&rdquo; Autonomy
guarantees no hidden assumptions.
</p><p>
The main challenge faced in this view is how to see the desired effect
emerge from these promises. What story do we tell about the system? In
imperative programming languages, the linear story is the code itself.
However, in a promise language, the human story is only implicit in a set
of enabling promises. We have to tell the story of what happened
differently. For some, this is a difficult transition to make, in the noble
tradition of Prolog and Lisp and other functional languages. However, at
scale and complexity, human stories are already so hard to tell that the
promise approach becomes necessary.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe74278"></a>
Configuration Management</h2></div></div><p>
The way we view the world in Promise Theory is as a collection of agents
or nested containers of things that can keep promises. These containers
could be:
</p><div class="itemizedlist"><ul type="disc"><li><p>
A part of a file.
</p></li><li><p>
A file.
</p></li><li><p>
A directory (of files).
</p></li><li><p>
A partition (of directories).
</p></li><li><p>
A container (or logical partition).
</p></li><li><p>
A virtual machine (or logical machine).
</p></li><li><p>
A local area network (of machines), etc.
</p></li></ul></div><p>
The reference software with this kind of thinking is still CFEngine
(version 3), as it was designed explicitly in this model, though several
software systems work in an implicitly promise-oriented fashion. Promise
thinking permeates the world of networking too, where autonomy is built
into the modus operandi of the devices. Other examples where promises are
made to users include interfaces and APIs, microservices or Service
Oriented Architecture (SOA).
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe74900"></a>
Knowledge-Oriented Service Design</h2></div></div><p>
Promises turn design and configuration into a form of knowledge management,
by shifting the attention away from what changes (or which algorithms to
enact), onto what interfaces exist between components and what promises
they keep and why. The service-oriented style of programming, made famous
by Amazon and Netflix, uses this approach for scalability (not only
machine scalability but for scaling human ownership). It is hailed as a
cloud-friendly approach to designing systems, but Promise Theory also tells
us that it is the route to very large scale. Applications have to be
extensible by cooperation (sometimes called horizontal scaling through
parallelism rather than vertical scaling through brute force). Databases
like Cassandra illustrate how to deal with the issues of scale, redundancy
and relativity.
</p><p>
Perhaps interestingly, biology has selected redundant services as its model
for scaling tissue-based organisms. This offers a strong clue that we are
on the right track. Avoiding strong dependencies is a way to avoid
bottlenecks, so this shows the route to scalability.
</p><p>
Autonomy and standalone thinking seem to fly in the face of what we
normally learn about programming&mdash;that is, to share resources, but this is not
necessarily true. Security and scalability both thrive under autonomy, and
complexity melts away when the dependencies between parts are removed and
all control is from within. The near future world of mobile and embedded
devices will not tolerate a remote-control model of management, and the
sprawl of the cloud's server back end will force us to decentralize
3-D-printed micro-data centers, like the electricity substations of today.
In this world, I think we can expect to see more of the autonomous thinking
pervading society.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7b580.0xe74ab8"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Mark Burgess is the founder, CTO and original author of CFEngine. Formerly
Professor of Network and System Administration at Oslo University College,
he led the way in theory and practice of automation and policy-based
management for 20 years. In the 1990s, he underlined the importance of
idempotent, autonomous desired state management (&ldquo;convergence&rdquo;) and
formalised cooperative systems in the 2000s (&ldquo;promise theory&rdquo;). He is the
author of numerous books and papers on Network and System Administration.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../244/toc244.html">Issue Table of Contents</a>
    <a class="link3" href="../244/11695.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>