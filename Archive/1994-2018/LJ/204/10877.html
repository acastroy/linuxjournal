<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Zotonic: the Erlang Content Management System
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;It's more than just a CMS. Create complicated Web sites quickly with Zotonic.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x21ba580.0x22b1ac0"></a>
Zotonic: the Erlang Content Management System
</h1></div><div><div class="author"><h3 class="author">
Michael
 
Connors
</h3></div><div class="issuemoyr">Issue #204, April 2011</div></div><div><p>
It's more than just a CMS. Create complicated Web sites quickly with Zotonic.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b2250"></a></h2></div></div><p>
Described by its authors as a pragmatic and modern CMS, Zotonic is that
and much more. When I started using Zotonic, it was because of its
efficiency and the fact that I could pack several client CMS sites
onto a machine with only humble resources. I soon discovered, however,
that Zotonic is not only a CMS, but also a Web framework, which allows
me to create very complicated Web sites in a fraction of the time
it would have taken me using more traditional languages and frameworks.
Zotonic won't fall over if it encounters an error, and it does not need to be
poked with a stick and awakened every time a request comes in.
</p><p>
Zotonic is written in Erlang, a functional language that was designed
for programming telephone switches. The logic behind using Erlang for Web
development is that modern Web sites, with their plethora of connections
from users and robots, are starting to look more and more like telephone
exchanges. &ldquo;I have never programmed in a functional language, and
Erlang looks like Dutch to me!&rdquo;, I hear you say. Well, the authors of
Zotonic are fluent in Erlang (and Dutch, incidentally), and they have done a
good job of creating a piece of software that is useful out of the box,
regardless of whether you know Erlang, and Zotonic could be just
the killer app you need to dive in and learn Erlang.
</p><p>
Another attractive feature of Zotonic is its PostgreSQL database (see
sidebar).
As someone who has toyed with learning Erlang
for a while, probably one of the big barriers was that on top of learning
a completely new programming paradigm, I also would have to learn a
new database in the form of mnesia. Zotonic's use of PostgreSQL means
one less new thing to learn and at least allows me to feel in familiar
territory when I am designing my data.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b2568"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Note:</b></p><p>
The only database offered by Zotonic at the moment is PostgreSQL;
however, there are plans to create &ldquo;Elastic Zotonic&rdquo;, which
will use a
distributed store. Although Zotonic does use a relational database,
in most cases, what you are inserting into the database will be a
Zotonic resource with a key (ID) and a document (Props). Relationships
between resources are defined using predicates, such as has_relation and
has_part. For a lot of Web development, this is all you need; however, if
you do need it, the power of the relational database is available to you.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b27d0"></a></h2></div></div><div class="sidebar"><p class="title"><b>Update:</b></p><p>
As it stands, the default Zotonic branch is under heavy development, and
installation instructions have changed slightly from the time this article
went to press. You can clone the 0.6
version instead using <tt  >hg clone -r release-0.6.x
https://zotonic.googlecode.com/hg/ zotonic</tt>. If you want to live
on the edge,
see the new instructions for the default
branch: <a href="http://code.google.com/p/zotonic/source/browse/doc/INSTALL" target="_self">code.google.com/p/zotonic/source/browse/doc/INSTALL</a>.
</p><p>
You also can check out the very active Zotonic Google group if you need
further help.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b2ae8"></a>
Dependencies</h2></div></div><p>
I am running the latest version of Ubuntu, which has Erlang
preinstalled. You can test whether you have Erlang by typing
<tt  >erl</tt> at the
command line. If you get the Erlang shell, you are good to go. Press Ctrl-c,
followed by the letter a and carriage return to exit Erlang. If you don't have
Erlang on your system, you can download it from the Erlang Web site or
install it with your distribution's package manager.
</p><p>
Another dependency is ImageMagick; to check whether it's installed, run:

<pre     class="programlisting">
convert -version
</pre>
</p><p>
You, of course, need to have PostgreSQL installed, and you need
Mercurial installed to fetch the latest version of Zotonic from the
Google code site.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b2d50"></a>
Installing and Configuring Zotonic</h2></div></div><p>
Fetch the Zotonic source and build it:

<pre     class="programlisting">
hg clone https://zotonic.googlecode.com/hg/ zotonic
cd zotonic
make
</pre>
</p><p>
Now, create a database for Zotonic:

<pre     class="programlisting">
CREATE USER zotonic WITH PASSWORD 'yourdbpassword';
CREATE DATABASE zotonic 
    WITH OWNER = zotonic ENCODING = 'UTF8';
GRANT ALL ON DATABASE zotonic TO zotonic;
\c zotonic
CREATE LANGUAGE "plpgsql";
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b2f60"></a>
The Default Site</h2></div></div><p>
Zotonic comes complete with an example site, which implements a simple
blog. You can find the code for this default site in priv/sites/default/,
and you can get this default site running by creating a config file and
starting Zotonic.
</p><p>
Find the sample config file in priv/sites/default/config.in, and rename
it or create a copy with no extension:


<pre     class="programlisting">
cp priv/sites/default/config.in priv/sites/default/config
</pre>
</p><p>
Open config in your favourite text editor, and modify it to use the
database you just created:

<pre     class="programlisting">
% Hostname for virtual host support
{hostname, "127.0.0.1:8000"},
{hostalias, "localhost:8000"},
% PostgreSQL database connection
{dbhost, "127.0.0.1"},
{dbport, 5432},
{dbuser, "zotonic"},
{dbpassword, "yourdbpassword"},
{dbdatabase, "zotonic"},
</pre>
</p><p>
Now, start Zotonic in debug mode using start.sh:

<pre     class="programlisting">
./start.sh
</pre>
</p><p>
You should see text fly by on the console that suggests some tables
are being created.
Point your browser at 127.0.0.1:8000, and you should see your new blog.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b3328"></a>
Using Zotonic for Content Management</h2></div></div><p>
Zotonic is first and foremost a content management system&mdash;that is what
it says on the tin. Now that you have a running version of Zotonic,
you can try out the content management features.
</p><p>
Point your browser at http://127.0.0.1:8000/admin.
You will see a login screen, and as this is your first login,
you need to set the password.
</p><p>
Use the login name &ldquo;admin&rdquo;, leave the password field empty, and click
Log On. You will see the create password form.
</p><p>
Once you have set your password, you are presented with the Zotonic admin
dashboard. Down on the left-hand side is the admin menu. Much
of it is straightforward, but one of the more interesting items here
is modules.
</p><div       class="mediaobject"><a href="10877f1.large.jpg"><img src="10877f1.jpg"></a><div class="caption"><p>
Figure 1. Zotonic Dashboard and Broadcast Dialog
</p></div></div><p>
In the Modules menu item, there's a list of available modules,
some of them activated, others not. Activate the comments module to
see the comments form appear at the bottom of your blog posts.
</p><p>
You can create a new blog post by creating a new page of category
&ldquo;article&rdquo;. 
</p><p>
In the list of pages, find the home page. You also can find it by
searching for &ldquo;home&rdquo; using the search box on the top right of
the admin page. 
</p><p>
Open this page for editing, and scroll down it until you see advanced
options. Expand the advanced options section, and notice that the home
page has a unique name of page_home set. This is useful for referring
to this page later in your code.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x22b3958"></a>
Customizing the Front End</h2></div></div><p>
Zotonic uses a modified version of Erlydtl for templating. Erlydtl is
an Erlang implementation of the Django templating language.
</p><p>
Look in the templates folder of the default Zotonic site
(priv/sites/default/templates). Here you will find a collection of .tpl
files, which are templates that define the site. Templates that start
with an underscore are not intended to be rendered alone, but rather
can be included in another template.
</p><p>
Most of the templates in this directory inherit from base.tpl, which
includes the site's header, menu and footer. This site uses article.tpl
for displaying pages of the category &ldquo;article&rdquo; and uses home.tpl to
display the home page.
</p><p>
Dispatch rules map URIs to resources. Look in the file
priv/sites/default/dispatch/dispatch. The following two dispatch rules
are defined:

<pre     class="programlisting">
{
     home,  [],
     resource_page, 
     [ {template, "home.tpl"}, {id, page_home} ]
 },
{
     article, ["article", id, slug],
     resource_page,
     [ {template, "article.tpl"}, {cat, article} ]
},
</pre>
</p><p>
The first rule states that you render the page with the unique name of
page_home using the template home.tpl.
</p><p>
The second rule says that you want to render all pages of
category article to article.tpl. You also define the structure of
the URL in this rule. Each article will have an address of this form:
/article/id/page-name.
</p><p>
In both of these examples, you use resource_page to do the actual
rendering. This renders a resource as an HTML page and gives you access
to the ID and category of the page from the template.
</p><p>
Other text pages you create will be rendered to page.tpl by default.
</p><p>
An about page, with the unique name page_about already exists in the
default Zotonic site; it is currently rendered to page.tpl. Let's try
making our own template to display the about page.
</p><p>
Create a template in the templates directory called about.tpl, and put the
following code in it:

<pre     class="programlisting">

{% extends "base.tpl" %}
    
{% block title %}
    {{ m.rsc[id].title }}
{% endblock %}
    
{% block content %}
    
    &lt;h1&gt;{{ m.rsc[id].title }}
             -- {{ m.rsc[id].summary }}&lt;/h1&gt;
   &lt;h2&gt;Hello, this is my about page!&lt;/h2&gt;
    {{ m.rsc[id].body|show_media }}
    
{% endblock %}

</pre>
</p><p>
Add the following to your dispatch rules:

<pre     class="programlisting">
{about,      ["about"],
                  resource_page,
                  [ 
                      {template, "about.tpl"}, 
                      {id, page_about}
                  ]
}
</pre>
</p><p>
Stop Zotonic, and run <tt  >make</tt>.
</p><p>
Start Zotonic again.
Now, if you go to http://127.0.0.1:8000/about in your browser, you will
see the text from the default about page rendered using the new template
you created.
</p><p>
Having access to the ID of the about resource from the template, you
can make calls to the database to retrieve other information
to display. As you can see from the template above, I used the title
(m.rsc[id].title), the summary (m.rsc[id].summary) and the body
(m.rsc[id].body). I also used a &ldquo;filter&rdquo; called show_media to
convert image markers in the body text into actual image tags for display.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x26ac338"></a>
Summary of Some Other Front-End Tools</h2></div></div><p>
You already have seen the show_media filter above, and many other filters exist
to transform data for output. Other than filters, front-end development
in Zotonic is aided by tags and scomps.
</p><p>
In the example above, I used the block tag to replace the content area
in the template that I'm extending.
Other tags that I use often are if, for and lib:

<pre     class="programlisting">

{% if id == 1 %}
    &lt;p&gt;The ID is 1&lt;/p&gt;
{% endif %}
    
{% for color in ["bleu", "blanc", "rouge"] %}
    &lt;p&gt;{{ color }}&lt;/p&gt;
{% endfor %}

</pre>
</p><p>
The lib tag can be used to import an aggregate of stylesheets or scripts
to reduce the number of requests to the server:

<pre     class="programlisting">
{% lib 
        "css/zp-menu.css"
        "css/zp-project.css"
    
%}
</pre>
</p><p>
Scomps, or screen components, are used when tags are not powerful enough
and more logic is needed. The scomps that I use most frequently are
menu and validate.
</p><p>
Menu is used to insert the standard Zotonic menu into your site:

<pre     class="programlisting">
{% menu id=id %}
</pre>
</p><p>
Validate is used to validate a form field at both the front end and the
back end:

<pre     class="programlisting">

&lt;input 
    type="password" 
    id="password" 
    name="password" value="" /&gt;
&lt;input 
    type="password" 
    id="password2" 
    name="password2" value="" /&gt;
{% validate id="password" 
    type={confirmation match="password2"} %}

</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x26ac758"></a>
Extending the Back End</h2></div></div><p>
If you are willing to write some Erlang code, Zotonic can become much
more than just a content management system. You can extend Zotonic 
with modules. The modules can be stored in the modules subdirectory of
your site.
</p><p>
To make a module, create a modules directory within your site if it does
not already exist:

<pre     class="programlisting">
mdkir priv/sites/default/modules
</pre>
</p><p>
Let's create a simple module that implements a Web site guestbook. Users
will be able to see the existing guestbook posts and add a new post.
</p><p>
Create a directory called mod_guestbook within the modules directory:

<pre     class="programlisting">
mkdir priv/sites/default/modules/mod_guestbook
</pre>
</p><p>
Using your favorite text editor, create a file in this directory called
mod_guestbook.erl, and in this file, put the following code:

<pre     class="programlisting">

%% @author Michael Connors
%% @doc A guestbook module. 
-module(mod_guestbook).
-author("Michael Connors &lt;michael@bring42.net&gt;").
-mod_title("Guestbook").
-mod_description("A simple guestbook module.").
-mod_prio(500).
    
%% interface functions
-export([
    init/1,
    datamodel/0
]).
    
-include_lib("zotonic.hrl").
    
%% @doc Initiates the server.
init(Context) -&gt;
    %% Manage our data model
    z_datamodel:manage(?MODULE, 
                       datamodel(), 
                       Context).
datamodel() -&gt;
    [{categories,
      [
       {gp,
        text,
        [{title, &lt;&lt;"Guestbook Post"&gt;&gt;}]}
      ]
     }
    ].

</pre>
</p><p>
Stop Zotonic and run <tt  >make</tt> again. This will build
your new module. Now,
restart Zotonic, and log in to the admin. Go to the modules page, and
observe that there now is a new module called Guestbook.
</p><p>
You can see here the values defined in the code for author,
mod_title, mod_description and mod_prio. The Prio value indicates the
importance of the module&mdash;the highest being 1 and the default being 500.
Modules with a higher priority are checked first for templates and scomps.
</p><p>
A percentage symbol in Erlang indicates a comment, so any of the lines
in this code preceded by percentage symbols are ignored by the
compiler. The first two lines, although comments, also contain special
notation, which is used to document the program.
</p><p>
Here, I exported init/1. This is because it must be called by external
modules; init has an arity of 1, meaning it takes 1 argument:

<pre     class="programlisting">
-export([
    init/1
]).
</pre>
</p><p>
If I had
a function that took two arguments, I would export it like this:

<pre     class="programlisting">
-export([
    itsname/2
]).
</pre>
</p><p>
You do not need to export datamodel, because it is used only by the init
function in this module.
</p><p>
Init will be called whenever your module is loaded, and the first
time it is called, it will create a new category in Zotonic called
guestbook_post. This will be a subcategory of &ldquo;text&rdquo; and will
have the display name Guestbook Post.
</p><p>
For each guestbook post, you should have a title and summary&mdash;luckily,
all pages in Zotonic already have a title and summary, so without
doing anything else, you can add posts to your guestbook by creating pages
of the category Guestbook Post. Create a few Guestbook Posts now,
ensuring that you fill in the titles and summaries. Also, don't forget to tick
Published; otherwise, they won't be visible to users who are not
logged in. You can use these to test your guestbook's display, which I
discuss next.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x21ba580.0x26acf40"></a>
Templates</h2></div></div><p>
Create a new subdirectory in mod_guestbook called templates:

<pre     class="programlisting">
mkdir priv/sites/default/mod_guestbook/templates
</pre>
</p><p>
Using your favorite text editor, create the following file named guestbook.tpl:

<pre     class="programlisting">

{% extends "base.tpl" %}
    
{% block content %}
&lt;h1&gt;Guestbook&lt;/h1&gt;
&lt;ul id="guestbook-posts" class="guestbook-posts"&gt;
{% with 
    m.search[
        {query cat='gp' sort='-publication_start'}
    ] as posts %}
    {% for post in posts %}
        {% include "_guestbook_post.tpl" %}
    {% endfor %}
{% endwith %}
&lt;/ul&gt;
{% include "_guestbook_form.tpl" %}
{% endblock %}

</pre>
</p><p>
This template fetches the pages of category guestbook_post in order
of publication date; it extends the base template of the site in which
it is used and overrides the &ldquo;content block&rdquo; of that base template.
</p><p>
I also am including two other templates, _guestbook_post.tpl and
_guestbook_form.tpl. I'll create these templates later.
</p><p>
Next, you need a dispatch rule.
Create a new subdirectory of mod_guestbook named dispatch:

<pre     class="programlisting">
mkdir priv/sites/default/mod_guestbook/dispatch
</pre>
</p><p>
Using a text-editor, create a file called dispatch (with no extension)
in the dispatch folder. It should contain the following dispatch rule:

<pre     class="programlisting">
[
    {guestbook, ["guestbook"],    
                resource_template,   
                [ {template, "guestbook.tpl"}]}
].
</pre>
</p><p>
The first parameter above is the name of the rule. This is followed by a
list containing the URI scheme; in this case, it's simply /guestbook. Let's
use a premade Zotonic resource called resource_template to do
the rendering, and the template that you actually will be rendering is
called guestbook.tpl.
</p><p>
Save everything, run <tt  >make</tt> and then restart Zotonic. When you navigate
to 127.0.0.1:8000/guestbook, you will see a page that simply contains
the heading Guestbook.
</p><p>
In the template above, I included another template called
_guestbook_post.tpl, which I did not create yet. This template will
contain the details of each guestbook post and be rendered once for
every guestbook post. Let's create it now in the templates subdirectory
of mod_guestbook:

<pre     class="programlisting">

    &lt;li class="guestbook-post"&gt;
        &lt;p&gt;{{ post.title }}-{{post.summary}}&lt;/p&gt;
    &lt;/li&gt;

</pre>
</p><p>
Run <tt  >make</tt> and reload Zotonic. You now should see the guestbook posts you
created earlier in the admin.
</p><p>
The next step is to allow users to sign the guestbook by creating the
_guestbook_form.tpl template:


<pre     class="programlisting">

{% wire id="guestbook-form" 
            type="submit" 
            postback={np} 
            delegate="mod_guestbook" %}
&lt;form id="guestbook-form" 
            method="post" action="postback"&gt;
  &lt;div&gt;
    &lt;div class="form-item"&gt;
      &lt;label for="title"&gt;Title&lt;/label&gt;
        &lt;input type="text" name="title" id="title" /&gt;
        {% validate id="title" type={presence} %}
    &lt;/div&gt;
    &lt;div class="form-item"&gt;
      &lt;label for="summary"&gt;Summary&lt;/label&gt;
      &lt;input type="text" name="summary" id="summary" /&gt;
      {% validate id="summary" type={presence} %}
    &lt;/div&gt;
    &lt;div class="form-item button-wrapper"&gt;
      &lt;button type="submit"&gt;{_ Post _}&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/form&gt;

</pre>
</p><p>
You use the &ldquo;wire&rdquo; scomp to specify that the form with the
<tt  >id="guestbook-form"</tt> will be handled by the event function of
mod_guestbook. You also use the &ldquo;validate&rdquo; scomp to check for
the presence of the required fields. If you wanted the summary field
to be optional, you could leave out the validate scomp for the summary
field. Here, you just use the presence validator, but there are others, such
as numericality, length, confirmation (for making sure two fields match)
and the very useful format validator, which takes a regular expression.
</p><p>
Now, you need to implement the event function of mod_guestbook to handle
this post:


<pre     class="programlisting">
%% @doc Handle the submit event of guestbook
event({submit, {np, _}, _TriggerId, _TargetId}, C) -&gt;
    T = z_context:get_q_validated("title", C),
    S = z_context:get_q_validated("summary", C),
    CatId = 
    m_category:name_to_id_check(gp, C),
    AC = z_acl:sudo(C),
    Props = [
         {category_id, CatId},
         {title, T},
         {summary, S},
         {is_published, true}],
     {ok, RscID} = m_rsc:insert(Props, AC),
     Post = m_rsc:get(RscId, C),
     TemplateProps = [
         {post, Post}
     ],
     Html = z_template:render("_guestbook_post.tpl",
                                  TemplateProps, AC),
     z_render:insert_top("guestbook-posts", 
                                  Html, AC).
</pre>
</p><p>
Don't forget to export event/2. Now you are writing Erlang code and
making use of some support functions that come with Zotonic.
</p><p>
If you are new to Erlang, the first thing to note is that once a variable
has been bound to a value, it cannot be changed. This may seem strange,
but the idea is to avoid side effects, so that you can write distributed
applications. A nice side effect (I know) is that it makes Erlang easier
to debug.
</p><p>
In Erlang, you use lists and tuples for storing aggregates of data. A list
is enclosed in square brackets and a tuple in curly brackets. Variables
in Erlang start with a capital letter (Props), and you also use atoms, which
are lowercase. Atoms do not have any value associated with themselves;
in essence, they are the value.
</p><p>
Functions that relate to access control are found in z_acl,
and in this case, you use <tt  >z_acl:sudo</tt> to gain superuser rights.
<tt  >z_context:get_q_validated</tt> allows you to get the contents of a validated
field from the post; <tt  >z_template:render</tt> returns a rendered template, and
<tt  >z_render:insert_top</tt> inserts some text at the top of an HTML element with
a given ID. More support functions can be found in src/support.
</p><p>
The code for accessing the database is found in src/models. Here, I accessed
the database to check the ID of a category (m_category:name_to_id_check)
and also to insert a new resource (m_rsc:insert).
</p><p>
The guestbook is not completely finished. You still need to add the
name of the person that signed it. This is easy, however, and you don't
need to go near the database to do it. Simply add a new field to your
form template, modify your event function to handle that field, and
your guestbook will be complete.
</p></div></div>
<div class="authorblurb"><p>
Michael Connors is a freelance software developer from Ireland, but he
currently
lives in Normandy, France. These days, he mostly develops software
in Erlang.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../204/toc204.html">Issue Table of Contents</a>
    <a class="link3" href="../204/10877.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>