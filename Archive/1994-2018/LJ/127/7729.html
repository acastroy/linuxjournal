<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>At the Forge</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Want to give everyone a polite reminder when you have new&#10;content on your Web site?&#10;Give your site the latest syndication standard&#10;and you'll have a new tool to keep visitors coming back.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1c8e580.0x1d85ab0"></a>At the Forge</h1></div><div><h3 class="subtitle"><i>
Aggregating with Atom</i></h3></div><div><div class="author"><h3 class="author">
Reuven
 M. 
Lerner
</h3></div><div class="issuemoyr">Issue #127, November 2004</div></div><div><p>
Want to give everyone a polite reminder when you have new
content on your Web site?
Give your site the latest syndication standard
and you'll have a new tool to keep visitors coming back.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d863a0"></a></h2></div></div><p>
In the world of organized crime, a syndicate is a collection of
gangsters who work together. In the world of newspapers, a syndicate
distributes information to subscribers, allowing each publication to
tailor the content of information it receives. Comics, news stories
and opinion columns often are distributed by syndicates, providing
greater exposure for the authors and more content for the readers.
</p><p>
In the past few years, Web developers also have begun to use the term
syndicate, as both a verb and a noun. Fortunately for our safety,
syndication on the Web has more in common with newspapers than with the
mob. But as with organized crime, many people have been hurt in
public disputes (albeit with words, not guns), leading to a split and
a fair amount of acrimony in the world of Web syndication.
</p><p>
The result of this split is Atom, a new syndication format that has
much in common with RSS (rich site summary or RDF site summary,
depending on the version and whom you ask). I believe that Atom
offers a number of advantages over any version of RSS, and that the
simplicity with which Atom feeds can be created makes it an obvious
choice over RSS. That said, the fact that most Weblog products
provide RSS feeds means that the two camps happily can coexist for
now. Understanding how both work also means your organization can
decide to adopt one or both standards, depending on your needs.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d86558"></a>
Some History</h2></div></div><p>
As we saw last month, RSS really is two different formats, or more
precisely, two different families of formats. RSS 0.9x and RSS 2.0
are from the same family and demonstrate the evolution, over time, of
syndication on the Web. RSS 2.0 is maintained mainly by Dave Winer of
Userland, scripting.com and (most recently) Harvard University.
Winer has given ownership of the standard to Harvard but also
has declared that version 2.0 will be the final one. Nevertheless, the
combination of RSS 0.9x and RSS 2.0 represents a widespread, stable,
well-understood and ambiguous protocol for syndicating Web content.
</p><p>
A separate flavor of RSS, confusingly known as RSS 1.0, uses the
resource development framework (RDF) produced by the World Wide
Web Consortium (W3C). RDF is designed to make it possible for
computers to understand a site's contents, allowing it to make
connections between sites, much as people instinctively do all the
time. RSS 1.0 produces a summary that is incompatible with all other
versions of RSS, using RDF to produce a standardized description of
the site's contents.
</p><p>
The fact that RSS 1.0 used the RSS name caused a great deal of
friction and animosity, with many people variously blaming Dave Winer,
the vagueness of the RSS specification and the proponents of Atom's
predecessor. At the end of the day, a number of prominent
individuals&mdash;led by Tim Bray, Mark Pilgrim and Sam Ruby&mdash;were backed by such
companies as Six Degrees (which publishes Movable Type software for
Weblogs) to produce a specification, initially called PIE and Echo,
which attempts to address the shortcomings of RSS.
</p><p>
The development of Atom took some time, because it involved
understanding and defining exactly what syndication means on today's
World Wide Web. RSS no longer is used only for news sites, its
original target, but also for Weblogs and nontextual content. The
developers decided to make internationalization a top priority,
meaning that it should be possible to produce a syndication feed in
any language. Another priority was the development of extensions&mdash;that is, it should be possible to add new functionality to the Atom
feed without having to redefine the core Atom specification.
</p><p>
As of this writing (mid-August 2004), the Atom specification now
exists in version 0.3, along with a standard API for editing content
over the network. Atom has begun the process of becoming standardized by
the IETF (the Internet Engineering Task Force, which produces and
publishes Internet standards), meaning it is on its way to
being a universally accepted standard, much like TCP/IP, SMTP or
HTTP. This undoubtedly will lead to even greater interest in Atom
from organizations that wait for the IETF's stamp of approval.
</p><p>
Atom is still in its initial stages, lacking public specifications for
a number of items, such as its extension mechanism. But its authors
have, to date, produced a standard whose complexity is fairly close to
RSS 0.9x and 2.0, written in as unambiguous a fashion as
possible, which includes many members of the Web syndication
community and offers a vision of syndication that goes far
beyond the Web.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d86818"></a>
Producing an Atom Feed</h2></div></div><p>
Although RSS was designed to summarize a news feed or Weblog, Atom was
created with a more general purpose in mind. For example, factory
machines could produce status reports in Atom, with an aggregator
displaying those that are malfunctioning. Libraries could produce
Atom feeds of the latest additions to their collections, with smart
aggregators looking for books on certain subjects. Fax machines could
be replaced by fax modems, using Atom to distribute fax images to
appropriate groups of people.
</p><p>
You even could use Atom feeds to create a newspaper publishing system,
where reporters send their stories not as e-mail, but instead publish
drafts on an Atom feed. Each editor would aggregate Atom feeds from
the reporters under his or her control, moving them onto an outgoing
Atom feed when the editing was complete. The final feed would end
up in the production department, where the text would be laid out and
made ready for actual printing. The newspaper's content flow
thus would be a flow of many Atom feeds into a single, final feed
representing the newspaper itself.
</p><p>
Producing an Atom feed is fairly simple, if you use Perl or another
high-level language for which an Atom library exists. Perl, for
example, has the XML::Atom module, available from CPAN
(Comprehensive Perl Archive Network). I had a bit of trouble
installing XML::Atom on my machine running Fedora Core 2 and Perl
5.8.3, but I was able to work around it by ignoring the optional
DateTime module during the installation process. I would not
recommend doing so in a production environment.
</p><p>
Although XML::Atom is the overall package name, programs that create Atom
feeds actually use XML::Atom::Feed and XML::Atom::Entry. Here is a short
Perl program that produces a simple feed, based in part on the sample
program in the perldoc on-line documentation for XML::Atom::Feed:

<pre     class="programlisting">
#!/usr/bin/perl

use strict;
use diagnostics;
use warnings;

use XML::Atom::Feed;
use XML::Atom::Entry;

# Create a new Atom feed
my $feed = XML::Atom::Feed-&gt;new;
$feed-&gt;title('My Weblog');

my $entry;
# Create a first entry for the feed
$entry = XML::Atom::Entry-&gt;new;
$entry-&gt;title('First Post');
$entry-&gt;content('First Post Body');
$feed-&gt;add_entry($entry);

# Create a second entry for the feed
$entry = XML::Atom::Entry-&gt;new;
$entry-&gt;title('Second Post');
$entry-&gt;content('Second Post Body');
$feed-&gt;add_entry($entry);

# Now produce the XML output
my $atom_feed_xml = $feed-&gt;as_xml;

# Display the XML output
print $atom_feed_xml, "\n";
</pre>
</p><p>
The above program produces the following feed, which I have formatted
with extra whitespace for easier reading:

<pre     class="programlisting">

&lt;?xml version="1.0"?&gt;
&lt;feed xmlns="http://purl.org/atom/ns#"&gt;
&lt;title&gt;
    My Weblog
&lt;/title&gt;
&lt;entry &gt;
    &lt;title&gt;
    First Post
    &lt;/title&gt;
    &lt;content mode="xml"&gt;
    &lt;default:div xmlns="http://www.w3.org/1999/xhtml"&gt;
        First Post Body
    &lt;/default:div&gt;
    &lt;/content&gt;
&lt;/entry&gt;
&lt;entry &gt;
    &lt;title&gt;
    Second Post
    &lt;/title&gt;
    &lt;content mode="xml"&gt;
    &lt;default:div xmlns="http://www.w3.org/1999/xhtml"&gt;
        Second Post Body
    &lt;/default:div&gt;
    &lt;/content&gt;
&lt;/entry&gt;
&lt;/feed&gt;

</pre>
</p><p>
As you can see, we create a single XML::Atom::Feed object, containing
one or more instances of XML::Atom::Entry. Each entry object
corresponds to a single &lt;entry&gt; tag in the Atom feed, which in turn
represents a single entry in our Weblog or a single message from our
factory floor.
</p><p>
The Atom specification indicates that the feed may contain a number of
attributes and sub-elements, including a language, a description of the
Weblog or site, copyright information and other general information
about the originating site. Each entry, in turn, has its own set of
elements, such as a title, an indication of when it was created and a
summary. Each Atom element also has a MIME type indicating what type
of content it contains, much like HTTP responses and e-mail
attachments.
</p><p>
Of course, creating a feed, as in the above example, is necessary
only if you are writing a new Atom-powered application or if you are
adding Atom capabilities to a Weblog product. Most Weblog products
now provide Atom feeds, either as part of their standard distribution
or through a plugin or other extension mechanism.
For example, an Atom feed plugin for the Blosxom Weblog product makes
it easy to add such a feed from a Weblog; install the plugin (by
placing it in the plugins directory), and anyone interested in
receiving an Atom feed from the Weblog in question will be able to do
so.
</p><p>
It shouldn't come as a surprise that this is so easy to accomplish,
given the fact that Blosxom is written in Perl, that Perl provides
excellent tools for working with XML and that the plugin simply needs
to summarize and rewrite content from the most recent entries in the
Weblog. Because Blosxom makes it so easy for plugins to modify
the main page (so as to advertise the Atom feed) and to retrieve
content (through the plugin API), it might be slightly easier to work
with Atom from that product. Given that most Weblog products are
written in a high-level language, such as Perl, Python or PHP, it
should be easy to add an Atom feed where none currently exists.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d86c90"></a>
Parsing an Atom Feed</h2></div></div><p>
To parse an Atom feed, either because we are writing an aggregator or
because we want to create an Atom-powered application, we have several
options. The easiest way is to continue to use XML::Atom::Feed
to discover and retrieve feeds, for example:

<pre     class="programlisting">
#!/usr/bin/perl

use strict;
use diagnostics;
use warnings;

use XML::Atom::Feed;

# Get the Atom feeds for www.diveintomark.org
my @uris =
    XML::Atom::Feed-&gt;find_feeds(
        "http://www.diveintomark.org/");

    # Print each Atom feed URI
    foreach my $uri (@uris)
    {
    print "uri = '$uri'\n";
    }
</pre>
</p><p>
In the above example, we see a single URI printed.
Now that we know where the feed is, we can get a list of links in it,
turning those links into XML:

<pre     class="programlisting">
#!/usr/bin/perl

use strict;
use diagnostics;
use warnings;

use XML::Atom::Feed;

# Get an Atom feed
my @uris = XML::Atom::Feed-&gt;find_feeds("http://www.diveintomark.org/");

foreach my $uri (@uris)
{
my $feed = XML::Atom::Feed-&gt;new(URI-&gt;new($uri));

my @links = $feed-&gt;link();

foreach my $link (@links)
{
    my $link_xml = $link-&gt;as_xml();
    print "link = '$link_xml\n";
}
}
</pre>
</p><p>
Of course, we don't have to produce or display XML; we can parse the
link information, sending new links to subscribers by e-mail, adding
them to a database or ignoring those that fail to meet certain
criteria.
</p><p>
Because Atom feeds are so regular, and because they operate using
Internet standards such as XML, Unicode and MIME, we can be confident
that the content our feed parses can be handled in straightforward
ways. We can farm out different content types to different handlers,
parse them in different ways and even (as in the newspaper example
above) place them onto new feeds, becoming a super-aggregator.
</p><p>
If you are interested in creating an aggregator or in understanding
how to work with the different myriad versions of RSS and Atom, it also is
worth looking at Mark Pilgrim's feed aggregator. Written in
Python and constantly updated, this is probably the best-documented
piece of open-source engine for working with syndication feeds.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d86fa8"></a>
RSS or Atom?</h2></div></div><p>
So, should your Web site (or Weblog) provide syndication feeds in RSS,
in Atom or in both?
It is clear to me that Atom is the best of the two (or three)
syndication format families produced to date. Dave Winer's RSS
formats were groundbreaking when they were released, but they have too
many problems to form the basis of full-fledged, enterprise-ready
standards. We have seen the agony that results from half-baked
standards, such as early versions of HTML and JavaScript, and given
that syndication stands a good chance of becoming an important
communication mechanism, completeness and unambiguity are important
factors to consider.
</p><p>
It is similarly important to consider the growing international use of the
Internet and that people want to syndicate media other than
text. Atom's lack of ambiguity regarding special characters is
another big step forward, ensuring that we can include &lt; and &gt; in our
Weblog entries without having to worry about the implications for
syndication. Most important, the planned provisions for extensions
will make it possible for Atom to meet the needs of specific groups
and applications without opening the entire specification anew.
</p><p>
Although Atom is remarkably complete, it is also straightforward to use.
A great deal of time and energy clearly have been put into making Atom
as easy to use as possible. Creating a new API is not a simple task,
particularly when it is meant to be as general as possible.
</p><p>
Finally, the mess of RSS version numbers that resulted in (and from)
petty and political arguments has served no one very well.
Because Atom has a different name, although literally an issue of semantics,
it reduces the confusion that developers and users alike face when
working with RSS.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c8e580.0x1d871b8"></a>
Conclusion</h2></div></div><p>
Atom is an attempt to solve many of the problems associated with RSS
and to turn syndication into a building block for new types of
high-level communication across Internet applications. Atom is
slightly more complicated than Dave Winer's versions of RSS,
but it is less complicated (in its initial version) than RSS 1.0, which
used RDF to describe and summarize Web sites. The combination of
easy-to-use software tools for working with Atom feeds, its
extensibility and the authors' commitment to being a part of the
Internet standards community, makes it clear that Atom will
play a key role in the future of Web communication.
</p><p><span   class="bold"><b>Resources for this article:</b></span>
<a href="../127/7751.html" target="_self">/article/7751</a>.
</p></div></div>
<div class="authorblurb"><p>
Reuven M. Lerner, a longtime Web/database consultant and developer,
now is a graduate student in the Learning Sciences program at
Northwestern University. His Weblog is at <a href="http://altneuland.lerner.co.il" target="_self">altneuland.lerner.co.il</a>, and you can reach him at
<a href="mailto:reuven@lerner.co.il">reuven@lerner.co.il</a>.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../127/toc127.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>