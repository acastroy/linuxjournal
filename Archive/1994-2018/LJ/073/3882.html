<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Why Python?</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Cardinal Biggles had Eric in the comfy chair for over four&#10;    hours before wringing this confession from him...&#10;    "><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x2680580.0x2777ab0"></a>Why Python?</h1></div><div><div class="author"><h3 class="author">Eric Raymond</h3></div><div class="issuemoyr">Issue #73, May 2000</div></div><div><p>
    Cardinal Biggles had Eric in the comfy chair for over four
    hours before wringing this confession from him...
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x2680580.0x27783f8"></a></h2></div></div><p>My first look at Python was an accident,
and I didn't much like what I saw at the time. It was early 1997,
and Mark Lutz's book <span   class="emphasis"><em>Programming Python</em></span> from
O'Reilly &amp; Associates had recently come out. O'Reilly books
occasionally land on my doorstep, selected from among the new
releases by some mysterious benefactor inside the organization
using a random process I've given up trying to understand.
</p><p>One of them was <span   class="emphasis"><em>Programming Python</em></span>. I
found this somewhat interesting, as I collect computer languages. I
know over two dozen general-purpose languages, write compilers and
interpreters for fun, and have designed any number of
special-purpose languages and markup formalisms myself. My most
recently completed project, as I write this, is a special-purpose
language called SNG for manipulating PNG (Portable Network
Graphics) images. Interested readers can surf to the SNG home page
at
<a href="http://www.catb.org/~esr/sng" target="_self">http://www.catb.org/~esr/sng/</a>.
I have also written implementations of several odd general-purpose
languages on my Retrocomputing Museum page,
<a href="http://www.catb.org/retro" target="_self">http://www.catb.org/retro/</a>.</p><p>I had already heard just enough about Python to know that it
is what is nowadays called a &ldquo;scripting language&rdquo;, an
interpretive language with its own built-in memory management and
good facilities for calling and cooperating with other programs. So
I dived into <span   class="emphasis"><em>Programming Python</em></span> with one
question uppermost in my mind: what has this got that Perl does
not?</p><p>Perl, of course, is the 800-pound gorilla of modern scripting
languages. It has largely replaced shell as the scripting language
of choice for system administrators, thanks partly to its
comprehensive set of UNIX library and system calls, and partly to
the huge collection of Perl modules built by a very active Perl
community. The language is commonly estimated to be the CGI
language behind about 85% of the &ldquo;live&rdquo; content on the Net. Larry
Wall, its creator, is rightly considered one of the most important
leaders in the Open Source community, and often ranks third behind
Linus Torvalds and Richard Stallman in the current pantheon of
hacker demigods.</p><p>At that time, I had used Perl for a number of small projects.
I'd found it quite powerful, even if the syntax and some other
aspects of the language seemed rather ad hoc and prone to bite one
if not used with care. It seemed to me that Python would have quite
a hill to climb as yet another scripting language, so as I read, I
looked first for what seemed to set it apart from Perl.</p><p>I immediately tripped over the first odd feature of Python
that everyone notices: the fact that whitespace (indentation) is
actually significant in the language syntax. The language has no
analog of the C and Perl brace syntax; instead, changes in
indentation delimit statement groups. And, like most hackers on
first realizing this fact, I recoiled in reflexive disgust.</p><p>I am just barely old enough to have programmed in batch
FORTRAN for a few months back in the 1970s. Most hackers aren't
these days, but somehow our culture seems to have retained a pretty
accurate folk memory of how nasty those old-style fixed-field
languages were. Indeed, the term &ldquo;free format&rdquo;, used back then to
describe the newer style of token-oriented syntax in Pascal and C,
has almost been forgotten; <span   class="emphasis"><em>all</em></span> languages have
been designed that way for decades now. Or almost all, anyway. It's
hard to blame anyone, on seeing this Python feature, for initially
reacting as though they had unexpectedly stepped in a steaming pile
of dinosaur dung.</p><p>That's certainly how I felt. I skimmed through the rest of
the language description without much interest. I didn't see much
else to recommend Python, except maybe that the syntax seemed
rather cleaner than Perl's and the facilities for doing basic GUI
elements like buttons and menus looked fairly good.</p><p>I put the book back on the shelf, making a mental note that I
should code some kind of small GUI-centered project in Python
sometime, just to make sure I really understood the language. But I
didn't believe what I'd seen would ever compete effectively with
Perl.</p><p>A lot of other things conspired to keep that note way down on
my priority list for many months. The rest of 1997 was eventful for
me; it was, among other things, the year I wrote and published the
original version of &ldquo;The Cathedral and the Bazaar&rdquo;. But I did
find time to write several Perl programs, including two of
significant size and complexity. One of them,
<span   class="bold"><b>keeper</b></span>, is the assistant still
used to file incoming submissions at the Metalab software archive.
It generates the web pages you see at
<a href="http://metalab.unc.edu/pub/Linux/!INDEX.html" target="_self">metalab.unc.edu/pub/Linux/!INDEX.html</a>.
The other, <span   class="bold"><b>anthologize</b></span>, was used
to automatically generate the PostScript for the sixth edition of
Linux from the Linux Documentation Project's archive of HOWTOs.
Both programs are available at Metalab.</p><p>Writing these programs left me progressively less satisfied
with Perl. Larger project size seemed to magnify some of Perl's
annoyances into serious, continuing problems. The syntax that had
seemed merely eccentric at a hundred lines began to seem like a
nigh-impenetrable hedge of thorns at a thousand. &ldquo;More than one
way to do it&rdquo; lent flavor and expressiveness at a small scale, but
made it significantly harder to maintain consistent style across a
wider code base. And many of the features that were later patched
into Perl to address the complexity-control needs of bigger
programs (objects, lexical scoping, &ldquo;use strict&rdquo;, etc.) had a
fragile, jerry-rigged feel about them.</p><p>These problems combined to make large volumes of Perl code
seem unreasonably difficult to read and grasp as a whole after only
a few days' absence. Also, I found I was spending more and more
time wrestling with artifacts of the language rather than my
application problems. And, most damning of all, the resulting code
was ugly&mdash;this matters. Ugly programs are like ugly suspension
bridges: they're much more liable to collapse than pretty ones,
because the way humans (especially engineer-humans) perceive beauty
is intimately related to our ability to process and understand
complexity. A language that makes it hard to write elegant code
makes it hard to write good code.</p><p>With a baseline of two dozen languages under my belt, I could
detect all the telltale signs of a language design that had been
pushed to the edge of its functional envelope. By mid-1997, I was
thinking &ldquo;there has to be a better way&rdquo; and began casting about
for a more elegant scripting language.</p><p>One course I did not consider was going back to C as a
default language. The days when it made sense to do your own memory
management in a new program are long over, outside of a few
specialty areas like kernel hacking, scientific computing and 3-D
graphics&mdash;places where you absolutely must get maximum speed and
tight control of memory usage, because you need to push the
hardware as hard as possible.</p><p>For most other situations, accepting the debugging overhead
of buffer overruns, pointer-aliasing problems,
<span   class="bold"><b>malloc/free</b></span> memory leaks and all
the other associated ills is just crazy on today's machines. Far
better to trade a few cycles and a few kilobytes of memory for the
overhead of a scripting language's memory manager and economize on
far more valuable human time. Indeed, the advantages of this
strategy are precisely what has driven the explosive growth of Perl
since the mid-1990s.</p><p>I flirted with Tcl, only to discover quickly that it scales
up even more poorly than Perl. Old LISPer that I am, I also looked
at various current dialects of Lisp and Scheme&mdash;but, as is
historically usual for Lisp, lots of clever design was rendered
almost useless by scanty or nonexistent documentation, incomplete
access to POSIX/UNIX facilities, and a small but nevertheless
deeply fragmented user community. Perl's popularity is not an
accident; most of its competitors are either worse than Perl for
large projects or somehow nowhere near as useful as their
theoretically superior designs ought to make them.</p><p>My second look at Python was almost as accidental as my
first. In October 1997, a series of questions on the
fetchmail-friends mailing list made it clear that end users were
having increasing trouble generating configuration files for my
<span   class="bold"><b>fetchmail</b></span> utility. The file uses a
simple, classically UNIX free-format syntax, but can become
forbiddingly complicated when a user has POP3 and IMAP accounts at
multiple sites. As an example, see Listing 1 for a somewhat
simplified version of mine.</p><p><a href="3882l1.html" target="_self">Listing 1</a></p><p>I decided to attack the problem by writing an
end-user-friendly configuration editor,
<span   class="bold"><b>fetchmailconf</b></span>. The design
objective of fetchmailconf was clear: to completely hide the
control file syntax behind a fashionable, ergonomically correct GUI
interface replete with selection buttons, slider bars and fill-out
forms.</p><p>The thought of implementing this in Perl did not thrill me. I
had seen GUI code in Perl, and it was a spiky mixture of Perl and
Tcl that looked even uglier than my own pure-Perl code. It was at
this point I remembered the bit I had set more than six months
earlier. This could be an opportunity to get some hands-on
experience with Python.</p><p>Of course, this brought me face to face once again with
Python's <span   class="emphasis"><em>pons asinorum</em></span>, the significance of
whitespace. This time, however, I charged ahead and roughed out
some code for a handful of sample GUI elements. Oddly enough,
Python's use of whitespace stopped feeling unnatural after about
twenty minutes. I just indented code, pretty much as I would have
done in a C program anyway, and it worked.</p><p>That was my first surprise. My second came a couple of hours
into the project, when I noticed (allowing for pauses needed to
look up new features in <span   class="emphasis"><em>Programming Python</em></span>) I
was generating <span   class="emphasis"><em>working</em></span> code nearly as fast as
I could type. When I realized this, I was quite startled. An
important measure of effort in coding is the frequency with which
you write something that doesn't actually match your mental
representation of the problem, and have to backtrack on realizing
that what you just typed won't actually tell the language to do
what you're thinking. An important measure of good language design
is how rapidly the percentage of missteps of this kind falls as you
gain experience with the language.</p><p>When you're writing working code nearly as fast as you can
type and your misstep rate is near zero, it generally means you've
achieved mastery of the language. But that didn't make sense,
because it was still day one and I was regularly pausing to look up
new language and library features!</p><p>This was my first clue that, in Python, I was actually
dealing with an exceptionally good design. Most languages have so
much friction and awkwardness built into their design that you
learn most of their feature set long before your misstep rate drops
anywhere near zero. Python was the first general-purpose language
I'd ever used that reversed this process.</p><p>Not that it took me very long to learn the feature set. I
wrote a working, usable fetchmailconf, with GUI, in six working
days, of which perhaps the equivalent of two days were spent
learning Python itself. This reflects another useful property of
the language: it is <span   class="emphasis"><em>compact</em></span>--you can hold its
entire feature set (and at least a concept index of its libraries)
in your head. C is a famously compact language. Perl is notoriously
not; one of the things the notion &ldquo;There's more than one way to do
it!&rdquo; costs Perl is the possibility of compactness.</p><p>But my most dramatic moment of discovery lay ahead. My design
had a problem: I could easily generate configuration files from the
user's GUI actions, but editing them was a much harder problem. Or,
rather, reading them into an editable form was a problem.</p><p>The parser for fetchmail's configuration file syntax is
rather elaborate. It's actually written in YACC and Lex, two
classic UNIX tools for generating language-parsing code in C. In
order for fetchmailconf to be able to edit existing configuration
files, I thought it would have to replicate that elaborate parser
in Python. I was very reluctant to do this, partly because of the
amount of work involved and partly because I wasn't sure how to
ascertain that two parsers in two different languages accept the
same. The last thing I needed was the extra labor of keeping the
two parsers in synchronization as the configuration language
evolved!</p><p>This problem stumped me for a while. Then I had an
inspiration: I'd let fetchmailconf use fetchmail's own parser! I
added a <b  >--configdump</b> option to fetchmail that
would parse .fetchmailrc and dump the result to standard output in
the format of a Python initializer. For the file above, the result
would look roughly like Listing 2 (to save space, some data not
relevant to the example is omitted).</p><p><a href="3882l2.html" target="_self">Listing 2</a></p><p>Python could then evaluate the fetchmail
<b  >--configdump</b> output and have the configuration
available as the value of the variable &ldquo;fetchmail&rdquo;.</p><p>This wasn't quite the last step in the dance. What I really
wanted wasn't just for fetchmailconf to have the existing
configuration, but to turn it into a linked tree of live objects.
There would be three kinds of objects in this tree:
<span   class="bold"><b>Configuration</b></span> (the top-level
object representing the entire configuration),
<span   class="bold"><b>Site</b></span> (representing one of the
sites to be polled) and <span   class="bold"><b>User</b></span>
(representing user data attached to a site). The example file
describes five site objects, each with one user object attached to
it.</p><p>I had already designed and written the three object classes
(that's what took four days, most of it spent getting the layout of
the widgets just right). Each had a method that caused it to pop up
a GUI edit panel to modify its instance data. My last remaining
problem was somehow to transform the dead data in this Python
initializer into live objects.</p><p>I considered writing code that would explicitly know about
the structure of all three classes and use that knowledge to grovel
through the initializer creating matching objects, but rejected
that idea because new class members were likely to be added over
time as the configuration language grew new features. If I wrote
the object-creation code in the obvious way, it would be fragile
and tend to fall out of sync when either the class definitions or
the initializer structure changed.</p><p>What I really wanted was code that would analyze the shape
and members of the initializer, query the class definitions
themselves about their members, and then adjust itself to
impedance-match the two sets.</p><p>This kind of thing is called <span   class="emphasis"><em>metaclass
hacking</em></span> and is generally considered fearsomely
esoteric&mdash;deep black magic. Most object-oriented languages don't
support it at all; in those that do (Perl being one), it tends to
be a complicated and fragile undertaking. I had been impressed by
Python's low coefficient of friction so far, but here was a
<span   class="emphasis"><em>real</em></span> test. How hard would I have to wrestle
with the language to get it to do this? I knew from previous
experience that the bout was likely to be painful, even assuming I
won, but I dived into the book and read up on Python's metaclass
facilities. The resulting function is shown in Listing 3, and the
code that calls it is in Listing 4.</p><p><a href="3882l3.html" target="_self">Listing 3</a></p><p><a href="3882l4.html" target="_self">Listing 4</a></p><p>That doesn't look too bad for deep black magic, does it?
Thirty-two lines, counting comments. Just from knowing what I've
said about the class structure, the calling code is even readable.
But the size of this code isn't the real shocker. Brace yourself:
this code only took me about ninety minutes to write&mdash;and it worked
correctly <span   class="emphasis"><em>the first time I ran it</em></span>.</p><p>To say I was astonished would have been positively wallowing
in understatement. It's remarkable enough when implementations of
<span   class="emphasis"><em>simple</em></span> techniques work exactly as expected the
first time; but my first metaclass hack in a new language, six days
from a cold standing start? Even if we stipulate that I am a fairly
talented hacker, this is an amazing testament to Python's clarity
and elegance of design.</p><p>There was simply no way I could have pulled off a coup like
this in Perl, even with my vastly greater experience level in that
language. It was at this point I realized I was probably leaving
Perl behind.</p><p>This was my most dramatic Python moment. But, when all is
said and done, it was just a clever hack. The long-term usefulness
of a language comes not in its ability to support clever hacks, but
from how well and how unobtrusively it supports the day-to-day work
of programming. The day-to-day work of programming consists not of
writing new programs, but mostly reading and modifying existing
ones.</p><p>So the <span   class="emphasis"><em>real</em></span> punchline of the story is
this: weeks and months after writing fetchmailconf, I could still
read the fetchmailconf code and grok what it was doing without
serious mental effort. And the true reason I no longer write Perl
for anything but tiny projects is that was never true when I was
writing large masses of Perl code. I fear the prospect of ever
having to modify keeper or anthologize again&mdash;but fetchmailconf
gives me no qualms at all.</p><p>Perl still has its uses. For tiny projects (100 lines or
fewer) that involve a lot of text pattern matching, I am still more
likely to tinker up a Perl-regexp-based solution than to reach for
Python. For good recent examples of such things, see the
<span   class="bold"><b>timeseries</b></span> and
<span   class="bold"><b>growthplot</b></span> scripts in the
fetchmail distribution. Actually, these are much like the things
Perl did in its original role as a sort of combination
awk/sed/grep/sh, before it had functions and direct access to the
operating system API. For anything larger or more complex, I have
come to prefer the subtle virtues of Python&mdash;and I think you will,
too.</p><p><a href="3882s1.html" target="_self">Resources</a></p><p>All listings referred to in this article are available by
anonymous download in the file
<a href="../listings/073/3882.tgz" target="_self">ftp.linuxjournal.com/pub/lj/listings/issue73/3882.tgz</a>.
</p></div></div>
<div class="authorblurb"><p>
        <div       class="mediaobject"><img src="3882aa.jpg"></div>
        <span   class="bold"><b>Eric Raymond</b></span>
                is a Linux advocate and
        the author of <span   class="emphasis"><em>The Cathedral &amp; The Bazaar</em></span> . He can be
        reached via e-mail at  (<a href="mailto:esr@thyrsus.com">esr@thyrsus.com</a>).
      </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../073/toc073.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>