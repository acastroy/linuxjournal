<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
At the Forge
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Interact with your Ruby code more easily with Pry, a modern replacement for&#10;IRB.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x16b9580.0x17b0ac0"></a>
At the Forge
</h1></div><div><h3 class="subtitle"><i>
Pry
</i></h3></div><div><div class="author"><h3 class="author">
Reuven
 M. 
Lerner
</h3></div><div class="issuemoyr">Issue #219, July 2012</div></div><div><p>
Interact with your Ruby code more easily with Pry, a modern replacement for
IRB.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17b1358"></a></h2></div></div><p>
I spend a fair amount of my time teaching courses, training
programmers in the use of Ruby and Python, as well as the PostgreSQL
database. And as if my graying hair weren't enough of an indication
that I'm older than many of these programmers, it's often shocking for
them to discover I spend a great deal of time with command-line
tools. I'm sure that modern IDEs are useful for many people&mdash;indeed,
that's what they often tell me&mdash;but for me, GNU Emacs and a
terminal window are all I need to have a productive day.
</p><p>
In particular, I tell my students, I cannot imagine working without
having an interactive copy of the language open in parallel. That is,
I will have one or more Emacs buffers open, and use it to edit my
code. But I'll also be sure to have a Python or Ruby (or JavaScript)
interpreter open in a separate window. That's where I do much of my
work&mdash;trying new ideas, testing code, debugging code that should
have worked in production but didn't, and generally getting a
&ldquo;feel&rdquo;
for the program I'm trying to write.
</p><p>
Indeed, &ldquo;feeling&rdquo; the code is a phenomenon I'm sure other
programmers understand, and I believe it's crucial when really
trying to understand what is going on in a program. It's sort of like
learning a new foreign language. At a certain point, you have an
instinct for what words and conjugations should work, even if
you've never used them before. Sometimes, when things go wrong, if
you have enough experience working with the code, you will have an
internal sense of what has gone wrong&mdash;where to look and how to fix
things. This comes from interacting and working with the code on a
day-to-day basis.
</p><p>
One of the advantages of a dynamic, interpreted language, such as
Python or Ruby, is that you can use a REPL (read-eval-print loop), a program that gives you the chance to
interact with the language directly, typing commands and then getting
responses. A good REPL will let you do everything from experimenting
with one-liners to creating new classes and modules. You're obviously
not going to create production code in such an environment, but you
might well create some classes, objects and methods, and then
experiment with them to see how well they work.
</p><p>
I have been using both Python and Ruby for a number of years, and
I teach classes in both languages on a regular basis. Part of these
classes always involves introducing students to the interactive
versions of these languages&mdash;the <tt  >python</tt> command in the case of
Python and <tt  >irb</tt> in the case of Ruby.
</p><p>
About a year ago, one of my Python students asked me what I knew about
iPython. The fact is that I had heard of it, but hadn't really
thought to check much into the project. At home that night, I was
pretty much blown away by what it could do, and I scolded myself for not
having tried it earlier. Indeed, if you are a Python programmer and
not using iPython in your day-to-day work, you should run to your
computer, install it and start to use it. It offers a wide and rich
variety of functions that provide specific supports for interacting
with the language. Of particular interest to me, when teaching my
classes, is the ability to log everything I type. At the end of
the day, I can send a complete, verbatim log of everything I've
written (which is a lot!) to the students.
</p><p>
I have had a similar experience with Ruby during the past few months.
When Pry was announced about a year ago, described as a better version
of Ruby's interactive IRB program, I didn't really do much with it.
But during the past few weeks, I have been using and thoroughly enjoying
Pry. I have incorporated it into my courses, and have&mdash;as in the case
of iPython&mdash;wondered how it could be that I ignored such a wonderful
tool for as long as I did.
</p><p>
This month, I take a look at Pry, an improved REPL for Ruby. It
not only allows you to swap out IRB, the standard interactive shell
for Ruby, but it also lets you replace the Rails console. The console
is already a powerful tool, but combined with Pry's ability to explore
data structures, display documentation, edit code on the fly, and
host a large and growing number of plugs, it really sings.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17b1930"></a>
Pry</h2></div></div><p>
Pry is a relative newcomer in the Ruby world, but it has become extremely
popular, in no small part thanks to Ryan Bates, whose wonderful weekly
&ldquo;Railscasts&rdquo; screencasts introduced it several months ago.
Pry is an
attempt to remake IRB, the interactive Ruby interpreter, in a way that
makes more sense for modern programmers.
</p><p>
Installing Pry is rather straightforward. It is a Ruby gem, meaning
that it can be installed with:

<pre     class="programlisting">
gem install pry pry-doc
</pre>
</p><p>
You actually don't need to install pry-doc, but you really will want
to do so, as I'll demonstrate a bit later.
</p><p>
I tend to use the <tt  >-V</tt> (verbose) switch when installing gems to see
more output on the screen and identify any problems that occur.
You also might notice that I have not used <tt  >sudo</tt> to
install the gem.
That's because I'm using rvm, the Ruby version manager, which allows
me to install and maintain multiple versions of Ruby under my home
directory. If you are using the version of Ruby that came with your
system, you might need to preface the above command with
<tt  >sudo</tt>.
Also, I don't believe that Pry works with Ruby 1.8, so if you have
not yet switched to Ruby 1.9, I hope Pry will encourage
you to do so.
</p><p>
Once you have installed Pry, you should have an executable program
called &ldquo;pry&rdquo; in your path, in the same place as other gem-installed
executables. So you can just type <tt  >pry</tt>,
and you will be greeted by the following prompt:

<pre     class="programlisting">
[1] pry(main)&gt;
</pre>
</p><p>
Now you can do just about anything in Pry that you could do in IRB.
For example, I can create a class, and then a new instance of that
class:


<pre     class="programlisting">
[2] pry(main)&gt; class Person
[2] pry(main)*   def initialize(first_name, last_name)
[2] pry(main)*     @first_name = first_name
[2] pry(main)*     @last_name = last_name
[2] pry(main)*   end
[2] pry(main)* end
</pre>
</p><p>
Now, you can't see it here, but as I
typed, the words &ldquo;class&rdquo;, &ldquo;Person&rdquo;,
&ldquo;def&rdquo; and &ldquo;end&rdquo; were all
colorized, similarly to how a modern editor colorizes keywords. The
indentation also was adjusted automatically, ensuring that the
&ldquo;end&rdquo;
words line up with the lines that open those blocks.
</p><p>
Once I have defined this class, I can create some new instances. Here
are two of them:


<pre     class="programlisting">

[3] pry(main)&gt; p1 = Person.new('Reuven', 'Lerner')
=&gt; #&lt;Person:0x007ff832949580 @first_name="Reuven", @last_name="Lerner"&gt;

[4] pry(main)&gt; p2 = Person.new('Shikma', 'Lerner-Friedman')
=&gt; #&lt;Person:0x007ff8332386c8 @first_name="Shikma",
@last_name="Lerner-Friedman"&gt;

</pre>
</p><p>
As expected, after creating these two instances, you'll see a printed
representation of these objects. Now, let's say you want to
inspect one of these objects more carefully. One way to do it is to
act on the object from the outside, as you are used to doing. But Pry
treats every object as a directory-like, or namespace-like, object,
which you can set as the current context for your method calls. You
change the context with the <tt  >cd</tt> command:

<pre     class="programlisting">
cd p2
</pre>
</p><p>
When doing this, you see that the prompt has changed:

<pre     class="programlisting">

[14] pry(#&lt;Person&gt;):1&gt;

</pre>
</p><p>
In other words, I'm now on line 14 of my Pry session. However, I'm
currently not at the main level, but rather inside an instance of
Person. This means I can look at the object's value for
@first_name just by typing that:

<pre     class="programlisting">

[15] pry(#&lt;Person&gt;):1&gt; @first_name
=&gt; "Shikma"

</pre>
</p><p>
Remember that in Ruby, instance variables are private. The only way to
access them from outside the object itself is via a method. Because
I haven't defined any methods, there isn't any way (other than
looking at the printed representation using the #inspect method) to
see the contents of instance variables. So the fact that you can just
write <tt  >@first_name</tt> and get its contents is pretty great.
</p><p>
But wait, you can do better than this; <tt  >@first_name</tt> is a string, so
let's go into that:

<pre     class="programlisting">

[17] pry(#&lt;Person&gt;):1&gt; cd @first_name
[18] pry("Shikma"):2&gt; reverse
=&gt; "amkihS"

</pre>
</p><p>
As you can see, by <tt  >cd</tt>-ing into
<tt  >@first_name</tt>, any method calls now will 
take place against <tt  >@first_name</tt> (that is, the text string) allowing you
to play with it there. You also see how the prompt, just before the
&gt; sign at the end, now has a :1 or :2, indicating how deep you have
gone into the object stack.
</p><p>
If you want to see how far down you have gone, you can type
<tt  >nesting</tt>,
which will show you the current context in the code, as well as the
above contexts:

<pre     class="programlisting">

[19] pry("Shikma"):2&gt; nesting 
Nesting status:
--
0. main (Pry top level)
1. #&lt;Person&gt;
2. "Shikma"

</pre>
</p><p>
You can return to the previous nesting level with
<tt  >exit</tt> or jump to
an arbitrary level with <tt  >jump-to N</tt>, where N is a defined nesting
level:

<pre     class="programlisting">

[25] pry("Shikma"):2&gt; nesting
Nesting status:
--
0. main (Pry top level)
1. #&lt;Person&gt;
2. "Shikma"

[26] pry("Shikma"):2&gt; jump-to 1

[27] pry(#&lt;Person&gt;):1&gt; nesting
Nesting status:
--
0. main (Pry top level)
1. #&lt;Person&gt;

[28] pry(#&lt;Person&gt;):1&gt; exit
=&gt; nil

[29] pry(main)&gt; nesting
Nesting status:
--
0. main (Pry top level)

</pre>
</p><p>
When I first learned about Pry, I worried that <tt  >cd</tt> and
<tt  >ls</tt> were
taken for objects and, thus, those commands would be unavailable for
directory traversal. Never fear; all shell commands, from
<tt  >cd</tt> to
<tt  >ls</tt> to <tt  >git</tt>, are available
from within Pry, if you preface them
with a . character.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17b2cc8"></a>
Editing Code</h2></div></div><p>
Pry supports readline, meaning that I can use my favorite Emacs
editing bindings&mdash;my favorite being Ctrl-R, for reverse
i-search&mdash;in the command line. Even so, I sometimes make mistakes and need
to correct them. Pry understands this and offers many ways to
interact with its shell.
</p><p>
My favorite is !, the exclamation point, which erases the current
input buffer. If I'm in the middle of defining a class or a method
and want to clear everything, I can just type !, and everything I've
written will be forgotten. I have found this to be quite useful.
</p><p>
But, there are more practical items as well. Let's say I want to
modify the &ldquo;initialize&rdquo; method I wrote before. Well, I can
just use the edit-method command:

<pre     class="programlisting">
edit-method Person#initialize
</pre>
</p><p>
Because my EDITOR environment variable is set to &ldquo;emacsclient&rdquo;, this
opens up a buffer in Emacs, allowing me to edit that particular
method. I change it to take three parameters instead of two, save it
and then exit back to Pry, where I find that it already has been
loaded into memory:


<pre     class="programlisting">
[52] pry(main)&gt; p3 = Person.new('Amotz', 'Lerner-Friedman')
ArgumentError: wrong number of arguments (2 for 3)
from (pry):35:in `initialize'
</pre>
</p><p>
Thanks to installing the pry-doc gem earlier, I even can get
the source for any method on my system&mdash;even if it is written in C!
For example, I can say:

<pre     class="programlisting">
show-method String#reverse
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17a9a28"></a></h2></div></div><p>
and I get the C source for how Ruby implements the &ldquo;reverse&rdquo; instance
method on String. I must admit, I have been working with open
source for years and have looked at a lot of source code, but
having the source for the entire Ruby standard library at my
fingertips has greatly increased the number of times I do this.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17a9b88"></a>
Rails Integration</h2></div></div><p>
Finally, Pry offers several types of integration with Ruby on Rails.
The Rails console is basically a version of IRB that has loaded the
Rails environment, allowing developers to work directly with
their models, among other things. Pry was designed to work with
Rails as well.
</p><p>
The easiest way to use Pry instead of IRB in your Rails console is to
fire it up, using the <tt  >-r</tt> option to require a
file&mdash;in this case,
the config/environment.rb file that loads the appropriate items for
the Rails environment. So I was able to run:

<pre     class="programlisting">
pry -r ./config/environment
</pre>
</p><p>
On my production machine, of course, I had to say:

<pre     class="programlisting">
RAILS_ENV=production pry -r ./config/environment
</pre>
</p><p>
Once I had done this, I could navigate through the users on my
system&mdash;for example:

<pre     class="programlisting">
u = User.find_by_email("reuven@lerner.co.il")
</pre>
</p><p>
Sure enough, that put my user information in the variable u. I could
have invoked all sorts of stuff on u, but instead, I entered the
variable:

<pre     class="programlisting">
cd u
</pre>
</p><p>
Then I was able to invoke the &ldquo;name&rdquo; method, which displays the
full name:

<pre     class="programlisting">

[14] pry(#&lt;User&gt;):2&gt; name
=&gt; "Reuven Lerner"

</pre>
</p><p>
But this isn't the best trick of all. If I add Pry into my Gemfile,
as follows:

<pre     class="programlisting">
gem 'pry', :group =&gt; :development
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17aa160"></a></h2></div></div><p>
Pry will be available during development. This means
anywhere in my code, I can stick the line:

<pre     class="programlisting">
binding.pry
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17aa2c0"></a></h2></div></div><p>
and when execution reaches that line, it will stop, dropping me into a
Pry session. This works just fine when using Webrick, but it also can be
configured to work with Pow, a popular server system for OS X:

<pre     class="programlisting">
def show
  binding.pry
end   
</pre>
</p><p>
I made the above modification to one of the controllers on my site,
and then pointed my browser to a page on which it would be invoked.
It took a little bit of time, but the server eventually gave way to a
Pry prompt. The prompt worked exactly as I might have expected, but
it showed me the current line of execution within the controller, letting
me explore and debug things on a live (development) server. I was
able to explore the state of variables at the beginning of this
controller action, which was much better and more interactive than
my beloved logging statements.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17aa478"></a>
Conclusion</h2></div></div><p>
Pry is an amazing replacement for the default IRB, as well as for the
Rails console. There still are some annoyances, such as its
relative slowness (at least, in my experience) and the fact that
readline doesn't always work perfectly with my terminal-window
configuration. And as often happens, the existence of a plugin
infrastructure has led to a large collection of third-party plugins
that handle a wide variety of tasks.
</p><p>
That said, these are small problems compared with the overwhelmingly
positive experience I have had with Pry so far. If you're using
Ruby on a regular basis, it's very much worth your while to look
into Pry. I think you'll be pleasantly surprised by what you
find.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x16b9580.0x17aa5d8"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
The home page for Pry is <a href="https://github.com/pry/pry" target="_self">https://github.com/pry/pry</a>. You can download
the source for Pry from Git, or (as mentioned above) just install the
Ruby gem. The Pry home page includes a GitHub Wiki with a wealth of
information and FAQs about Pry, its installation, configuration and
usage.
</p><p>
A nice blog post introducing Pry is at
<a href="http://www.philaquilina.com/2012/05/17/tossing-out-irb-for-pry" target="_self">www.philaquilina.com/2012/05/17/tossing-out-irb-for-pry</a>.
</p><p>
Finally, a Railscast about using Pry, both with and without Rails, is
at <a href="http://railscasts.com/episodes/280-pry-with-rails" target="_self">railscasts.com/episodes/280-pry-with-rails</a>.
</p><p>
I also mentioned iPython at the beginning of this column. Pry and
iPython are very similar in a number of ways, although iPython is more
mature and has a larger following. If you work with Python, you
owe it to yourself to try iPython at <a href="http://ipython.org" target="_self">ipython.org</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Reuven M. Lerner is a longtime Web developer, consultant and trainer.
He is also finishing a PhD in learning sciences at Northwestern
University. His latest project, SaveMyWebApp.com, went live this
spring. Reuven lives with his wife and children in Modi'in, Israel.
You can reach him at <a href="mailto:reuven@lerner.co.il">reuven@lerner.co.il</a>.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../219/toc219.html">Issue Table of Contents</a>
    <a class="link3" href="../219/11308.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>