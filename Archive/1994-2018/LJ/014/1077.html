<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Introduction to Eiffel</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Dan introduces us to the Eiffel language, a fairly new&#10;    Object-Oriented language designed to streamline the software&#10;    engineeering process.&#10;    "><meta name="keywords" content="language, compilers"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1b69580.0x1c60ab0"></a>Introduction to Eiffel</h1></div><div><div class="author"><h3 class="author">Dan Wilder</h3></div><div class="issuemoyr">Issue #14, June 1995</div></div><div><p>
    Dan introduces us to the Eiffel language, a fairly new
    Object-Oriented language designed to streamline the software
    engineeering process.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c614a8"></a></h2></div></div><p>In the late 1970s, when I was a
journeyman laboring over the macro assembler language, a simple,
elegant, and expressive language called C emerged from the
structured programming tradition. My friends advised me to forget
C, to learn a &ldquo;real programming language&rdquo; like PL/1 or Ada,
available on many more of the important platforms, and with
commercial staying power due to the support of the government and
major corporations. Ignoring this advice, I concentrated on C. Some
of you may agree my choice was the right one for its time.
</p><p>Now, more than a decade later, another simple, elegant, and
expressive language has emerged, this time from the object-oriented
tradition. With roots in Simula, beholden to no backwards
compatibility issues, the Eiffel programming language was designed
from scratch by Bertrand Meyer and his colleagues for the purpose
of enabling the construction of robust, general, reusable software
components. With commercial support from a few vendors,
availability on several significant platforms, and some success
stories in development of major commercial applications, this
language bears careful observation.</p><p>I have known of Eiffel since 1989, when I read Dr. Meyer's
book, <span   class="emphasis"><em>Object Oriented Software Construction</em></span>
(Prentice Hall, 1988). I was impressed with the language, much as I
had been impressed with C when I read Kernighan and Ritchie's
classic, <span   class="emphasis"><em>The C Programming Language</em></span> (Prentice
Hall, 1988), ten years earlier. The opportunity to give Eiffel a
try presented itself with the Linux port announced in 1994 by
Bertrand Meyer's company, Interactive Software Engineering of
Goleta, California.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c61710"></a>The Pitch</h2></div></div><p>So what is all this noise about object-oriented programming,
and what sets Eiffel apart from the pack of object-oriented
languages?</p><p>Much of the promise shown by object-oriented software
construction may be attributed to the possibility of code reuse,
particularly the reuse of software components.</p><p>By reuse, I mean the incorporation of previously written
software <span   class="emphasis"><em>unmodified</em></span> into new programs. In the
US we have a saying: &ldquo;if it ain't broke, don't fix it.&rdquo; This folk
wisdom highlights the result of research studies which indicate the
great hazard of introducing new problems when working on existing
software. Ideally, it should be possible to write something once,
then put it on ice to be reused but never modified, except to fix
bugs and perhaps to add new features. Existing users should be
protected, if possible, from effects of such changes.</p><p>Unfortunately reuse has succeeded in only limited ways so
far. For example, the Unix C library or the various widget
libraries used in constructing Graphical User Interfaces are widely
used across many platforms. These notwithstanding, most of the
significant computer programs produced today contain great volumes
of handcrafted code. The difficulty of producing software
components with enough built&mdash;in flexibility is prominent&mdash;and a
great part of this difficulty must be ascribed to language
issues.</p><p>The Eiffel programming language was designed to promote
re-use. Bertrand Meyer recounts in the preface to <span   class="emphasis"><em>Eiffel:
The Libraries</em></span> (Prentice Hall, in press) how he started
out to write reusable components and how he came to abandon the
attempt to use existing languages and instead wrote a language for
the purpose.</p><p>Compiled and strongly typed, with genericity (templates),
polymorphism, dynamic binding, exceptions, garbage collection, a
genuinely useful implementation of multiple inheritance, and unique
handling of assertions, Eiffel should be considered a contender on
purely technical grounds.</p><p>Eiffel provides assertions as language primitives that
furnish both in-line design documents and optional runtime error
checking. Assertions are inherited. This serves to guarantee that
descendents will live up to or exceed their ancestors' promises.
Use of these assertions is a part of what is called &ldquo;design by
contract&rdquo;. These represent an application of responsibility-driven
design at a language level.</p><p>There are also other factors:</p><div class="itemizedlist"><ul type="disc"><li><p>Eiffel has a published, non-proprietary design,
coordinated by a nonprofit consortium whose decisions all existing
vendors agree to observe.</p></li><li><p>Simple and consistent syntax makes Eiffel an easy
language to learn. You will find no dense nests of parentheses,
asterisks, brackets, or ampersands in this language. If you delight
in special cases and obscure exceptions to rules, with attendant
language primitives just for handling these things, Eiffel is not
the language for you.</p></li><li><p>Precedence of arithmetic operators gives the order
of evaluation of mathematical expressions you would expect, unless
your native programming language is Smalltalk, Lisp, or
Forth.</p></li><li><p>Eiffel is available on a wide range of
platforms.</p></li></ul></div><p>The design of Eiffel has been placed in the public domain by
Interactive Software Engineering, Bertrand Meyer's company. The
Eiffel trademark is owned by NICE, the Nonprofit International
Consortium for Eiffel, which has been liberal in bestowing use of
the trademark. A validation suite will be available from NICE later
this year. Major Eiffel vendors and users, including
representatives from corporations and academia, are represented on
NICE. Membership is open to any interested party. Proposals of NICE
are published on the newsgroup comp.lang.eiffel. Anybody may
participate in the ensuing discussion.</p><p>The official language definition is <span   class="emphasis"><em>Eiffel: The
Language</em></span>, By Bertrand Meyer (Prentice Hall, 1992).
Almost 600 pages long, this volume contains a precise definition of
the language, many examples, and a great deal of discussion. The
formal syntax definition occupies only eight pages.</p><p>NICE is in the process of standardizing the libraries. PELKS,
the Proposed Eiffel Library Kernel Standard, is in the final stages
of adoption, even as the vendors hasten to bring their own class
libraries into line with it. Other libraries may follow.</p><p>Eiffel is available or announced from a number of vendors on
a roster of operating systems or platforms including Windows 3.1,
VMS, SunOS, Solaris, Ultrix, OSF/1, DG Aviion, IBM RS/6000, Silicon
Graphics, Macintosh, OS-2, and NEXTSTEP, as well as Linux.</p><p>Many Linux users are interested in seeing vendor interest in
our operating system, and a few astute vendors are beginning to
join the fold. It seems not too surprising that vendors of a
language that is in many respects years ahead of the pack should
also be astute enough to recognize the nature of the Linux
community. And they have&mdash;all four Eiffel vendors offer Linux
ports.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c62058"></a>Classes</h2></div></div><p>Object-oriented programming draws on just a few main ideas. I
will talk about three of the important ones and illustrate their
realization in the Eiffel language.</p><p>The first important idea is encapsulation: the packaging of
data with means to manipulate it. Such a package, written in a
programming language is a class, but an instance of a class in
execution (or in storage) is an object.</p><p>In Eiffel, everything exists within a class. There are no
external variables or routines. A class has features. Features in
turn are either attributes or routines.</p><p>Attributes store values, including references to objects.
They may be constant or variable.</p><p>Routines do things. Routines are either procedures or
functions. Functions return results and are not supposed to change
system state. Procedures change system state but return
nothing.</p><p>All features, even constant or variable attributes, are said
to be &ldquo;called&rdquo;. This is perhaps less strange than it might seem,
for in Eiffel, a call to a function with no arguments is written
the same as a call to an attribute. If in some class you
write:</p><pre     class="programlisting">

that := the.other
</pre><p><b  >the.other</b> may be either a function or an
attribute, in this context it makes no difference.</p><p>So, you encapsulate data and the routines that manipulate it
in a class. Assertions, mentioned previously, are also parts of a
class and serve to express class preconditions, constraints and
invariants.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c62478"></a>Inheritance</h2></div></div><p>The second important idea is inheritance.</p><p>Once you have a class, which describes what you know about
the how and why of some sort of object, it may further benefit you
to derive a new class from it, with additions and variations,
<span   class="emphasis"><em>without</em></span> touching the program code in the
original class. Inheritance is a mechanism that allows this.</p><p>For example, you might derive <b  >BEE</b> from
<b  >INSECT</b>. Many features of <b  >BEE</b>
would inherit directly from <b  >INSECT</b>, some
features would be modified, and <b  >BEE</b> would
provide a few new features of its own.</p><p>A rule of thumb, called the &ldquo;is-a&rdquo; rule, furnishes one way to
determine whether A might usefully inherit from B. Examine the
sentence &ldquo;A is a B&rdquo;. Does it make sense? It should if A is a
reasonable candidate to inherit from B. For example,
&ldquo;<b  >BEE</b> is an <b  >INSECT</b>&rdquo; passes
this test, so <b  >BEE</b> might inherit from
<b  >INSECT</b>. Then, <b  >INSECT</b> will be
ancestor of <b  >BEE</b>, and <b  >BEE</b> will
be a descendent <b  >INSECT</b>.</p><p>The &ldquo;has-a&rdquo; rule furnishes a contrast. If &ldquo;A has a B&rdquo; makes
more sense than &ldquo;A is a B&rdquo;, it may be prudent to let A reference or
have a feature of type B, rather than inheriting from B.
&ldquo;<b  >BEE</b> has a <b  >STINGER</b>&rdquo; makes
more sense than &ldquo;<b  >BEE</b> is a
<b  >STINGER</b>&rdquo; or for that matter
&ldquo;<b  >STINGER</b> is a <b  >BEE</b>&rdquo;.
Therefore, class <b  >BEE</b> should have a feature of
type <b  >STINGER</b>. That makes <b  >BEE</b>
a client of <b  >STINGER</b>, and
<b  >STINGER</b> a supplier to
<b  >BEE</b>.</p><p>The client-supplier relationship offers a client less
detailed control than a descendent. A client may use or not use a
feature of a supplier, but it cannot redefine such a feature. Many
of a supplier's features may be hidden from a client, while they
will be visible to a descendent. The positive side of this is that
the client will be relatively unaffected by details of a supplier's
implementation and less likely to be impacted by changes in a
supplier.</p><p>Both client and inheritance relationships can facilitate
software reuse. The traditional function call is more akin to the
client relationship, and many attempts at reuse in the past, prior
to object-oriented approaches, have made use of the function call.
However, we still find ourselves writing and rewriting familiar
pieces of functional code too complex to make good candidates for
library routines.</p><p>The implementation details of inheritance may seriously
affect its suitability as a mechanism for reuse. In the ideal
implementation, problems arising in descendent classes could always
be resolved there. Unfortunately, with many languages, problems
arising in descendent classes require changes to ancestors.</p><p>This becomes more true with multiple inheritance, a technique
by which a class may enjoy, or perhaps not enjoy, multiple
ancestors. This technique is a powerful one, but it is unavailable
in many object-oriented languages and discouraged in most of the
rest. Among languages that have reached commercial viability,
Eiffel offers a superior implementation of multiple
inheritance.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c599c0"></a>Polymorphism</h2></div></div><p>In its broad sense, this indicates a situation where a simple
request may elicit different but not entirely inconsistent
responses, depending on the target of the request. These responses
may be arrived at by entirely different means.</p><p>For example, you might have classes that look in part like
this:</p><pre     class="programlisting">

class INSECT
-- Description of a standard            -- insect.
     ...
feature flee is
     do
     -- How a standard
     -- insect flees.
     ...
     end; -- flee
end

class BEE
inherit INSECT
     redefine flee
     end;
     ...
feature flee is
     do
     -- How a bee flees.
            ...
     end; --flee
end
class COCKROACH
inherit INSECT
     redefine flee
     end;
     ...
feature flee is
     do
     -- How a cockroach flees.
     ...
     end; -- flee
end

class WATERBUG
inherit INSECT
     redefine flee
     end;
     ...
feature flee is
     -- How a water bug flees.
     ...
     end; -- flee
end
</pre><p>Then, you might have examples of <b  >BEE</b>,
<b  >COCKROACH</b>, and <b  >WATERBUG</b> bound
to references of <b  >INSECT</b>:</p><pre     class="programlisting">

-- Define references to an
-- INSECT and to a BEE.

     insect:INSECT;
     bob:BEE;

-- Bind some particular
-- insect to the reference

     insect := bugs.get

-- Now you have a BEE, a
-- COCKROACH or a WATERBUG.
-- Make it flee after its own
-- fashion, be it that of BEE,
-- COCKROACH, or WATERBUG.
-- This is a polymorphic call,
-- as the code executed will
-- depend on the type of the
-- object bound to insect.

     insect.flee;

-- You can't make a WATERBUG
-- collect pollen.
-- For this you need a BEE, and
-- a trial assignment is
-- available to assign objects
-- that might conform to the
-- type of a reference.

     bob ?= insect;

-- Then maybe you can make bob
-- the bee collect pollen.
-- If he isn't a BEE or a
-- conforming type, bob is Void.

     if bob /= Void then
        bob.collect_pollen
     end;
</pre><p>Another sort of polymorphism, sometimes called parametric
polymorphism, is supported in Eiffel as genericity.</p><p>The final sort of polymorphism I'll mention is found as
function overloading in other languages. Here, a function may be
defined multiple times, with different types and numbers of
arguments. When the function is called, the actual function invoked
depends on the argument list.</p><p>Function overloading is not implemented in Eiffel.
Workarounds are present, and arithmetic operations are handled as
special cases, but the general case of function overloading is felt
by the designers of Eiffel to be too full of potential ambiguities,
type-checking failures, complications, and interactions to be
worthwhile just now. A lively thread on this topic is seen from
time to time on the newsgroup comp.lang.eiffel.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c59e90"></a>Multiple Inheritance</h2></div></div><p>Multiple inheritance is a big win under Eiffel. If you have
dealt with this in other languages you may be surprised. Multiple
inheritance entails many sticky problems, including name collisions
and complications of repeat inheritance, and in most other
languages is best avoided whenever possible.</p><p>When two classes inherited by common descendent have
different features of the same name, a name collision
obtains.</p><p>When a feature is inherited more than once from a common
ancestor along two or more inheritance paths, you have repeat
inheritance. This may cause a name collision and also raises
practical problems, such as which repeated feature to use in a
polymorphic call.</p><p>Most object-oriented languages do not attempt
multiple-inheritance. The literature is full of elaborate
explanations why. This is sad. Eiffel demonstrates that multiple
inheritance need not be difficult or complex, and it can also yield
some quite practical results.</p><p>Eiffel provides an implementation of multiple inheritance
which minimizes the adverse effects of name collisions and repeat
inheritance complications. As is typical in Eiffel, the solution to
one problem helps solve another problem. In Eiffel, a name
inherited from an ancestor may be revised in a descendent using a
rename clause. Eliminating name collisions then merely involves
giving a new name to one or both of the colliding features. The
feature is unaffected, except that it is known in the renaming
class and any descendents of that class by its new name.</p><p>Supposing we have a class named <b  >SOME_OTHER</b>
that inherits two entirely different features both called put from
two ancestors named <b  >FIRST_CLASS</b> and
<b  >BOWSER</b>:</p><pre     class="programlisting">

class SOME_OTHER inherit
   FIRST_CLASS
     rename
       put as first_put
       end;
   BOWSER
     rename
       put as bowser_put
       end;
     ...
end
</pre><p>then in some client class we may have feature
<b  >what_now:SOME_OTHER</b></p><pre     class="programlisting">

-- We may invoke the feature
-- named put from either of its
-- originating classes

     what_now.first__put(this);
     what_now.bowser_put(that);
</pre><p>Repeat inheritance is only slightly more complex. In the
simple case, repeat inheritance is just a by-product of the class
inheritance structure you have chosen. Perhaps some of the classes
inherited from the class library have common ancestors&mdash;this is
almost certain. Your responsibility is easy: do nothing. The
compiler eliminates the duplicates, and your class has only a
single copy of each inherited feature, regardless of how many
different ways a feature might come to be present.</p><p>In the less common situation, you might want two copies of a
feature, for instance put, from an ancestor. A class fragment
exhibiting this situation might look something like this:</p><pre     class="programlisting">
class SOME_OTHER
     inherit
     FIRST_CLASS
       rename
          put as first_copy
       select
        -- Resolve an ambiguity.
         first_copy
       end;
     FIRST_CLASS
       rename
         put as second_copy
       end;
</pre><p>The select clause serves to resolve an ambiguity. Suppose you
reference an object of type <b  >FIRST_CLASS</b> and you
happen to invoke a feature known in <b  >FIRST_CLASS</b>
as put.</p><p><b  >SOME_OTHER</b> inherits
<b  >FIRST_CLASS</b> twice, and because of the renaming,
there are two possible answers to the question, &ldquo;What is the name
of put in <b  >SOME_OTHER</b>?&rdquo; The following code
fragment illustrates:</p><pre     class="programlisting">

-- Declare a reference of type FIRST_CLASS
-- then attach an object of type SOME_OTHER,
-- a descendent of type FIRST_CLASS, using a
-- creation procedure of SOME_OTHER called "make"

     this:FIRST_CLASS;
     !SOME_OTHER!this.make;

-- When you try to invoke put,
-- without select it is not clear what you mean.
-- Could mean first_copy, could mean second_copy.

     this.put;
</pre><p>The select clause removes the ambiguity by saying, &ldquo;When
invoking this duplicated feature under its ancestral name, select
this copy.&rdquo; Note that Eiffel brings a thorny problem, repeat
inheritance, to the resolution you might hope for. Duplicates are
simply eliminated, with no further intervention. If you wish to
duplicate-a much less common situation&mdash;you can do this using quite
simple syntax. Finally, features of the same name that are distinct
may be renamed so that both are available, or the unwanted feature
may be undefined. pb In each case, the mechanisms provided are
simple and local to the class where the problem arises. No
revisions to ancestors are required. This is no accident. A major
thrust in the design of this language was to eliminate the
occasions for revisions to ancestors. Reuse is served here by
localizing any adaptations required by repeat inheritance and name
collisions in the class where they are encountered. The ancestors
are not broken, so they require no fixing. If they are not fixed,
they will not have bugs introduced, and other clients or
descendents of the ancestor classes will not be affected by
changes, bug-inducing or otherwise, that might otherwise be
required in the absence of suitable means to resolve conflicts in
the descendent.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c5a7d8"></a>Genericity</h2></div></div><p>Suppose you need a class to manipulate a structured
collection of objects&mdash;an array of <b  >INSECT</b>s, a
parse tree, a hashed list of sales prospects, or some such
thing?</p><p>Some object-oriented languages furnish a general approach.
You construct a template for, say, a <b  >LINKED_LIST</b>
or an <b  >ARRAY</b>. You then use this template with
some arguments indicating the classes to be used in constructing
the particular <b  >LINKED_LIST</b> or whatever.</p><p>In Eiffel, this capability is called genericity, and the
templates are generic classes. As usual, this is done in a way that
does the job and yet is so simple, it seems effortless.</p><p>Suppose you are writing an ant hill. First you need some
ants.</p><pre     class="programlisting">

class ANT
     inherit INSECT
     -- A basic ant.  It has features to crawl,
     -- forage, dig, tend the young, and so on.
   ...
end

class CARPENTER_ANT
     inherit ANT
       redefine
       -- Redefine some things.
       -- These chew on your house and your apple
       -- tree.
       ...
       end;
     ...
end

class ARMY_ANT
     inherit ANT
       redefine
       -- These are always on the go.
       -- You hope they don't stop by your place
       -- for dinner.
       ...
       end;
     ...
end
</pre><p>Now you are ready for ant hills. Let us suppose you already
have some class that models insect societies. Its header might look
like this</p><pre     class="programlisting">
class INSECT_SOCIETY[G-&gt;INSECT]
  ...
</pre><p>which indicates that an <b  >INSECT_SOCIETY</b> may
be formed using a parameter that conforms to
<b  >INSECT</b>. Loosely, this means any descendent
<b  >INSECT</b> will do.
<b  >anthill:INSECT_SOCIETY[ANT]</b> declares a reference
to an <b  >INSECT_SOCIETY</b> containing ants. This
reference may then be attached an <b  >INSECT_SOCIETY</b>
containing <b  >CARPENTER_ANT</b>,
<b  >ARMY_ANT</b>, or any other descendent of
<b  >ANT</b> we have defined. In fact, this allows us to
reference an anthill comprising more than one kind of ant, which is
convenient, as some anthills may contain more than one kind of
ant.</p><p>In writing a specific container class, for example, we may
wish to take advantage of things we know about insects in the
features of the container class. It would never do, in such a
situation, for example, to enter an object of class
<b  >DOG</b> or <b  >HAMMER</b> into this
container. The type-safe mechanism for doing this is called
constrained genericity and is illustrated above in the header line
for class <b  >INSECT_SOCIETY</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1b69580.0x1c5b120"></a>Summary</h2></div></div><p>The Eiffel programming language offers power, simplicity,
strong type checking, and numerous other amenities. With an open
specification for both the language and the kernel libraries, and
support from multiple vendors, Eiffel now stands poised to take
off.</p><p>According to one vendor, most interest lately has come from
people who are turning to Eiffel having used C++ for some years and
who have become convinced that the training costs and the
complexity of that language are not justified by the features
provided.</p><p>The more adventurous among us who have a thirst to tackle an
object-oriented programming language unhindered by excess baggage
from the past ways of doing things may wish to further explore this
language.</p><p>In my next article, I'll write more about ISE Eiffel and the
compiler and tools from Tower Technology of Austin, Texas. I'll
also offer a few thoughts about how to get started with this
language.</p></div></div>
<div class="authorblurb"><p>
        <div       class="mediaobject"><img src="1077aa.jpg"></div>

      <span   class="bold"><b>Dan Wilder</b></span>
      has been employed as a software
      engineer since 1975. Dan resides in Seattle, where he divides his
      time between work, family, and a home Linux system. Any time left
      is spent ignoring the moss collection his neighbors think he calls
      a lawn. He can be reached via e-mail as
      <a href="mailto:dan@gasboy.com">dan@gasboy.com</a>.</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../014/toc014.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>