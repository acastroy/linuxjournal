<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Build a Large-Screen Command Center with the RPi 2
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Two Raspberry Pi 2 model Bs show their stuff by powering two command&#10;center 4K monitors.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xaea580.0xbe1ac0"></a>
Build a Large-Screen Command Center with the RPi 2
</h1></div><div><div class="author"><h3 class="author">
John
 S. 
Tonello
</h3></div><div class="issuemoyr">Issue #258, October 2015</div></div><div><p>
Two Raspberry Pi 2 model Bs show their stuff by powering two command
center 4K monitors.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xbe2250"></a></h2></div></div><p>
When the folks who make the Raspberry Pi made good on their plan to
release a multi-core version of the tiny computer with 1GB of RAM earlier
this year, I saw it as the perfect opportunity to put the single-board
Linux box to work&mdash;real work&mdash;in our company's network operations
center.
</p><p>
NYSERNet, Inc., is an optical networking company that provides high-speed
connections for New York state's leading universities and research
centers. Part of our job is to keep an eye on a fiber network that
stretches from Buffalo to New York City. If something does down, we need
to know quickly.
</p><p>
In the past, we had a walk-up command center that featured ten wall-mounted
19-inch monitors powered by two large-form Windows PC towers loaded with
heavy-duty video cards and enough VRAM to make everything work. The
screens showed network maps, data-center views and weather, among
other things.
</p><p>
But during a recent office remodel, we decided all the cabling,
clunky-looking PCs and video-card sharing needed to go. We wanted the
new space&mdash;with two new 50-inch Ultra HD monitors instead of the army
of 19-inchers&mdash;to be clean and uncluttered, and to offer staff and visitors
a nice sense of &ldquo;Aw, cool!&rdquo;
</p><div       class="mediaobject"><a href="11920f1.large.jpg"><img src="11920f1.jpg"></a><div class="caption"><p>
Figure 1. A 50-inch Vizio TV displays a NYSERNet, Inc., network map in high
resolution, powered by a Raspberry Pi 2 Model B, the small black box
to the left. The RPi is shown pulled out from its normal hiding space
behind the screen (photo by John S. Tonello).
</p></div></div><p>
Enter the Raspberry Pi 2 Model B.
</p><p>
With its powerful new four-core processor and double the RAM of its
immediate predecessor, the RPi seemed to be the perfect computer not only to 
drive our large new 4K monitors, but also to run several important
applications used by the NOC team, including a Java-based network
map, Iceweasel (a Firefox Web browser derivative) and InterMapper,
a proprietary network monitoring tool. Raspbian, a Debian derivative
that fits well with our Ubuntu shop, would be an ideal choice for the OS.
</p><p>
Before we could dive in and turn over a very public&mdash;and
necessary&mdash;system to a pair of $35 RPis, I had to make sure they had enough
video power to drive the large televisions. After all, we needed the 4K
resolution in order to get the pixel depth necessary for sharp screen
views and enough graphical real estate to accommodate the applications
we'd be running. The old ten-screen setup featured a different application
window on each monitor; the two-screen setup needed to show just as
many windows.
</p><p>
I ran some preliminary tests on an HP Mini running Windows 8.1 and on
the RPi 2 Model B. The Mini could muster only 1080p, but I found the RPi
could indeed provide the resolution I wanted with its built-in full-size
HDMI port and on-board Broadcom graphics. I also found I could do it
without having to set the poor RPi on fire by overclocking it to the max.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xbe2880"></a>
Choosing the RPis</h2></div></div><p>
For this project, I needed two RPis, one for each new large-screen
TV. You easily can set up more. I ordered two of the latest Raspberry Pi
2 Model B kits, which each included a computer, an 8GB SD card, a vented
plastic case and a USB power supply. This particular RPi is ideal because
it's powerful enough to run high-resolution video and
our network-monitoring applications simultaneously. The previous RPi B+ with 512MB of
RAM didn't provide quite enough horsepower for what I needed. If you
don't need the Ultra HD resolution, an older RPi may work fine.
</p><p>
The rest of this article assumes you know how to set up a Raspberry
Pi. If not, I've listed a good article in the Resources section that explains how to do
it. I used Raspbian as my base OS.
</p><p>
Once your RPi is up and running, it's a good idea to connect it to your
network. If something goes wrong with the video settings during this
setup, you'll want another way to edit the configuration files. Giving
the RPi an address on your network and setting up SSH will do just that.
</p><p>
If you're able to find a kit with a pre-installed Raspbian (or NOOBS)
SD card, that'll work fine. Other flavors, such as Arch Linux ARM and
Pidora, also may be good options, since this solution relies more on the
RPi's base configuration and less on the OS that sits on top of it.
</p><p>
All told, the kits cost about $65 each. I purchased a couple 12-inch
HDMI cables too&mdash;one for each RPi-TV pair.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xbe2b40"></a>
Choosing the Screens</h2></div></div><p>
It was important to get high-resolution screens for this project, and
after a bit of shopping, I settled on the Vizio 50-inch 4K Ultra HD
LED Smart TV (P502UI-B1E). It features 3840x2160 resolution, a 120Hz
refresh rate and the 16:9 aspect ratio I wanted. It didn't hurt that
this particular television came in at less than $800 delivered.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xbe2c48"></a>
Configuring the RPi</h2></div></div><p>
Using the raspi-config tool (built in to Raspbian), you can fine-tune
how the computer handles memory, video display and a host of other RPi
parameters. For my purposes, I used it to work with three things:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Overclocking
</p></li><li><p>
Overscan
</p></li><li><p>
Memory Split
</p></li></ul></div><p>
By the way, these settings also can be modified by editing
/boot/config.txt, so if you don't have raspi-config on your
distribution, you can set the parameters using the configuration
file. The /boot/config.txt on an RPi is sort of equivalent to BIOS on
other computers, and there's good Raspbian documentation available for
it. For more information, I've included a link about it in the Resources
section.
</p><p>
To start with the modifications, launch raspi-config: 

<pre     class="programlisting">
$ sudo raspi-config
</pre>
</p><p>
Overclocking is option 7 in the first menu; Overscan and Memory Split
are options A1 and A3 under the Advanced Options menu. Start with
Overclocking (Figure 2).
</p><div       class="mediaobject"><a href="11920f2.large.jpg"><img src="11920f2.jpg"></a><div class="caption"><p>
Figure 2. Overclock
</p></div></div><p>
After reading the warning, press Enter to acknowledge it (Figure 3). It's important
to know that overclocking can make weird things happen to your RPi,
so be careful.
</p><div       class="mediaobject"><a href="11920f3.large.jpg"><img src="11920f3.jpg"></a><div class="caption"><p>
Figure 3. Overclocking Warning
</p></div></div><p>
You'll be offered six overclocking options. Each offers an increasing
level of speed&mdash;and heat. Although the RPi 2 Model B is rated at 900MHz,
I went ahead and chose the Medium overclock preset, which offers 900MHz
ARM, 250MHz core, 450MHz SDRAM and 2 overvolt (Figure 4).
</p><div       class="mediaobject"><a href="11920f4.large.jpg"><img src="11920f4.jpg"></a><div class="caption"><p>
Figure 4. Choosing Overclock Preset
</p></div></div><p>
After experimenting with the basic settings (no overclocking), I found
that this medium overclocking made the applications run a little faster,
meaning the human experience of using the RPi was better.
</p><p>
If your applications are less resource-heavy, you probably can skip
overclocking altogether. However, even multiple Iceweasel windows or
tabs can hog system resources and may lead you to want a little more
oomph. Remember, the RPi is being asked to do quite a bit of graphical
processing that will use memory and cycles.
</p><p>
Select Medium, tab to Ok and press Enter, and you'll be back at the main
raspi-config menu.
</p><p>
Now it's time to make two Advanced Options configuration changes:
overscanning and memory. First, let's look at overscanning.
</p><p>
When you first connect your RPi to a monitor and boot it, you may see
black bars on the screen. These are unused pixels, and overscan is
disabled by default to give you a sort of graphical safe mode. If your
display is newer (like my two 4K TVs), you safely can disable overscan
and allow the RPi to use all the screen real estate.
</p><p>
Select Advanced Options in the main raspi-config menu, and choose Overscan
(A1) from the list (Figure 5). You have two options: disable or enable. Choose
Disable, and tab to Ok to return to the main menu.
</p><div       class="mediaobject"><a href="11920f5.large.jpg"><img src="11920f5.jpg"></a><div class="caption"><p>
Figure 5. Overscan
</p></div></div><p>
It's often hard to know if overscan will mess things up, so this is a
good point to save what you've done and reboot the RPi. Select Finish
from the main menu. That'll drop you to your command prompt:

<pre     class="programlisting">
$ sudo reboot
</pre>
</p><p>
If your screen looks okay on reboot (no black bars, no odd pixelation and
no weird flashing), you should be good to go. If it's screwed up,
or screwed up enough that you can't read anything, you'll need to
<tt  >ssh</tt>
in to the RPi from a separate computer and re-run raspi-config from
there. In this unlikely event, repeat the previous steps from a remote
shell and choose the Enable overscan option.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xbe3c18"></a>
Configure Memory Split</h2></div></div><p>
Now you can make the modification that will make the biggest difference
for this project&mdash;changing how the RPi allocates its 1GB of on-board
memory:

<pre     class="programlisting">
$ sudo raspi-config
</pre>
</p><p>
Enter the Advanced Options menu again, this time selecting the Memory
Split (A3) option (Figure 6).
</p><div       class="mediaobject"><a href="11920f6.large.jpg"><img src="11920f6.jpg"></a><div class="caption"><p>
Figure 6. Memory Split
</p></div></div><p>
You'll be offered several choices: 16, 32, 128, 256 and 512. Out of
the box, the RPi commits 64MB of its 1GB to the GPU. That's not nearly
enough to give the pixel resolution we want. After some experimenting,
I found that maxing out the memory for the GPU (512) worked best (Figure
7).
</p><div       class="mediaobject"><a href="11920f7.large.jpg"><img src="11920f7.jpg"></a><div class="caption"><p>
Figure 7. Maxing Out the Memory
</p></div></div><p>
This relatively massive amount of video memory delivers the graphical
performance you'll need for Ultra HD screens. Still, don't expect it
to perform like a desktop. Some graphical lag will remain when
you resize or move application windows.
</p><p>
Tab to Ok, tab to Finish and return to the command line. Reboot to make
the memory changes take effect.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xfdc4f0"></a>
Modify the Boot Configuration</h2></div></div><p>
Once the overscan, overclocking and memory split modifications are
complete, the rest of the heavy lifting for this project is done in the
boot configuration script: /boot/config.txt. See the Resources section for
a link to the complete description of
all its features.
</p><p>
Use your favorite text editor to open the file as root:

<pre     class="programlisting">
$ sudo vi /boot/config.txt
</pre>
</p><p>
The in-file documentation is helpful and will give you easy-to-follow
tips about the various parameters. In this file, you'll also see some
of the changes you previously made using raspi-config. If you didn't
use raspi-config, you can make the necessary modifications to overscan,
overclocking and memory split in the following steps.
</p><p>
First, disable overscanning:

<pre     class="programlisting">
disable_overscan=1
</pre>
</p><p>
If you set this in raspi-config, this already will be uncommented and
set to 1. Below that entry, you'll see overscan adjustments. These
all should be commented out. The same goes for the
<tt  >framebuffer_width</tt>
and <tt  >framebuffer_height</tt> settings. Unless you have a particular display
in mind, comment out these lines:

<pre     class="programlisting">
# uncomment this if your display has a black border 
# of unused pixels visible and
# your display can output without overscan
disable_overscan=1

# uncomment the following to adjust overscan. Use 
# positive numbers if console goes off screen, 
# and negative if there is too much border
#overscan_left=16
#overscan_right=16
#overscan_top=16
#overscan_bottom=16
</pre>
</p><p>
If the RPi doesn't automatically detect your HDMI display, uncomment
the <tt  >hdmi_force_hotplug=1</tt> line. That should fix it.
</p><p>
In order to get the RPi to support the Ultra HD screen resolution, you'll
need to use <tt  >hdmi_group</tt> and
<tt  >hdmi_mode</tt> to enable custom settings. The
<tt  >hdmi_group</tt> parameter sets the type of display you're using: 0 will
auto-detect, 1 will set CEA (typical for televisions), and 2 will set DMT
(typical for monitors).
</p><p>
Although I'm using a Vizio TV, I needed to set
<tt  >hdmi_group</tt> to 2:

<pre     class="programlisting">
# Set monitor mode to DMT
hdmi_group=2
</pre>
</p><p>
Depending
on the screen you choose, you may need to experiment with these settings
a bit. Remember, if something goes wrong and you no longer can read the
screen, <tt  >ssh</tt> in to your RPi and back out your
changes.
</p><p>
Driving the Vizio TV requires a custom resolution that is not offered in
any of the preset modes, so you'll need to set the HDMI output format
to 87, a custom mode:

<pre     class="programlisting">
# Make our custom resolution the default
hdmi_mode=87
</pre>
</p><p>
For a complete list of <tt  >hdmi_mode</tt> values (including
resolution and frequency), see the
Config.txt link in the Resources section of this article.
</p><p>
With the custom mode set, you now need to add the specific parameters
for Coordinated Video Timings (CVT). The format is:

<pre     class="programlisting">
hdmi_cvt=&lt;width&gt; &lt;height&gt; &lt;framerate&gt; &lt;aspect&gt; 
 &#8618;&lt;margins&gt; &lt;interlace&gt; &lt;rb&gt;
</pre>
</p><p>
So, a simplified version of this entry for the 3840x2160 Vizio TV 
looks like this:

<pre     class="programlisting">
hdmi_cvt 3840 2160 24
</pre>
</p><p>
Again, you can modify these settings to match your screen's parameters. 
It's much like adjusting the screen resolution on any computer
monitor&mdash;width, height and framerate are key.
</p><p>
I also set the framebuffer width and height to match my
<tt  >hdmi_cvt</tt> width
and height, and then set a high pixel frequency limit:

<pre     class="programlisting">
max_framebuffer_width=3840
max_framebuffer_height=2160
hdmi_pixel_freq_limit=400000000
</pre>
</p><p>
After some trial
and error, these settings worked well. Additional details are available
in the RPi Config (see Resources).
</p><p>
If you didn't use raspi-config to set overclocking and the GPU memory
split, add those parameters to the end of /boot/config.txt now:

<pre     class="programlisting">
arm_freq=900
gpu_mem=512
</pre>
</p><p>
Your entire /boot/config.txt settings now should look something like this:

<pre     class="programlisting">
disable_overscan=1
hdmi_group=2
hdmi_mode=87
hdmi_cvt 3840 2160 24
max_framebuffer_width=3840
max_framebuffer_height=2160
hdmi_pixel_freq_limit=400000000
arm_freq=900
gpu_mem=512
</pre>
</p><p>
Save /boot/config.txt and reboot. When the RPi comes back up, you should
have the high-resolution view you want. 
</p><p>
Deploying a second RPi is
as simple as duplicating the SD card from the RPi you just set up
and plugging it in to a second RPi. (See Resources for information on how
to do that.)
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xfdd3b8"></a>
Mouse and Keyboard Sharing</h2></div></div><p>
Because I have both RPis running in graphical mode, I need a keyboard and
mouse, but in the NYSERNet, Inc., command center, eliminating clutter is
an important goal. When it came time to control the RPis, I didn't want
a bunch of keyboards and mice lying around. I wanted just one of each,
and I wanted those to control the two computers wirelessly. The answer
was SSH and its x2x feature. (See Resources for a full <span   class="emphasis"><em>Linux
Journal</em></span> x2x how-to.)
</p><p>
With x2x, you can move the mouse (and keyboard focus) from one RPi to
the other, one monitor to the other, as though the screens were attached
to a single computer. It's fast and seamless.
</p><p>
I attached a Bluetooth USB dongle to the primary RPi I called rpi01. It
was immediately detected by the system and connected my Bluetooth
keyboard and mouse. I tested the functionality with the window manager,
and everything worked fine, although I needed to adjust the mouse speed
a bit so it would traverse the vast desktop more quickly.
</p><p>
The RPi is friendly to most modern Bluetooth USB adapters, so you should
be able to get one to be plug-and-play. From there, you'll want to share
the mouse and keyboard with your secondary RPi (in my case, rpi02). Since
rpi01 was my &ldquo;primary&rdquo; RPi, and I wanted to connect to rpi02,
my &ldquo;secondary&rdquo; RPi located to the left (or
<tt  >-west</tt>) of the other,
I opened a terminal on rpi01 and entered the following:

<pre     class="programlisting">
pi@rpi01:~$ ssh -X pi@rpi02 x2x -west -to :0
</pre>
</p><p>
This example assumes you're logged in to your primary RPi as the user pi
and you want to connect to your secondary RPi as the user pi. Another way
of putting it is this: if your Bluetooth mouse and keyboard are working on
rpi01 and you want to connect to rpi02 at 192.168.1.11, issue the command:

<pre     class="programlisting">
pi@rpi01:~$ ssh -X pi@ 192.168.1.11 x2x -west -to :0
</pre>
</p><p>
The <tt  >:0</tt> indicates the primary display. Once connected, the mouse 
now will move seamlessly from one screen to the other, and the focus for the
keyboard will follow. If you want, you can create a script and drop it
on the desktop of the primary RPi so you quickly can run SSH x2x after
a reboot.
</p><p>
For those who want to do this from two or more systems that don't use
Linux, Synergy is a good choice. It's a $10 application that works across
Linux, Mac and Windows.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xfdd990"></a>
Set Up VNC as a Remote-Control Alternative</h2></div></div><p>
If you'd rather not have any keyboard and mouse cluttering your public
space where you plan to hang your monitors (or because you just don't
use them with the RPis very much), a good alternative to SSH x2x is VNC.
</p><p>
It used to be rather difficult to set up VNC on Linux and access
the active session, but that changed with the advent of the vino
package. Now, in-session VNC works right out of the box with a simple
graphical control panel.
</p><p>
Use your package manager to install vino on each target RPi. Once
installed, open a terminal and run the vino setup utility:

<pre     class="programlisting">
$ vino-preferences
</pre>
</p><div       class="mediaobject"><img src="11920f8.jpg"><div class="caption"><p>
Figure 8. VNC Desktop Sharing Preferences
</p></div></div><p>
Under Sharing, enable both &ldquo;Allow other users to view your
desktop&rdquo;
and &ldquo;Allow other users to control your desktop&rdquo;. Uncheck
&ldquo;You must
confirm each access to this machine&rdquo;, so you don't have to acknowledge
the connection on the target RPi. Also check &ldquo;Require the user to enter
this password&rdquo;, and enter a password to thwart any unauthorized access.
</p><p>
Click close and reboot the RPi. This will ensure that vino-server
will start. In future boots, vino-server will start automatically. Again,
the goal here is to set up these RPis so you can do everything remotely
and not have to log in to start basic services.
</p><p>
Once the RPi reboots, repeat the vino package install and setup on any
additional RPis you're using, then go to your desktop and install
a VNC-compatible remote-desktop client. There are many options for all
platforms, but I prefer Remmina on my Linux Mint 17 desktop. Remmina
supports VNC and RDP, and it makes it easy to throttle the graphical
resolution and connection speeds to customize the remote-user experience.
</p><p>
Use your package manager to install Remmina. It comes with VNC support
out of the box, but you also can install remmina-plugin-vnc manually.
</p><p>
Once installed, launch Remmina from the command line by entering
<tt  >remmina</tt> (or open the graphical control panel):

<pre     class="programlisting">
$ remmina
</pre>
</p><p>
Create a new connection
with appropriate parameters (Figure 9).
</p><div       class="mediaobject"><img src="11920f9.jpg"><div class="caption"><p>
Figure 9. Creating a Profile
</p></div></div><p>
Create a profile for each RPi to which you want to connect. Give each
profile a name, ensure that you've selected the VNC protocol, enter the
server address for the RPi, use the default RPi account (usually pi
unless you've changed it), and set the color depth and quality.
</p><p>
I used a color depth of 256 colors and &ldquo;Poor&rdquo; quality, because I wanted
a better remote-user experience. If you get greedy with the color and
quality, the RPi will struggle a bit to redraw and refresh the VNC window,
which is about four times the size of a typical desktop monitor.
</p><p>
Click Save or Connect, and you'll connect to your RPi. Be patient. I've
found that this connection is not instantaneous even across a fast
LAN. It takes several seconds. Once connected, you can use Remmina to
show a full-screen view and use its window sliders to navigate to areas
of the RPi desktop that don't fit on your smaller desktop monitors.
</p><p>
Before hanging the new 50-inch TVs in our command center, I did my
final testing with everything still on the ground. I booted each RPi,
installed and launched the applications I needed, tested the networking
and the remote connections, and left the whole thing running for a few
days. Once I felt confident everything was stable, we hung the screens on
low-profile wall-hangers, connected the RPis with the short HDMI cables
and tucked them behind the TVs. Anyone looking sees only the monitors;
the rest is neatly hidden away.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xeeedf8"></a>
Final Thoughts</h2></div></div><p>
Because your RPis probably are sitting on a network, it's a good idea
to secure them with a firewall. I set up some iptables rules that block
almost all traffic.
</p><p>
Also, to make the RPis even easier to maintain, you may want to install
Webmin, a free Web-based administration tool for Linux environments. It
works well under Raspbian and doesn't hog resources when it's not in use.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xeeef58"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
NOOBS RPi Config: <a href="https://www.raspberrypi.org/documentation/installation/noobs.md" target="_self">https://www.raspberrypi.org/documentation/installation/noobs.md</a>
</p><p>
Config.txt Documentation: <a href="https://www.raspberrypi.org/documentation/configuration/config-txt.md" target="_self">https://www.raspberrypi.org/documentation/configuration/config-txt.md</a>
</p><p>
RPi Config Documentation: <a href="http://elinux.org/RPiconfig" target="_self">elinux.org/RPiconfig</a>
</p><p>
Duplicate SD Card: <a href="https://www.raspberrypi.org/forums/viewtopic.php?f=91&amp;t=46911" target="_self">https://www.raspberrypi.org/forums/viewtopic.php?f=91&amp;t=46911</a>
</p><p>
<span   class="emphasis"><em>Linux Journal</em></span> x2x How-To: <a href="http://www.linuxjournal.com/content/share-keyboardmouse-between-multiple-computers-x2x" target="_self">www.linuxjournal.com/content/share-keyboardmouse-between-multiple-computers-x2x</a>
</p><p>
Synergy Mouse and Keyboard Sharing: <a href="http://www.synergy-project.org" target="_self">www.synergy-project.org</a>
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xaea580.0xeef588"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
John S. Tonello is Director of IT for NYSERNet, Inc., in Syracuse, New
York. He's
been a Linux user and enthusiast since he installed his first Slackware
system from diskette 20 years ago.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../258/toc258.html">Issue Table of Contents</a>
    <a class="link3" href="../258/11920.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>