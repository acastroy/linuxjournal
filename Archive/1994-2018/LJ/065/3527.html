<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>First UNIX/Linux National Competition Held in Ljubljana, Slovenia</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    A look at the questions and answers for a contest to find&#10;    Linux solutions to common problems.&#10;    "><meta name="keywords" content="education"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xd7a580.0xe71ab0"></a>First UNIX/Linux National Competition Held in Ljubljana, Slovenia</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author">Primoz Peterlin</h3></div><div class="author"><h3 class="author">Ales Kosir</h3></div><div class="issuemoyr">Issue #65, September 1999</div></div></div><div><p>
    A look at the questions and answers for a contest to find
    Linux solutions to common problems.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7a580.0xe72818"></a></h2></div></div><p>On April 24, 1999, the Slovenian National
Linux User Group organized the first national competition in
UNIX/Linux. The competition was among the activities connected with
the 23rd Annual National Competition in Computer Science for high
school students and the Fifth Festival of Computing, both of which
were held in late April at the Department of Computer Science at
the University of Ljubljana. As opposed to the already
long-established tradition of national competitions in computer
science, where a great emphasis is given to problems easily solved
with procedural programming languages, this competition seeks its
niche in favoring solutions implemented with &ldquo;alternative&rdquo; tools
from the UNIX programming environment, where the strengths of these
tools can be shown in the best way.
</p><p>When preparing the exercises for this competition, those of
us who served as the organizing committee searched the Web
extensively for similar competitions elsewhere. Unfortunately, we
found none. We would therefore like to make our own experiences
available to the broader audience and hopefully initiate some
collaboration in this area. In this article, we present the
exercises that were part of the competition together with their
solutions, explained in detail and commented. We conclude with the
results of the competition accompanied by a few remarks and
afterthoughts.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7a580.0xe72978"></a>Exercises</h2></div></div><p>2:1. Frequency Analysis of Text</p><p>Perform a simple frequency analysis of text. Read a text file
and write to the standard output the complete list of all words in
the text along with their frequencies. The list should be sorted in
ascending order, with the least frequent words on the top and the
most frequent ones on the bottom. A &ldquo;frequency&rdquo; is a number which
tells us how many times a certain word occurs in the given text.
You can assume the text file contains no other characters but
letters and blanks.</p><p>2:2. vi Editor</p><p>On a multi-user system, you want to prevent multiple users
from editing the same file simultaneously using the
<span   class="bold"><b>vi</b></span> editor. Suggest a solution!
Implement your solution as a script. Comment the good and the bad
aspects of your solution. You can assume that every user calls the
editor using the command <span   class="bold"><b>vi</b></span>
<span   class="emphasis"><em>filename</em></span>. You cannot rely on the
<span   class="bold"><b>vi</b></span> editor issuing a warning when
editing an already-opened file.</p><p>2:3. Shuffle</p><p>The lines in a given file are sorted by certain criterion.
You don't want this, and would like to shuffle the lines
pseudo-randomly. Propose your shuffling algorithm and implement it
in the code. Pay attention to the efficiency of your code.
&ldquo;Pseudo-randomly&rdquo; means you are allowed to use the random number
generator available in the tool you will choose.</p><p>2:4. IP Addresses</p><p>A text file contains multiple references to IP addresses. You
want to replace them all with the fully qualified domain names
(FQDN). The IP addresses and the corresponding FQDNs are listed in
the /etc/hosts file:</p><pre     class="programlisting">
193.2.1.72      nanos.arnes.si
</pre><p>You can assume this file contains nothing but records like
the one shown.
</p><p>Numerical IP value is of the form 0.0.0.0-255.255.255.255.
Without sacrificing much generality, you can assume every pattern
0.0.0.0-999.999.999.999 in the given text file is a valid IP
address and its corresponding FQDN can be found in the /etc/hosts
file. You can also assume each IP address in the text file is
delimited by at least one blank character on both sides.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7a580.0xe72f50"></a>General Rules</h2></div></div><p>You are allowed to use the script languages of any command
shell (e.g., <span   class="bold"><b>sh</b></span>,
<span   class="bold"><b>csh</b></span>,
<span   class="bold"><b>ksh</b></span>,
<span   class="bold"><b>bash</b></span>) or any script language such
as <span   class="bold"><b>sed</b></span>,
<span   class="bold"><b>awk</b></span> and
<span   class="bold"><b>perl</b></span>. You are also allowed to use
all the user commands provided by a UNIX system as specified by
POSIX. You are <span   class="emphasis"><em>not</em></span> allowed to use compiled
languages such as C, C++, Pascal or FORTRAN. If you are in doubt as
to whether the tool you plan to use is allowed, you can ask a
member of the supervising committee. The decision of the
supervising committee is final.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7a580.0xe73318"></a>Solutions</h2></div></div><p>2:1. Frequency Analysis of Text</p><p>It is easy to solve this exercise with the
<span   class="bold"><b>sort</b></span> and
<span   class="bold"><b>uniq</b></span> commands and some command
pipelines. The solution can be written in a single line:</p><pre     class="programlisting">
tr " " "\n" &lt; <span   class="emphasis"><em>filename</em></span> | sort | uniq -c | sort -n
</pre><p>With <span   class="bold"><b>tr</b></span> we replace each
blank in the text file with a newline, thus chopping it into a form
where a single word is written per line. Since tr expects the data
stream from the standard input, we have to redirect the data from
the file to the standard input with the &lt; sign. The author of
the exercise has made life a bit easier for us, since we don't have
to worry about the periods, commas and other non-letters in the
text. The output from tr is pipelined (the | sign) to the input of
the sort command, which outputs an alphabetically sorted list of
all words in the text file. We pipeline it again to the input of
the uniq command. With no options, the uniq command eliminates
multiple occurrences of adjacent lines in a text. With the option
<b  >-c</b> (count), it also reports the number of
occurrences for each line read on the input. Since we have already
chopped the text beforehand, uniq thus outputs the list of
frequencies. The only remaining task is sorting it by frequency
rather than alphabetical order, which we do with the second
<span   class="bold"><b>sort</b></span> command. The
<b  >-n</b> option is used to perform the sort by the
numerical value of the first field.
</p><p>Was the explanation too quick? If you are not familiar with
pipelines, we advise you to try and assemble the complete operation
one step at a time. To start, use the tr command alone:</p><pre     class="programlisting">
tr " " "\n" &lt; <span   class="emphasis"><em>filename</em></span>
</pre><p>Now try to pipeline its output into sort, and watch what
happens! Continue with the rest of the pipelined commands.
</p><p>Let us conclude this discussion with an illustration showing
frequency analysis on an actual text. The ten most common words in
<span   class="emphasis"><em>Martin Krpan</em></span>, a text by Fran Levstik,
are:</p><pre     class="programlisting">
61 v
65 Krpan
74 bi
74 na
107 da
121 in
127 ne
142 se
161 pa
207 je
</pre><p><span   class="bold"><b>2:2. vi Editor</b></span>
</p><p>This exercise requires familiarity with the concept of file
locking. The given program (in our case, the
<span   class="bold"><b>vi</b></span> editor) is renamed or moved to
a directory not included in the users' <b  >PATH</b>
environment variable. In its place, we put an enveloping script
named vi which, when called, creates a lock file, starts the editor
and removes the lock file on exit. The lock file is created in the
same directory as the file we are editing, and not in the /tmp
directory, for instance. This is necessary to avoid any confusion
which could arise when two files with the same name exist in two
different directories.</p><p>A possible problem may occur if two users simultaneously
start editing a certain file. User A starts the script, which
discovers a lock file does not exist and proceeds to create one.
Before it actually creates it&mdash;remember, UNIX is a multitasking
system&mdash;the process is interrupted by user B starting the same
script. Since the lock file still doesn't exist, the script also
decides that user B is allowed to set the lock.</p><p>The problem can be avoided if the procedure is reversed:
first we create the lock file, and afterwards we check if we were
successful. Does that sound strange? The solution presented here
does exactly that. Using the <span   class="bold"><b>touch</b></span>
command, the script always tries to create a lock file, then reacts
depending on the exit status reported by touch. On a successful
exit, touch exits with a zero (true) exit code, while on an
unsuccessful exit, it reports a non-zero (false) exit code. There
are other possible situations in which touch exits with a non-zero
exit code, but here we are focusing on only one. If we try to touch
a file belonging to another user for which we don't have write
permission, touch reports an error and exits with a non-zero exit
code. Therefore, we have to make sure that when the lock file is
created, no other user has write permission. This is accomplished
using the <span   class="bold"><b>umask</b></span> command as shown
below: user (<b  >u</b>) is the only one who is granted
both read and write (<b  >rw</b>) permissions, while
users from the same group (<b  >g</b>) and all the other
(<b  >o</b>) users are granted none. Since we don't want
the umask command to affect our environment, we have limited its
influence by enclosing it in parentheses. The gibberish following
the touch command is used to send the error messages produced by
touch into oblivion. We are interested only in the exit code and
are happy with touch running absolutely quietly.</p><pre     class="programlisting">
#!/bin/ksh
if ( umask u=rw,g=,o=; touch $1.lock &gt;\
/dev/null 2&gt;&amp;1 )
then
  vi $1
  rm -f $1.lock
else
  echo "$1 is currently locked."
fi
</pre><p>Since it depends on the touch exit code, the solution
presented here doesn't prevent a user from opening <span   class="emphasis"><em>his
own</em></span> file more than once. This is not explicitly required
in the exercise, so it is not considered a deficiency in this
context. There is also nothing preventing <span   class="emphasis"><em>root</em></span>
from opening anybody's files. Moreover, the solution employing an
enveloping script does not prevent any user from reading an
already-opened file from <span   class="emphasis"><em>within</em></span> the vi editor.
Unlike the traditional AT&amp;T vi, many of its newer incarnations
have the file-locking facility built in.
<span   class="bold"><b>vim</b></span> (Vi IMproved), the most common
vi replacement on Linux, is one of them.
</p><p>2:3. Shuffle</p><p>Shuffling is obviously a procedure that can easily be
accomplished by brute force. First, each line is prepended by a
random number, then the lines in the file are sorted according to
these random numbers, and finally all the prepended numbers are cut
away, retaining only the original lines in their altered order.
Again, the solution can be written in a single line:</p><pre     class="programlisting">
awk '{ print rand(), $0 }' <span   class="emphasis"><em>sorted.lst</em></span> | sort -n
|
cut -d " " -f 2-
</pre><p>The first command performs the following statement in the
<span   class="bold"><b>awk</b></span> scripting language on the file
sorted.lst:
<pre     class="programlisting">
{ print rand(), $0 }
</pre>


For those not familiar with awk, commands in this scripting
language have the form
<pre     class="programlisting">
<span   class="emphasis"><em>condition</em></span> { <span   class="emphasis"><em>statement</em></span> }
</pre>


For each record on input (if not specified otherwise, a record
defaults to a line, as in the present case), the condition is
checked, and if met, the corresponding statement is executed.
</p><p>In our case, no condition was specified, which means the
statement is executed for each line on input. The statement itself
says to print a random number followed by the line read on the
input. The output from awk is then piped to the input of sort,
which sorts the lines by the numerical value of their first field.
The first field is the random number which was prepended in the
previous step.</p><p>Finally, we remove the prepended random numbers with
<span   class="bold"><b>cut</b></span>. The two options given to
<b  >cut</b> mean, treat blank as field delimiter
(<b  >-d " "</b>) and extract the fields from the second
field onward (<b  >-f 2-</b>). We have thus dropped the
first field, which was the prepended random number.</p><p>Sorting makes the above algorithm an <span   class="emphasis"><em>N</em></span>
log <span   class="emphasis"><em>N</em></span> one. A more efficient shuffling was
invented by Durstenfeld (<span   class="emphasis"><em>Comm. ACM</em></span>
<span   class="bold"><b>7</b></span>, 1964, 420), having a linear
dependency. Here we present an implementation in Perl for our
purpose:</p><pre     class="programlisting">
#!/usr/bin/perl
@line =&lt;&gt;; # the complete input file
                    #is read into a vector
for ($i = 0; $i &lt;= $#line; $i++) { # for i-th line
    $rnd = $i + int(rand($#line - $i + 1));
                    # we select a random line
                    # between i and the end
    print $line [$rnd]; # print it
    $line [$rnd] = $line[$i]; # replace with i-th
}
</pre><p><span   class="bold"><b>2:4. IP addresses</b></span>
</p><p>This exercise requires recognizing the following pattern in
the text: a blank, followed by one, two or at most three digits, a
dot, again one, two or three digits, another dot, again one, two or
three digits, yet another dot, once more one, two or three digits,
and the final blank. This pattern can be efficiently described as a
<span   class="emphasis"><em>regular expression</em></span> in Perl:</p><pre     class="programlisting">
\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b
</pre><p>Here <b  >\b</b> denotes a word boundary,
<b  >\.</b> is an explicit dot (otherwise a dot means
&ldquo;any character&rdquo; in the regular expression syntax) and
<b  >\d{1,3}</b> means a sequence from one to three
digits.
</p><p>The solution consists of two separate tasks. First, we have
to read the <b  >/etc/hosts</b> file and construct a
mapping table. Second, we scan the text file for IP addresses and
replace them with the corresponding FQDN from the mapping table.
Again we present a solution in Perl:</p><pre     class="programlisting">
#!/usr/bin/perl
open (HOSTS_FILE, "/etc/hosts");
while ($line = &lt;HOSTS_FILE&gt;) {
    chomp $line;
    ($ip, $fqdn) = split(/ +/, $line);
    $hostbyip {$ip} = $fqdn;
}
close(HOSTS_FILE);
while (&lt;&gt;) {
  s/\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})
  \b/$hostbyip{$1}/g;
  print;
}
</pre><p>When constructing the mapping table
<b  >$hostbyip</b>, we used a nice feature of Perl called
associative arrays or hashes, which allows us to refer to an
element in the table by a symbolic name. Here, we used the IP
address written as a string (variable <b  >$ip</b>). The
address replacement in the second task is implemented using the
<b  >s</b> (substitution) operator:
s/<span   class="emphasis"><em>pattern</em></span>/<span   class="emphasis"><em>replacement</em></span>/g.
The final <b  >g</b> (global) modifier makes the
substitution operator more eager; the first pattern found in the
line doesn't satisfy it, but it continues to scan the rest of the
line for another occurrence(s) of the given pattern.
</p><p>In reality, the Domain Name System has replaced the
/etc/hosts files long ago. For a more realistic example, we would
have to replace the reading of /etc/hosts table by a
<span   class="bold"><b>gethostbyaddr</b></span> call. The modified
program is actually even shorter:</p><pre     class="programlisting">
#!/usr/bin/perl -p
BEGIN {
    sub gethostbyip {
    my ( $ip ) =  @_ ;
    $packaddr = pack ("C4", split (/\./, $ip) );
    ($name) = gethostbyaddr( $packaddr, 2 );
    return $name;
    }
}
s/\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})
\b/gethostbyip($1)/eg;
</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd7a580.0x126d1f0"></a>Results</h2></div></div><p>Thirteen competitors entered this year. They had 90 minutes
to solve all exercises using pencil and paper. They were allowed to
use all available literature, but did not have access to a computer
to test their solutions. Therefore, the committee decided to judge
favorably all solutions exhibiting the correct ideas, even if they
were not written syntactically error-free. After reviewing all
submitted solutions, the committee decided to award prizes to the
following three contestants:</p><div class="itemizedlist"><ul type="disc"><li><p>Andraz Tori</p></li><li><p>Mitja Bezget</p></li><li><p>Gasper Fele-Zorz</p></li></ul></div><p>The average quality of the submitted solutions suggests that
despite all the publicity Linux received during the last year, high
school students are not particularly familiar with the tools from
the UNIX/Linux programming environment. This is a pity, since we
believe that the many strong scripting languages and modular tools
are one of Linux's advantages over its competitors.
</p><p>The analysis of the anonymous questionnaire which the
competitors were asked to fill in also yielded some interesting
results. The competitors were asked questions about their own
computing environment, to classify the exercises on a scale of 1 to
5 from &ldquo;easy&rdquo; to &ldquo;difficult&rdquo; and to give suggestions. Some
found the limit to scripting languages too restrictive. An
interesting response came from a competitor who considered the
exercises would be simple &ldquo;provided that C or C++ could be
used&rdquo;.</p><p>This calls for a comment. Every exercise is easiest to solve
in a language one is familiar with. Anybody familiar with both C
and some scripting language would probably agree that these
exercises can be solved in the latter with much less effort. This
was intentional. What wasn't intentional is that we discovered the
fact that high school students hardly touch on any scripting
language at all and are thus unaware of their benefits. Rapid
prototyping, for example, is quickly and easily accomplished from
readily available tools. This is a complement rather than a
replacement for the compiled languages. If speed is truly
important, a successful prototype is normally followed by a
compiled version, usually distinguished by much faster execution.
In practice, both approaches coexist, while in our schools, one
seems to have a complete dominance.</p><p>Last but not least, the title of this competition also
probably deserves a comment. UNIX, or Linux in its narrower sense,
denotes the operating system kernel. Kernel-level exercises were
not part of this competition and, given the limited time and
resources available to competitors, would not be feasible at this
moment. It would be honest to admit that in the trade-off between
short and catchy names and long and precise ones, we have leaned
towards the former. Who knows&mdash;perhaps the extra room we have
created for ourselves will even prove useful at some later
time.</p></div></div>
<div class="authorblurb"><p>
          <div       class="mediaobject"><img src="3527aa1.jpg"></div>
          <span   class="bold"><b>Primoz Peterlin</b></span>
          holds a M.Sc. in Physics and
          works for the Institute of Biophysics, University of Ljubljana,
          Slovenia. Getting his first computer in 1983, he discovered Linux
          in 1992 and has never left it since. His diverse interests include
          biocomputing, typography and mountain hiking. He can be reached at
          <a href="mailto:primoz.peterlin@biofiz.mf.uni-lj.si">primoz.peterlin@biofiz.mf.uni-lj.si</a>.
        </p><p>
          <div       class="mediaobject"><img src="3527aa2.jpg"></div>
          <span   class="bold"><b>Ales Kosir</b></span> has a BS in Mathematical Physics and
          an MS in Mechanical Engineering. In the company Hermes SoftLab, he
          works on compiler-based technology, while he is interested in many
          aspects of localization. He enjoys cooking, particularly seafood,
          and for his own pleasure he plays the piano. More about him can be
          found on <a href="http://nl.ijs.si/GNUsl/" target="_self">nl.ijs.si/GNUsl/</a>.
        </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../065/toc065.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>