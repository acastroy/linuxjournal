<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
At the Forge
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;How URLs, a technology that we take for granted, are changing with the&#10;times.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xccd580.0xdc4ac0"></a>
At the Forge
</h1></div><div><h3 class="subtitle"><i>
URLs
</i></h3></div><div><div class="author"><h3 class="author">
Reuven
 M. 
Lerner
</h3></div><div class="issuemoyr">Issue #242, June 2014</div></div><div><p>
How URLs, a technology that we take for granted, are changing with the
times.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc5358"></a></h2></div></div><p>
The world Wide Web recently celebrated its 25th anniversary. As I
have written in previous columns, the growth and ubiquity of the
modern Web never cease to amaze me. I get my news, television and
podcasts via the Web, not to mention my groceries and airline tickets, and
it allows me to
and communicate with my consulting clients around the world.
</p><p>
From my perspective, part of the genius of the Web, designed by Tim
Berners-Lee, was its simplicity. Numerous researchers had been
discussing hypertext for years before Berners-Lee appeared on the
scene&mdash;and when he did, it was with a set of technologies that
remain with us: HTTP, HTML and URLs.
</p><p>
I wouldn't claim that these technologies are unchanged after 25 years
of usage, but it is pretty amazing to see how much they resemble
their original versions. HTML has become, of course, far more
sophisticated, thanks in no small part to the HTML5 set of standards,
along with JavaScript and CSS. HTTP has undergone a number of changes
to improve its efficiency through the years, and it would seem that HTTP
2.0 eventually will be released, bringing with it considerably improved
performance and security.
</p><p>
The lowly URL, however, has remained largely unchanged&mdash;at least,
until now. In this article, I want to spend a bit of time talking about
URLs (and their cousins, URIs and URNs) and the changes that are
happening in the world of Web technologies. In particular, we're
seeing changes in Web application technologies that have far-reaching
implications for how we use the Web and for the ways in which our
URLs function&mdash;especially as the Web becomes increasingly full of
mobile and single-page apps.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc5670"></a>
Uniform Resource X</h2></div></div><p>
The idea behind URLs (Uniform Resource Locators) is a simple one: it
identifies a document on the Internet. If you're reading this article,
you presumably know that a URL can look like this:
http://example.com/foo.
</p><p>
The first URLs were defined in fairly simple terms. There was a
protocol, followed by a colon, and then (in the case of HTTP, at
least) a server name, port number and pathname.
</p><p>
But soon after URLs first were unveiled, people started to consider
that other things deserved unique identifiers. For
example, let's say you want to refer to a book. Each book has a
unique ISBN, so shouldn't it be possible to refer uniquely to a book
via its ISBN? The IETF, which is in charge of many Internet
standards, certainly thought so, and thus created the idea of a URN,
or Uniform Resource Name. Whereas a URL points to a resource on the
Internet, via a protocol, server name and pathname, URNs point to
off-line resources via a unique code. Thus, you can point to a book
with urn:isbn:0451450523.
</p><p>
Where does this book reside on the network? That's not the sort of
question you're supposed to ask about a URN. URNs uniquely
identify resources, but they don't tell you where to find them on-line. A
URN always begins with &ldquo;urn:&rdquo;, followed by the type of resource you're
describing. Following that, you'll then have a unique identifier for
that resource. A URN should be unique; many books may share the same
title, but each book has a unique ISBN.
</p><p>
With the creation of URNs, both URNs and URLs then became specific
types of URIs, or Uniform Resource Identifiers. A URI can be a URL,
identifying a particular on-line location. Or a URI can be a URN,
pointing to a unique resource in the world.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc5930"></a>
Parts of a URL</h2></div></div><p>
Although URNs certainly are a great idea, I haven't ever used them in my
work. But I have used URLs extensively, and I expect that all other Web
developers have done so too.
</p><p>
URLs are remarkably flexible, in that they can specify any protocol&mdash;and then for each protocol, a URL can specify a particular access
method. The following URL,
http://lerner.co.il/,
thus indicates that the resource is available via the HTTP protocol.
HTTP URLs then have a hostname, followed by an optional port number that
defaults to 80 for HTTP and 443 for HTTPS (that is, HTTP with SSL
encryption). So the previous URL also could be written as
http://lerner.co.il:80/,
but there's generally no need to do so. Following the slash that
comes after the hostname, there is a path. So, I can say:
http://lerner.co.il/team.
</p><p>
This is where things start to get a bit interesting. The
&ldquo;/team&rdquo; is
passed to the Web server at &ldquo;lerner.co.il&rdquo; and describes...well, we
don't know what it describes. To the outside world, the
&ldquo;/team&rdquo; path
seems to indicate part of a hierarchy, and probably even a document.
Inside the Web application, it can be anything at all. In modern
Web applications, the &ldquo;router&rdquo; looks at the URL and decides which
object and/or method should be activated based on the path.
</p><p>
Now, in most cases, this is all you're going to need. But there are
some additional, often ignored parts of URLs that are becoming
increasingly important. For example, the hash character (#) can exist
in the URL, and it separates the main URL from the &ldquo;fragment&rdquo;. What is a
fragment? Whatever you want it to be&mdash;that part of an HTTP URL is
handled internally by the application and/or the browser.
</p><p>
For years, the fragment was used to let you skip to a particular part
of a page. So if you went to http://example.com/foo.html#section2,
and if there was a &ldquo;name&rdquo; link inside the page with the value
&ldquo;section2&rdquo;, the browser would move you there.
</p><p>
Another use for the fragment was to provide a URL for links that
didn't exist for actual linking, but rather so that JavaScript could
fire. That is, you could create a link like:

<pre     class="programlisting">

&lt;a id="click-me" href="#"&gt;Click me&lt;/a&gt;

</pre>
</p><p>
If you were to click on such a link from a browser without JavaScript,
nothing would happen. But in a browser with JavaScript, the page
presumably would set a callback, such that clicking on the link would
fire up some JavaScript code.
</p><p>
To date, the fragment probably has been the smallest and most easily
ignored part of a URL. But that is changing, and rapidly, thanks to
the rise of single-page applications. However, before I discuss
those, let me first talk about REST and what it means for URLs.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc6010"></a>
REST</h2></div></div><p>
&ldquo;REST&rdquo; has nothing to do with sleep; it is an acronym for
Representational State Transfer and was coined by Apache cofounder
Roy Fielding in his PhD dissertation. The idea behind REST is that you
often see URLs as ways to access applications and documents on the
Web, including the things you want to do with those applications
and documents. So you might have a /register URL on your site, as
well as a /view_status or /see_book?id=100.
</p><p>
The REST says that you should stop creating such URLs, and that you
should instead see a URL as a unique way to describe an on-line
resource. Thus, user 100 on your system becomes /user/100. Wait, you
want to do something with user 100? That requires a verb, rather than
a noun. Instead of using the URL, or part of it, for the verb, you
instead should use the verb that already is being used with the URL&mdash;namely, one of the appropriate HTTP verbs. Most of us are only
familiar with the HTTP methods GET and POST, but there are a bunch of
others too. (Not that they're really supported by most browsers, of
course.)
</p><p>
Now, I must admit that when REST became a mainstream, and even
preferred, way to create URLs with Ruby on Rails, I tended to resist
it. But over time, I have learned to appreciate the elegant
simplicity of these URLs, particularly in an age when a growing number
of HTTP verbs are supported by browsers, or (as in the case of Rails)
you can automatically provide a parameter that indicates the request
method, overriding the POST that you always send.
</p><p>
Rails has been particularly successful at pushing REST as a paradigm,
in that controllers are assumed to provide seven
different methods automatically, which are mapped in a standard way to combinations
of HTTP request methods and URL patterns. Now, just because Rails
does REST a certain way doesn't mean that everyone needs to do it in
precisely that way, using the specific URL style and meaning that
Rails has defined. But that style, or something very close to it,
has become quite popular, as you can see from such packages as Grape
API for Ruby or Django REST Framework for Python.
</p><p>
One of the interesting aspects of using URLs in a REST framework is
that the URL now describes an object, which often is mapped not only
to a router and/or controller, but also to an object in a database.
Thus, the URL /users/1 effectively will allow me to retrieve, via the
Web, information about user with ID 1.
</p><p>
Although such information used to be passed in XML or even in HTML, it's
now fairly standard to transmit API data using JSON, which is
standard, easy to work with and implemented in all modern languages.
A RESTful API that uses JSON is increasingly common as the browser
portion of applications becomes more important and needs to load and
save data using these APIs.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc6328"></a>
Single-Page Apps</h2></div></div><p>
The most recent version of a Web application is the single-page
application. From a user's perspective, you can call it a &ldquo;single-page
application&rdquo;, because it doesn't ever need to refresh the whole page,
even when you click on a link or a button. Rather, JavaScript changes
the page on the fly, modifying the DOM elements and reacting to events
within the browser window.
</p><p>
It's possible to create single-page applications using a library such
as jQuery, but as things get complex, it becomes somewhat difficult
and frustrating to do so. You end up spending time developing
solutions that handle the infrastructure of such an application,
rather than the application itself. If this sounds familiar,
that's because the same thing happened about a decade ago. People were
tired of writing the same code again and again for their Web
applications. As a result, the notion of a &ldquo;framework&rdquo; was born, with
Rails and Django being two of the most prominent players in that
space.
</p><p>
Backbone.js was one of the first client-side frameworks, but it wasn't
the only one. Indeed, there are dozens of frameworks, each claiming
to be some degree of MVC (model-view-controller) that run in the
browser and allow programmers to create rich, client-side applications
in relatively short order. More recently, Backbone and its ilk have
given way to a new and more thoroughly designed type of framework,
with the two leading contenders being Ember.js and Angular.js. (I
intend to write about both of these quite a bit in the coming year.)
</p><p>
For me, at least, the most striking thing when I started to learn
Ember and Angular was their talk about the &ldquo;router&rdquo;. Now, in Rails, a
router is the part of the code that maps the URL /users/101 and knows
to invoke the appropriate code. And indeed, the router in Ember does
something very similar, taking the URL and ensuring that the correct
code is invoked.
</p><p>
But wait a second&mdash;I'm talking about a single-page app, right? If
you're working with Ember, what is your router doing worrying
about what URL is being passed? The answer, it turns out, is that the
router in both Ember and Angular aren't looking at the main part of
the URL, but rather the fragment. The URL will not be
/users/101
but rather
myapp.html#/users/101
or something of the sort. This means that you now effectively have two
URLs you need to think about: one that tells the server which
application you want and then a second that tells the client-side
application which JavaScript code to run. This new use of URLs still
looks somewhat strange to me, as it's making use of the fragment,
which I had largely ignored for years. However, it's also exciting to
see that URLs continue to be flexible, adapting to new uses for the
Web, and making it possible to continue using browsers in new and
interesting ways.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc66f0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
The ultimate reference for URLs, which doesn't mean that it's easy to
read or understand, is RFC 3986 at
<a href="http://tools.ietf.org/html/rfc3986" target="_self">tools.ietf.org/html/rfc3986</a>, published by the IETF, the body in
charge of many Internet standards.
</p><p>
If you are interested in looking at modern client-side frameworks, you
can learn more about them at <a href="http://backbonejs.org" target="_self">backbonejs.org</a> (for Backbone),
<a href="http://emberjs.com" target="_self">emberjs.com</a> (for Ember) and <a href="http://angularjs.org" target="_self">angularjs.org</a> (for Angular). All are
popular open-source projects with large and active communities.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xccd580.0xdc6ab8"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Reuven M. Lerner, a longtime Web developer, consultant and trainer,
is completing his PhD in learning sciences at Northwestern University.
You can learn about his on-line programming courses, subscribe to his
newsletter or contact him at <a href="http://lerner.co.il" target="_self">lerner.co.il</a>.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../242/toc242.html">Issue Table of Contents</a>
    <a class="link3" href="../242/11685.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>