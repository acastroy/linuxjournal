<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Using Linux at Left Field Productions</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    One programmer's experiece developing a Gameboy emulator on&#10;    Linux.&#10;    "><meta name="keywords" content="game, Gameboy, Left, Field"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1a46580.0x1b3dab0"></a>Using Linux at Left Field Productions</h1></div><div><div class="author"><h3 class="author">David Ashley</h3></div><div class="issuemoyr">Issue #75, July 2000</div></div><div><p>
    One programmer's experiece developing a Gameboy emulator on
    Linux.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a46580.0x1b3e4a8"></a></h2></div></div><p>Left Field Productions, Inc. is a game
developer in Westlake Village, California, which concentrates on
the console market, specifically the Nintendo N64 and Gameboy
systems. Their web page is at
<a href="http://www.left.com" target="_self">http://www.left.com/</a>. I
joined Left Field in September of 1998 to do Gameboy programming.
Since that time, Linux has been used on the company-wide network
offering various services, all running on a lowly Pentium 90 with
16MB of RAM and a single 6.4GB hard drive. The machine is known by
all as &ldquo;the Linux box&rdquo;.
</p><p>The company uses 10BaseT for all networking. The Linux box
also provides the main gateway to the Internet. It is running the
<span   class="bold"><b>named</b></span> name server, and the Apache
web server for company internal web pages. The Linux box has dual
mechanisms for connecting to the Internet: one through ISDN, the
other through a conventional 56K modem. ISDN is the preferred
method, but during occasional outages, it is necessary to downgrade
to the modem.</p><p>The Linux box provides public Samba services, making storage
area available for file backups and exchange among the artists and
programmers. The <span   class="bold"><b>fetchpop</b></span> program
was used to pull mail off our ISP and forward it to individual
accounts on the Linux box. When some problems with fetchpop arose,
mostly due to the lack of a timeout feature during mail retrieval,
I replaced it with <span   class="bold"><b>fetchmail</b></span>,
which we are still using. Periodically, employees' preferred
desktop mail client connects to the Linux box to retrieve their
mail and send any outgoing mail off to the Internet. Sendmail also
provides outgoing mail service.</p><p>The Linux box has enjoyed up times of more than 60 days. The
few times it has been rebooted were due to planned outages for
power utility service, and upgrades such as adding a new hard
drive. As far as I know, there has never been a system crash. I
think it is sometimes rebooted unnecessarily by some of the other
Linux-literate employees, as it can be more convenient than
specifically restarting a single task after modifying a
configuration file. Employees with lots of DOS/Windows experience
have a kind of &ldquo;when in doubt, reboot&rdquo; philosophy.</p><p>When I first started at Left Field, we used a free
assembler/linker combination for generating the code for the
Gameboy ROM images, and we used commercial painting and graphic
arts programs for art generation. The tools for converting and
compressing graphics files were all developed in-house. We used
Win32-based machines for everything. On my Pentium II 400 machine,
a complete rebuild, where all source files are assembled and then
linked, would take from 30 seconds to 2 minutes, depending on the
project. We were working on a basketball game called <span   class="emphasis"><em>Kobe
Bryant 3 on 3</em></span> and a Disney title called <span   class="emphasis"><em>Beauty
and the Beast, A Boardgame Adventure.</em></span></p><p>Once the ROM image was generated, we could download it to the
Nintendo debugger system for testing, or more frequently, we would
run it on a Gameboy emulator. The emulator was very usable, but it
had quite a personality and was temperamental at best. I found if I
exited the emulator and reloaded it a few times, it would
invariably crash the system. Also, it was unusable for testing the
sound aspects of the games&mdash;the quality of its sound emulation was
painful to hear. The emulator was actually a DOS program working
with an extender, and knew nothing about the Windows 95 windowing
environment. I think legacy is the most likely cause for its
instability.</p><p>After finishing up these first two projects, I found myself
with some free time before the next project began in earnest. I had
long been thinking of writing our own emulator because of my
dissatisfaction with the emulator we were using&mdash;the frequent
crashes and inability to get the source in order to repair it
ourselves was quite frustrating. So, within a couple of months of
starting at Left Field, I began some minor work writing an emulator
for the Gameboy CPU. All my programming was done in C. I installed
the public-domain DJGPP compiler and used it under DOS. In fact, I
was able to significantly speed up build times by using the MAKE
utility from DJGPP, replacing the Watcom MAKE we had been
using.</p><p>Unfortunately, the demands of the project caused me to stop
work on the emulator before I could even test it. Then, about a
year later, I had some free time again and was able to get back to
the code. This time, I chose to move away from Win32/DOS and switch
to <span   class="bold"><b>gcc</b></span> under Linux&mdash;a move that
made the programming infinitely more enjoyable. Surprisingly, there
were only a few mistakes in the emulation code, and in a short
time, I had the CPU &ldquo;working&rdquo;. It appeared to be behaving
correctly. The next step was to emulate the video hardware of the
Gameboy. For display output, I chose to use the SDL library, which
is a multi-platform gaming library. One of the supported platforms
is Win32, so the benefit there was that any code I wrote could be
used by other employees who were still running Windows. I was using
SDL under an X Window System environment. After some solid work, I
had the video emulation working quite well, and it was a joy to see
ROM images actually work.</p><p>Finally, I had to add the sound-emulation code. This proved
to be the easiest task, and after a short time, the emulator was
producing quite accurate and acceptable sound, again using the SDL
library. With a simple recompile using a cross compiler, an .EXE
executable could be built. The emulator worked under Win32 as well.
There were a few quirks related to sound under Windows 95 that had
to be worked out. Windows proved incapable of servicing the audio
interrupts at the 64Hz rate I had been using without problems under
Linux. I had to compromise and lower the rate to 32Hz so Windows
could keep up. I never determined whether the problem was in SDL's
Win32 code or in Windows itself.</p><p>The assembler/linker we had been using offered a version for
Linux, but I wasn't happy with it. The Linux source wasn't as up to
date as the DOS version&mdash;the two versions were based off different
source trees, and it was clear the DOS version had priority. My
options were to use the older Linux version or port the DOS code to
Linux. I chose instead to abandon the assembler and write my own.
Using core code that originated from my own ACC C-like compiler, I
managed to create an assembler with a syntax similar enough to the
assembler we had been using. I took the opportunity to make changes
in syntax when it was convenient. I knew how the assembler was
going to be used, and some features weren't important, so I never
implemented them.</p><p>In the end, my own assembler reported lines-per-minute
assembly rates over 30 times faster than the old assembler. With
the small source files, assembling each was practically
instantaneous. The next part I needed was the linker. Again, I
began with the ACC code and modified it to suit. Linking was also
much faster than before.</p><p>Now, to test the assembler/linker combination, I took our
game source trees and made the necessary syntax modifications in
the source files. I used the <span   class="emphasis"><em>Beauty and the
Beast</em></span> code, and spent about four hours going through all
the files to get something without linker errors. Naturally, the
resulting ROM image didn't work, but after a day of hunting for
bugs in all parts of the system, I got a ROM image that actually
came up on the emulator looking like the real game&mdash;very
encouraging.</p><p>In a project like this, debugging problems can be tricky.
When no single part has really been tested, a bug can be anywhere;
thus, I found myself frequently hunting in the wrong places for
bugs. Sometimes, I was surprised to find the assembler actually did
something right, and the emulator was to blame&mdash;and vice
versa.</p><p>In testing the ROM images with the emulator, it became
apparent I needed some debugging functions built into the emulator.
Even before beginning work on the assembler, I had added
disassembly capability to the emulator. Doing so had been very
helpful in finding bugs in the emulator. After I had the assembler
working, I added some nice features like symbolic debugging, break
points, expression evaluation, memory viewing and instruction
execution history. For text display and entry, I added a scrollback
buffer, name completion and
<span   class="bold"><b>tcsh</b></span>-style line editing.</p><p>Bugs became more and more rare, and were easier and easier to
find. It was clear the new system was completely viable for
developing, and an in-house suite of tools offered very strong
advantages that we would never get by using outside software. For
example, any desired feature could be added easily, since the
source was ours. For portability, I had written everything in
standard C. One thing I kept in mind was that at any moment I might
have to retreat from Linux and switch back to DOS, and I wanted the
tools to work there as well. The assembler and linker compiled
perfectly with DJGPP.</p><p>I was pleased to note build times were reduced to almost
nothing. A complete rebuild that had taken 30 seconds before took
three seconds now, on the same machine. It must be noted that those
times reflect two different operating systems as well as two
different assembler/linker pairs, so an actual breakdown of how the
speedup was occurring can't be made. I never bothered to do a
detailed analysis; I was happy just to be using the new
system.</p><p>On the other hand, my emulator, written in pure C, placed
significantly more demands on the CPU than the DOS emulator we had
been using. The author probably had hand-coded x86 code sprinkled
liberally throughout. I also assumed this was the source of most of
the crashes caused by that emulator.</p><p>To complete the Linux Gameboy development environment, I had
to port the various tools used for converting graphics files and
dealing with data files in general. Some I had created myself, and
these ported almost without modification because I had used DJGPP
as the C compiler. The only change required was related to the DOS
custom of having CR/LF (carriage return/line feed) as the end of a
line, rather than the UNIX-style LF only. DJGPP header files define
the flag <b  >O_BINARY</b> which must be used when
opening a file, to specify that CR/LF should not be converted.
Under Linux, <b  >O_BINARY</b> is not defined, so
compiler errors would result. The solution was to place the three
lines</p><pre     class="programlisting">
#ifndef O_BINARY
#define O_BINARY 0
#endif
</pre><p>early in the source files, so the source would work without
change under both DJGPP and gcc/Linux.
</p><p>The main graphics manipulation tools had been written by
someone else at the company, and I had to make more extensive
changes to get them to compile under gcc/Linux. There was the
<b  >O_BINARY</b> problem as before, but in addition,
some of the programs did wild-card expansion in the program itself.
The DOS shell doesn't do wild-card expansion, so DOS programs must
provide that service for themselves. Unfortunately, the functions
for performing this were nonstandard C and so wouldn't carry over.
In the end, I hacked out those sections of the code and relied on
standard UNIX shell wild-card expansion to do the job. Also, the
header file &ldquo;windows.h&rdquo; was included frequently, and that
dependence had to be removed as well as the structures and system
calls in the code that required it.</p><p>Another problem which came up is the DOS/Win32 standard
practice of file names being case insensitive. Under UNIX, case is
significant, so errors popped up in source files where a file such
as &ldquo;Elmer.h&rdquo; was being requested, when the file in the directory
was actually elmer.h (or even worse, ELMER.H). Also throughout the
code, programs would create an output file with an extension and
the extension would be in upper case, so I'd generate files with
names such as &ldquo;cpaused.CHR&rdquo;. To me, this was jarring and
unattractive, so I modified all the files to produce lower case
extensions. This required another round of changes when the wrong
file name was being referred to, and error messages were
appearing.</p><p>In the end, I managed to mirror on Linux every tool we had
under DOS/Win32. Developing code under Linux was vastly more
enjoyable than under DOS/Win32, mostly because it was faster and
more stable. There is also something very rewarding about using
your own tools in any work. In total, from start to finish, the
time to bring everything up on Linux, as well as writing the new
emulator, took about three to four weeks.</p><p>Shortly after the next project began taking form, one of the
artists asked if he could do builds himself, as he wanted to tinker
with animation frames and see how they looked in actual use. Rather
than go to the trouble of getting all the tools set up on his
machine, as a quick solution I copied the source tree to a
directory path that my machine had been making public with Samba.
The directory /d on my machine appeared as //dave/d on the network.
I set up a simple script to check for the existence of the ROM
image file. If the file wasn't there, it would do a rebuild. So, to
get a new ROM image, the artist would copy over the modified data
files, then delete the ROM image and wait a moment for the new
build to appear magically. With Linux's excellent disk caching, I
was usually unaware of when this happened.</p><p>One final problem caused me some worry. I was currently the
only person actually using Linux as a development platform. What
would happen if one of the other programmers wanted to contribute
to the project? I didn't want to force my Linux preference onto
anyone else, so I had to be able to deal with this. Already, all
our tools had equivalent Linux/DOS versions, so that wasn't a
problem. The problem would be from multiple programmers merging
code changes to the same source tree. Under Win32, we had been
using Microsoft Visual Source Safe for that. Although I suspected
there must be a Linux client for talking to Source Safe, I never
looked. Instead, I studied how to use
<span   class="bold"><b>CVS</b></span> (Concurrent Versions System),
the traditional source-code revision-control system used in a vast
array of open-source projects. After experimenting with CVS and
learning enough about its quirks, I found it performed at least as
well as Source Safe. It conveniently handles the end-of-line
problem by storing the source files in the repository in UNIX
format and adding/removing the CR as needed when dealing with a
Win32/DOS client. I'm using CVS on the command line, and I prefer
that to mouse clicks; CVS seems faster at updating the modified
files.</p><p>Even though I'm the only programmer on the current project, I
am checking my code changes into the network CVS server, just to
get into the habit of doing so, as well as to provide an additional
level of backup and modification history. As you might have
guessed, the CVS server is running on the Linux box.</p><p><a href="3828s1.html" target="_self">Related URLs</a></p></div></div>
<div class="authorblurb"><p>
       email: <a href="mailto:dash@xdr.com">dash@xdr.com</a>
       </p><p>
      <span   class="bold"><b>David Ashley</b></span>
      (dash@xdr.com) has been working with
      computers and electronics for over 24 years. He has written several
      free games for Linux, including Scavenger, XBomber and Sdlshanghai.
      He pays his bills by working at Left Field Productions, Inc. of
      Westlake Village, California, doing game programming for Nintendo
      consoles. Having recently become a father, he is finding himself
      with less and less time for his addiction&mdash;programming in Linux. He
      tells us, &ldquo;All opinions expressed in this article are my own and
      do not represent the opinions or official policy of Left Field
      Productions, Inc.&rdquo;</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../075/toc075.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>