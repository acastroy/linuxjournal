<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Say Goodbye to Reboots with Ksplice
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Tired of rebooting for kernel updates? Good news&mdash;now you don't have to,&#10;thanks to Ksplice Uptrack.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xd01580.0xdf8ac0"></a>
Say Goodbye to Reboots with Ksplice
</h1></div><div><div class="author"><h3 class="author">
Waseem
 
Daher
</h3></div><div class="issuemoyr">Issue #184, August 2009</div></div><div><p>
Tired of rebooting for kernel updates? Good news&mdash;now you don't have to,
thanks to Ksplice Uptrack.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdf92a8"></a></h2></div></div><p>
Everyone hates rebooting for updates. When system administrators reboot
their servers, they have to manage an inconvenient outage window&mdash;quite
possibly during the middle of the night&mdash;and they have to deal with the
lost productivity and annoyed users that result from the disruption.
Similarly, rebooting your desktop means losing all of your valuable
state&mdash;your favorite editor with the 35 open files you
were working on, your 14 terminals, and, of course, your paused
game of <span   class="emphasis"><em>Frozen Bubble</em></span>.

</p><p>
But the alternative&mdash;not installing updates right away&mdash;is even more
unpleasant. If your parents were anything like mine, they insisted
that you do two things: eat your vegetables and install your software
updates. Why? Well, first, vegetables provide your body with
much-needed nutrients. Second, most exploits take advantage of well-known
software vulnerabilities&mdash;vulnerabilities that do not exist on patched
systems. So staying up to date goes a long way in keeping your systems
secure and reliable.
</p><p>
So is this it? Will we forever be forced to choose between security and
availability? Fortunately, the answer is no. Ksplice, a startup company
founded by MIT alumni, has developed technology that can install software
updates, without requiring a reboot.
</p><p>
Using this technology, they are offering Ksplice Uptrack, a service
that keeps your Linux systems up to date and secure without any
hassle. Additionally, experienced kernel developers also can use the
Ksplice tools to create their own rebootless updates.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdf9670"></a>
Getting Started with Ksplice Uptrack</h2></div></div><p>
You can start using Ksplice Uptrack without any advance
preparation. Follow the directions on the Ksplice Uptrack Web site,
which allows you to install the software using your package manager.
</p><p>
Once you've done this, a K icon appears in your notification
area. When you see the K, you know that you have the latest security
fixes for your Linux kernel. When new updates are available, a warning
sign appears over the K.
</p><div       class="mediaobject"><img src="10395f1.jpg"><div class="caption"><p>
Figure 1. Ksplice Uptrack notifies you that new rebootless updates are available
by displaying a K with a warning sign in the notification area.
</p></div></div><p>
When this happens, click on the K to view a list of the available
updates. Install the updates by clicking the green Install all
updates button. The listed updates will be installed on your running
system in seconds, as your applications continue to run without
interruption.
</p><div       class="mediaobject"><a href="10395f2.large.jpg"><img src="10395f2.jpg"></a><div class="caption"><p>
Figure 2. The Ksplice Uptrack manager shows you a list of the available kernel
updates. These updates correct security and reliability problems in
the kernel. You can install these updates, without disrupting your
running applications, by clicking Install all updates.
</p></div></div><p>
Like any good Linux tool, Ksplice Uptrack also can be controlled from
the command line, with four simple commands. Each update has an ID
associated with it, which you use to name it. You can install or remove
individual updates, just like with any package manager. Here are the
Ksplice Uptrack Commands:
</p><div class="itemizedlist"><ul type="disc"><li><p>
<tt  >uptrack-upgrade</tt>: downloads and installs the latest kernel updates available
for your system. 
</p></li><li><p>
<tt  >uptrack-install id</tt>: installs the update named id.
</p></li><li><p>
<tt  >uptrack-remove id</tt>: removes the update named id.
</p></li><li><p>
<tt  >uptrack-show id</tt>: shows more detail about the update named id.
</p></li></ul></div><p>
What about when you actually do reboot? Well, you can boot in to your
brand-new kernel that you've installed the traditional way, using your
package manager. Everything will continue to work nicely, and when Ksplice
Uptrack detects new updates for this kernel, it will notify you, just
like before.
</p><p>
Alternatively, you can reboot into your old kernel. In this case,
Ksplice Uptrack will re-apply the rebootless updates early in the boot
process. This approach may be more desirable for some system
administrators, because it ensures that the machine is in the exact same
configuration both before and after the reboot.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdfa170"></a>
How It Works</h2></div></div><p>
New research originally conducted at MIT makes this rebootless update
software possible. Three basic actions are related to rebootless
updates: creating a rebootless update from a source code patch,
applying a rebootless update to a running system and reversing an
update. I describe each of these actions below.
</p><p>
To follow along with these examples on your own computer, you 
need to install the Ksplice utilities. Your distribution likely
already includes these utilities, so you can install them using your
package manager. If not, you can download them from the Ksplice
Web site.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdfa2d0"></a>
Creating a Rebootless Update</h2></div></div><p>
To prepare a Ksplice rebootless update, you need a few ingredients.
First, you need the source code of the running kernel&mdash;your Linux
distribution typically makes this available through your package
manager. You also need the kernel configuration file and the
System.map file. Finally, you need to point Ksplice at
your kernel headers by creating a symbolic link.
</p><p>
Ideally, you also would like the versions of the compiler and
assembler on your system to be the same as the ones that built the
original kernel. If they are too different, the Ksplice tools will
notice and complain before trying to install the update. (I explain why
later in this article.)
</p><p>
With all of the materials mentioned above, you can build a replica of
your running kernel.
</p><p>
In these examples, I assume that the directory
/usr/src/linux already contains the running kernel's
source. The following commands prepare your setup appropriately,
as described above:


<pre     class="programlisting">
$ mkdir /usr/src/linux/ksplice
$ cp /boot/config-`uname -r` /usr/src/linux/ksplice/.config
$ cp /boot/System.map-`uname -r` /usr/src/linux/ksplice/System.map
$ ln -s /lib/modules/`uname -r`/build /usr/src/linux/ksplice/build
</pre>
</p><p>
Next, you need the patch to the kernel that you want to apply. This
can be an ordinary patch taken from Linus Torvalds' git tree or a
patch of your own design. Let's use an example patch that modifies
the behavior of printk, the Linux kernel function that is
responsible for printing messages to the kernel log. I assume that
you have placed this patch in ~/printk.patch:

<pre     class="programlisting">
--- linux-2.6/kernel/printk.c  ...
+++ linux-2.6-new/kernel/printk.c  ...
@@ -609,6 +609,7 @@
        va_list args;
        int r;

+       vprintk("Quoth the kernel:\n", NULL);
        va_start(args, fmt);
        r = vprintk(fmt, args);
        va_end(args);
</pre>
</p><p>
Once this patch is applied, all messages that are printed using
printk will be preceded by the message &ldquo;Quoth the kernel:&rdquo;.
</p><p>
To create the rebootless update, run the following command
from the directory /usr/src/linux/kernel:

<pre     class="programlisting">
ksplice-create --patch=~/printk.patch /usr/src/linux
</pre>
</p><p>
It should output something like <tt  >Ksplice update tarball written to
ksplice-8c4o6ucj.tar.gz</tt>. This is the rebootless update that
corresponds to your source code patch.
</p><p>
Feeding your patch and the kernel's source code into
<tt  >ksplice-create</tt> will do the following: first, it compiles your
kernel twice&mdash;once without the patch and once with the patch applied.
</p><p>
Second, it compares the output of the two compilations,
looking for differences. In particular, it needs to find
functions that have changed. For each changed function, it pulls out a copy of
both the old and the new versions and puts them in the output file.
</p><p>
At this point, Ksplice has determined what functions have been changed by
the source code patch, and it has saved old and new versions of the changed
functions. Now, it must figure out how to install the new versions
of the functions safely, while the system is running.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdfa9b0"></a>
Applying a Rebootless Update</h2></div></div><p>
Applying the update from your perspective is quite simple. As root, run:

<pre     class="programlisting">
ksplice-apply ./ksplice-8c4o6ucj.tar.gz
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0xdfab10"></a></h2></div></div><p>
from the directory /usr/src/linux/kernel; ksplice-8c4o6ucj.tar.gz
is the name of the tarball created in the step above.
</p><p>
If the update has been applied successfully, kernel messages should
appear with &ldquo;Quoth the kernel&rdquo; in front of them. Let's verify this by
running <tt  >dmesg</tt>, which allows us to look at the kernel's log.
</p><p>
If all has gone well, you will see something like:

<pre     class="programlisting">
# dmesg | tail -n2
Quoth the kernel:
ksplice: Update 8c4o6ucj applied successfully
</pre>
</p><p>
What's happening under the hood to make this possible? Remember that
Ksplice has a list of functions that need to change in the running
kernel. In particular, it has the old versions (that is, the versions
that should be in memory right now) and the new versions.
</p><p>
First, it has to locate the functions that it's trying to change. So
if it's trying to change printk, as in this example, it
first needs to find it in kernel memory.
</p><p>
Once it has found it, it compares it to the old copy of
printk that it has in the tarball. Remember that this
version of printk was compiled from the unmodified kernel
source, with the same compiler and assembler. So the two versions
should match exactly. If they do not match, we act conservatively and
give up. This safety check is why Ksplice requires the same compiler and
assembler in the ksplice-create step.
</p><p>
Now that it has found the old copy of the function and confirmed that
it is the correct code, it needs to replace it. It accomplishes this by
first loading the new version of the function elsewhere in memory,
using the kernel's module loader. Next, at a safe time, it
overwrites the first instruction of the old function with a jump
instruction that goes to the new function. This is called a
trampoline, because it &ldquo;bounces&rdquo; all of the callers of the old
function immediately over to the new function.
</p><div       class="mediaobject"><a href="10395f3.large.jpg"><img src="10395f3.jpg"></a><div class="caption"><p>
Figure 3. To replace a function, first a new version is loaded into memory.
Then, at a safe time, a trampoline is inserted at the start of the
old version of the function, redirecting all callers to the new code.
</p></div></div><p>
When is it safe to do this replacement? At a high level, we want to
replace the code when no one else is using it. If the code is being
used while it is being replaced, we potentially could end up with a
problem. For example, if the old version of a function locked a
resource in one way, and the new version locks it in another, and both
run at the same time, we could end up in a situation in which they
step on each other's toes.
</p><p>
So how does Ksplice make sure that no one is using the code while it is being
replaced? It examines the stack of every kernel thread to ensure
that no one has a pointer into the code that is being replaced. Said
another way, if no one can reference the old code, no one is using the
old code, so it's safe to replace it. This whole process takes place
while the machine is briefly paused using Linux's
stop_machine mechanism, to make sure that no new references
get added when we're not looking.
</p><p>
If this check concludes that it is not a safe time to update the code
(that is, if someone is holding a reference to the old code),
ksplice-apply aborts the update process. Trying again is
harmless, however, and if the update does not apply right away, it
will generally apply after a few tries. This is because essentially
none of the code in the kernel is <span   class="emphasis"><em>constantly</em></span> in
use.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0x11f3548"></a>
Reversing a Rebootless Update</h2></div></div><p>
Anything that can be applied also can be reversed, and the Ksplice
tools let you do this easily. To undo an update, simply run
<tt  >ksplice-undo</tt> with the update's ID, like so:

<pre     class="programlisting">
# ksplice-undo 8c4o6ucj
</pre>
</p><p>
If this process succeeds, a message will show up in the kernel's log:

<pre     class="programlisting">
# dmesg | tail -n1
ksplice: Update 8c4o6ucj reversed successfully
</pre>
</p><p>
If you forget the update ID, fear not. <tt  >ksplice-view</tt> will list
the Ksplice updates currently installed on your system.
</p><p>
Under the hood, reversing an update is very similar to applying an
update. Ksplice finds the old and new functions, and at a safe time,
it <span   class="emphasis"><em>removes</em></span> the trampoline. Now, all callers
of the old function will continue to get the old function.
In the context of a removal, a safe time is determined as it was before,
except now Ksplice makes sure that the new code is not in use.
Because the tarball contains the old code, it's easy for Ksplice
to determine with what code to replace the trampoline.
</p><p>
Determining which updates are installed is also easy. Remember that
the new code gets into the kernel by being loaded as a module. As a
result, it appears in the <tt  >lsmod</tt> output, which
ksplice-view can examine.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0x11f39c0"></a>
Pushing the Limits</h2></div></div><p>
Can this technology really be used to keep production machines up to
date for extended periods of time? Absolutely. In fact, a Ksplice
evaluation of all of the serious Linux security vulnerabilities
between May 2005 and May 2008 shows that all of them can be applied as
rebootless updates.
</p><p>
However, there is a caveat: a programmer needs to write a small amount
of additional code (about 17 lines per patch, on average) for about
12% of these patches. So what sorts of patches require this additional
code, and why?
</p><p>
Let's say that we find a bug in a kernel function that gets
called only when the machine is booting and never gets called again. Let's
say that this function was supposed to set a flag, but doesn't.
</p><p>
We can create a Ksplice update that fixes the function, but that
doesn't really accomplish anything, because the function never will be
called again (so the bug never will be corrected).
</p><p>
Instead, a kernel programmer needs to write some additional code that
transforms the state of the kernel to correct the bug. In this case,
the update will need to set the flag when it is applied.
</p><p>
However, determining whether a patch is safe to apply without
additional code is tricky, as is writing the additional code. In
general, patches that change initialization values or add new fields
to data structures require additional code, but this is not a hard-and-fast rule. As a result, you should not construct your own Ksplice
updates for use on production systems unless you are an experienced
kernel developer.
</p><p>
That said, you still can reap the benefits of this new technology by
using the Ksplice Uptrack service without having to do any of the
work, because the Ksplice Uptrack folks have done it for you.
</p><p>
Rebootless updates represent an exciting step forward&mdash;and, with
Ksplice Uptrack, Linux is the first mainstream operating system that
does not require reboots for security updates, ever.
</p><p>
So, say goodbye to reboots, and keep working on that high score of
yours.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xd01580.0x11f3d88"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
About the Ksplice Uptrack service, including instructions for
installing and getting started with the service:
<a href="http://www.ksplice.com/uptrack" target="_self">www.ksplice.com/uptrack</a>.
</p><p>
Sign up for the Ksplice mailing list if you're interested in hearing more:
<a href="http://lists.ksplice.com" target="_self">lists.ksplice.com</a>.
</p><p>
A detailed technical paper on the internals of Ksplice's core technology:
<a href="http://www.ksplice.com/paper" target="_self">www.ksplice.com/paper</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Waseem Daher is a cofounder of Ksplice. He lives and works in
Cambridge, Massachusetts, and can be reached at
<a href="mailto:wdaher@ksplice.com">wdaher@ksplice.com</a>.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../184/toc184.html">Issue Table of Contents</a>
    <a class="link3" href="../184/10395.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>