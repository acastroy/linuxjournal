<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Almost Internet with SLiRP and PPP</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Connecting to the Internet with Linux.&#10;    "><meta name="keywords" content="communication, network, WWW, Internet, programming, system, admin"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1147580.0x123eab0"></a>Almost Internet with SLiRP and PPP</h1></div><div><div class="author"><h3 class="author">Jim Knoble</h3></div><div class="issuemoyr">Issue #24, April 1996</div></div><div><p>
    Connecting to the Internet with Linux.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x123f558"></a></h2></div></div><p>It's the '90s. More and more people
around the world have heard of &ldquo;getting connected to the
Internet.&rdquo; Some of those have actually made the technological,
intellectual, and cultural leap into &ldquo;Cyberspace&rdquo;. And some of
<span   class="emphasis"><em>those</em></span> are using Linux to get connected. I'm
part of all three groups. In fact, I've become rather dependent on
my Internet connection&mdash;it's like having a telephone, only more
expensive.
</p><p>To be connected to the Internet, you used to have only two
choices: either a direct (and expensive) Internet connection, like
those used by corporations and institutions, or a modem connection
into somebody else's machine which had a direct Internet
connection, using your computer as if it were a &ldquo;dumb terminal&rdquo;.
You can still do that today, if you feel like it, but with the
increasingly common availability of &ldquo;real&rdquo; net connections like
SLIP (Serial Line Internet Protocol) and PPP (Point-to-Point
Protocol), fewer Internet users really want to feel as if all they
have on their desk is a dumb terminal. Yet, for a number of
reasons, the only Internet access available to some of us is a
dial-up dumb-terminal-ish Internet account, or &ldquo;shell&rdquo;
account.</p><p>Enter SLiRP. SLiRP is a freely available software package,
written by Danny Gasparovski
(<a href="mailto:danjo@blitzen.canberra.edu.au">danjo@blitzen.canberra.edu.au</a>),
which makes an ordinary shell account act like a SLIP or PPP
account. There are other so-called &ldquo;SLIP emulators&rdquo; available
(one of the more notable of which is The Internet Adaptor&mdash;see
<a href="1174ref.html" target="_self">References sidebar</a>, as well as
&ldquo;terminal multiplexers&rdquo; such as
<span   class="bold"><b>term</b></span>, which uses a non-standard
protocol between the shell account and the local computer. SLiRP
has advantages over both groups, many of which, along with some
disadvantages, the author details in the README file accompanying
the SLiRP package.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x123f870"></a>The Remote Half: Installing SLiRP</h2></div></div><p>SLiRP does not run on your &ldquo;local&rdquo; computer (the one that
would otherwise be a dumb terminal), but rather on the &ldquo;remote&rdquo;
computer (the one that's actually connected to the Internet). In
order to install SLiRP properly, you need the following:</p><div class="itemizedlist"><ul type="disc"><li><p>A Unix shell account on the remote host</p></li><li><p>A C compiler available on the remote host</p></li><li><p>An editor that you know how to use on the remote
host</p></li></ul></div><p>If you're not sure whether you have a compiler or editor
available, please contact your system administrator, or someone
else who is familiar with your remote site.</p><p>The steps involved in installing SLiRP are as follows:</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x123fc90"></a>Getting SLiRP</h2></div></div><p>The most recent version of SLiRP available at the time of
this writing is slirp-0.95h.tar.gz. See
<a href="1174ref.html" target="_self">References sidebar</a> to find SLiRP.
Once you have the package, &ldquo;untar&rdquo; it somewhere useful (such as
/usr/local/src)--perhaps with the command <b  >tar zxvf
slirp-0.95h.tar.gz</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x123fe48"></a>Compiling the source code</h2></div></div><p>Documentation of many sorts is included in the SLiRP package
in slirp-0.95h/docs. Instructions for compiling SLiRP are in
slirp-0.95h/docs/README.compiling, the gist of which is: change to
the slirp-0.95h/src directory and run the configure program located
there (usually by typing <b  >./configure</b>); then
build the program by typing <b  >make</b>. If you have
problems, consult the file
slirp-0.95h/docs/README.getting-help.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1240000"></a>Installing the program</h2></div></div><p>When you have successfully compiled SLiRP, you will need to
put the SLiRP binary somewhere where you can run it. If you don't
already have a directory for your own programs, I suggest creating
a directory called ~/bin, and then adding it to your
<b  >PATH</b> in your login scripts. If you're not sure
how to do this on your system, check with your system
administrator. Then, from the slirp-0.95h/src directory, perform
the following commands:</p><pre     class="programlisting">
strip slirp
cp slirp ~/bin
chmod 0700 ~/bin/slirp
</pre><p>(Alternatively, if your site has GNU `install' available, you
may perform the above actions in one step with <b  >install -s
-m 0700 slirp ~/bin</b>.)
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1240268"></a>Configuring SLiRP</h2></div></div><p>This is the tricky bit, partly because SLiRP is an evolving
product, and its documentation is not necessarily entirely complete
and up-to-date; however, I suggest reading slirp-0.95h/docs/CONFIG
and slirp-0.95h/docs/README.ppp before doing anything else. Next,
using your favorite text editor, create SLiRP's configuration file,
called ~/.slirprc. At the very minimum, you will want to include a
<b  >baudrate</b> setting. If you're planning on using
SLiRP to emulate PPP, you should also include a
<b  >ppp</b> flag, an <b  >asyncmap</b> setting
and <b  >mtu</b> and <b  >mru</b> values. Your
.slirprc file might look something like mine:</p><pre     class="programlisting">
baudrate 115200
ppp
asyncmap 0
mtu 552
mru 552
log start
</pre><p>You will most likely want to adjust the &ldquo;baudrate&rdquo; to suit
your modem&mdash;some experimentation may be necessary. [&ldquo;baudrate&rdquo;
should really be bits per second, or bpsrate. Even geeks who happen
to know that their 14400 bps modems run at 2400 baud shouldn't set
the baudrate parameter to 2400..  &mdash;ED]
</p><p>Once you have SLiRP installed and configured, you can start
it by simply typing <b  >slirp</b>; SLiRP will then
attempt to initiate a connection.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1240688"></a>The Local Half: Installing PPP Under
Linux</h2></div></div><p>SLiRP is only half of your net connection; you also need to
activate the other half of the connection on your local Linux
machine. Linux, like SLiRP, &ldquo;speaks&rdquo; both SLIP and PPP&mdash;that is,
support for TCP/IP networking over both SLIP connections and PPP
connections is built into the Linux kernel. However, although both
are available under Linux, I highly recommend using PPP instead of
SLIP, for the following reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>PPP is an Internet Standard Protocol&mdash;this means
that it has undergone a standardization process approved by the
Internet Architecture Board (IAB) and is an official part of the
Internet Protocol Suite. SLIP, by contrast, is an &ldquo;Internet
non-standard&rdquo; and is not on the standard track.</p></li><li><p>PPP will work over some connections that are not
8-bit-transparent; SLIP will not.</p></li><li><p>PPP can support authentication, peer address
negotiation, packet header compression, and point-to-point error
correction; SLIP can support none of these (although Compressed
SLIP, or CSLIP, does support packet header compression).</p></li></ul></div><p>In short, it is my opinion that PPP is capable of providing a
more robust and reliable connection than SLIP without significantly
reducing the apparent speed of the connection.</p><p>PPP support under Linux comes in two halves. One half is part
of the network system drivers, and comes built into the Linux
kernel. The other half is a <span   class="emphasis"><em>daemon</em></span> process
called <span   class="bold"><b>pppd</b></span>, which comes as a
separate package.</p><p>Most distributions today come with PPP support built in, but
if your Linux system is built from an older distribution, you may
need to install PPP support. In order to properly install PPP
networking under Linux, you need gcc installed, and either:</p><div class="itemizedlist"><ul type="disc"><li><p>A Linux kernel version 1.1.13 or greater with PPP
support compiled in, or</p></li><li><p>A Linux kernel version 1.0 or greater, plus either
some experience compiling a Linux kernel or someone to help you do
it.</p></li></ul></div><p>If you don't know whether your kernel has PPP support
compiled in, look for a message similar to the following when you
boot up your machine:</p><pre     class="programlisting">
PPP: version 0.2.7 (4 channels) <span   class="emphasis"><em>[...]</em></span>
</pre><p>You can also use the command <b  >dmesg | grep
PPP</b> to search the kernel boot messages for the above
line. If no PPP messages exist, you will need to recompile your
kernel to add PPP support (unless you are using the PPP kernel
module; some distributions come with a PPP module ready to use). If
you don't know what version your kernel is, use the <b  >uname
-a</b> command to display information about your system. If
your kernel version is less than 1.1.13, you may need to recompile
your kernel with a new PPP driver in order to use PPP. If you need
to recompile your kernel, and especially if you need to install a
newer PPP driver, see the documentation accompanying the pppd
package and the Linux Documentation Project's
<span   class="bold"><b>PPP-HOWTO</b></span> and
<span   class="bold"><b>Kernel-HOWTO</b></span> for more
information.</p><p>The steps involved in setting up PPP are as follows:</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x16392d0"></a>Getting pppd</h2></div></div><p>The latest version of pppd at the writing of this article is
ppp-2.1.2d.tar.gz. You may already have pppd; many Linux
distributions include it. You can check for it with the following
command: <b  >find / -name "pppd*" -print</b>. If your
distribution already has pppd installed, you can proceed to the
configuration step. If you're going to be compiling pppd, untar the
source package somewhere useful (such as the place you untarred
SLiRP).</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1639430"></a>Compiling and installing pppd</h2></div></div><p>The pppd package comes with thorough instructions, including
some specifically for Linux users, located in pppd-2.1.2d/README
and pppd-2.1.2d/README.linux. I recommend you read both those
documents and any documentation located in pppd-2.1.2d/linux before
compiling and installing pppd. Then, change to the pppd-2.1.2d/pppd
directory and create a Makefile using <b  >cp Makefile.linux
Makefile</b> (I recommend copying instead of linking so that
you can make changes to the makefile if necessary without affecting
the original). Inspect the makefile to make sure
<b  >BINDIR</b> and <b  >MANDIR</b> are set to
the correct location to install the pppd binary and manual page
respectively (to comply with the Linux Filesystem Standard, they
should probably be set to /usr/sbin and /usr/man). Make any
required changes to the makefile using your favorite text editor.
Build pppd by running <b  >make</b>. To install pppd,
first become the superuser (either by logging in as root or using
the <b  >su</b> command) and type <b  >make
install</b>; this installs both the pppd binary and the
manual page. If you are replacing an older version of pppd, you may
wish to make a backup copy of the older pppd until you are sure the
new one works correctly. [If you are using the latest development
kernel, you will need the latest version of pppd as well; it will
be the latest in the 2.2.0 series, kept in the same places as the
older 2.1.2 series pppd sources&mdash;ED]</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1639748"></a>Compiling and installing chat</h2></div></div><p>The pppd package comes with a utility program called
<span   class="bold"><b>chat</b></span> which performs
&ldquo;expect-send&rdquo; scripts for dialing modems, performing automated
logins, etc. chat is located in pppd-2.1.2d/chat/. The steps for
compiling and installing chat are essentially the same as for pppd:
copy the makefile, edit to suit your system,
<b  >make</b>, and then <b  >make install</b>
as the superuser. The chat manual page, however, needs to be
installed by hand; use</p><pre     class="programlisting">
install -m 0444 -o root -g man chat.8 /usr/man/man8/
</pre><p>to do this.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x1639a08"></a>Configuring pppd</h2></div></div><p>Now is a good time to read the manual page for pppd. While it
is rather long, the manual page contains some information critical
to understanding how to set up pppd, including explanations of
several scripts called by pppd. There are several steps involved in
properly configuring pppd, and a few more in making it convenient
to use:</p><div class="itemizedlist"><ul type="disc"><li><p>Creating the system-wide pppd configuration file
/etc/ppp/options.</p></li><li><p>Modifying the network configuration files to work
with a PPP connection.</p></li><li><p>Creating the scripts /etc/ppp/ip-up and
/etc/ppp/ip-down to perform any needed actions when the PPP link
becomes active and before it is closed, respectively.</p></li><li><p>Configuring the system logging facility so that
messages from pppd are written to the system logs.</p></li><li><p>Creating scripts to start and stop pppd
gracefully.</p></li></ul></div><p>The system-wide configuration file, /etc/ppp/options, is the
most important thing to get right for pppd to work. The file must
exist and be readable by the root user, even if you don't plan to
store configuration information in it&mdash;otherwise, pppd won't start.
Unfortunately, there are so many possible options to configure for
pppd that it's difficult to build a configuration file from
scratch. I have put together an options file template for pppd,
which includes each configurable option and explanatory text taken
directly from the pppd manual page, and made it freely available
for anonymous FTP (see <a href="1174ref.html" target="_self">References</a>
for locations). I recommend fetching the pppopt.tgz package to use
as a starting point for configuration.</p><p>A configuration file for pppd looks like this:</p><pre     class="programlisting">
## /etc/ppp/options -- config file for pppd
# async character map -- 32-bit hex; each bit
# is a character that needs to be escaped for
# pppd to receive it.  0x00000001 represents
# "&lt;\&gt;x00", and 0x80000000 represents "&lt;\&gt;x1f".
asyncmap 0
# Use hardware flow control (i.e. RTS/CTS) to
# control the flow of data on the serial port.
crtscts
# Add a default route to the system routing
# tables, using the peer as the gateway, when
# IPCP negotiation is successfully completed.
# This entry is removed when the PPP connection
# is broken.
defaultroute
# Set the MRU [Maximum Receive Unit] value to &lt;n&gt;
# for negotiation.  pppd will ask the peer to send
# packets of no more than &lt;n&gt; bytes. The minimum
# MRU value is 128. The default MRU value is 1500.
# A value of 296 is recommended for slow links
# (40 bytes for TCP/IP header + 256 bytes of data)
mru 552
# Disables the default behaviour when no local IP
# address is specified, which is to determine (if
# possible) the local IP address from the
# hostname. With this option, the peer will have
# to supply the local IP address during IPCP
# negotiation (unless it is specified explicitly on
# the command line or in an options file).
noipdefault
</pre><p>This file assumes that the modem is set to use hardware flow
control (<b  >crtscts</b>), that the link between the
local machine and the remote one is 8-bit-clean (<b  >asyncmap
0</b>), and that the remote machine will tell pppd what the
local machine's IP address is (<b  >noipdefault</b>). It
also tells pppd to add a &ldquo;default route&rdquo; to the system routing
tables (<b  >defaultroute</b>), which is generally what
we want for a dial-up Internet connection, and sets the &ldquo;maximum
receive unit&rdquo;, the largest PPP packet that pppd will accept, to
552 (<b  >mru 552</b>).</p><p>If you want to use software flow control instead of hardware
flow control for your modem, you can use <b  >xonxoff</b>
instead of <b  >crtscts</b>. You also need to add the XON
and XOFF characters to the <b  >asyncmap</b> option, as
follows: the number following <b  >asyncmap</b> is a
32-bit hexadecimal number, where each bit represents a character
between 0x00 (<b  >^@</b>) and 0x1f
(<b  >^_</b>) which must be &ldquo;escaped&rdquo;, or sent as a
two-byte sequence to avoid getting swallowed or munged in
transmission; <b  >asyncmap 000a0000</b> escapes
characters 0x13 (<b  >^S</b>) and 0x11
(<b  >^Q</b>), the XON/XOFF characters. You will also
need to add this <b  >asyncmap</b> setting to your SLiRP
configuration file on the remote host.</p><p>The network configuration files on your Linux system which
you need to modify or check are:</p><div class="itemizedlist"><ul type="disc"><li><p>/etc/rc.d/rc.inet1 or /etc/rc.net, the network
configuration script (it may be called something slightly
different, depending on your distribution)</p></li><li><p>/etc/hosts, the hostname-to-address configuration
file</p></li><li><p>/etc/resolv.conf, the resolver configuration
file</p></li></ul></div><p>Configuration of these files is discussed in detail in the
README.linux file that comes with pppd under the heading &ldquo;General
Network Configuration&rdquo;; however, a few items are important for
using pppd with SLiRP:</p><div class="itemizedlist"><ul type="disc"><li><p>In /etc/hosts, use the address `10.0.2.15' as the
address for your Linux machine; this is the address SLiRP uses by
default. For example, my own machine is called &ldquo;zephyr&rdquo;, in the
fictitious domain &ldquo;earth&rdquo;, and the following line appears in my
host table after the loopback entry:</p></li></ul></div><pre     class="programlisting">
10.0.2.15 zephyr.earth zephyr
</pre><div class="itemizedlist"><ul type="disc"><li><p>In order to fill in the
<b  >nameserver</b> part of /etc/resolv.conf, you need to
know the address of the nameserver for the remote host. There are
three ways to find out this information, in order from least to
most effort:
</p><p>(1) Use the command <b  >nslookup</b>, which will
print the name and numeric address of the default nameserver (use
<b  >exit</b> to exit nslookup);</p><p>(2) Read the remote resolver configuration file using the
command <b  >cat /etc/resolv.conf</b>--it should have
nameserver entries just like the ones you need; or</p><p>(3) Ask the system administrator, who may or may not be
willing to give you that information.</p></li></ul></div><p>You may wish to perform certain actions when the PPP link
opens and to perform others when the PPP link closes down; you can
put such actions in scripts called /etc/ppp/ip-up and
/etc/ppp/ip-down. For instance, I have configured smail (my mail
delivery agent) to send outgoing mail to my Internet account
provider, which is only available when my PPP link is up. In my
ip-up script, I have a command to send any queued outgoing mail
along to the smart-host for delivery.</p><pre     class="programlisting">
#!/bin/sh
#
# /etc/ppp/ip-up -- do net-stuff when ppp is up
# send queued outgoing mail over new net connection
/usr/sbin/runq
</pre><p>The ip-up and ip-down programs do not have to be shell
scripts&mdash;they could just as easily be written in Perl, Tcl, or any
other scripting language. However, the scripts should be
executable, i.e. they should have execute permission set
(using</p><p>Do not break up the following line:</p><pre     class="programlisting">
chmod 0755 /etc/ppp/ip-up /etc/ppp/ip-down
</pre><p>and the first line of the script should be of the format
<b  >#!<i><tt>path-to-program</tt></i></b>,
containing the complete path to the program that should run the
script (e.g., <b  >#!/bin/sh</b> for a Bourne shell
script, or <b  >#!/usr/local/bin/perl</b> for
Perl).</p><p>pppd sends messages and some debugging information to the
system logging facility <span   class="bold"><b>syslogd</b></span>.
You may wish to configure syslogd so that those messages get logged
to a separate log file; to do this you need to become the superuser
and modify the syslogd configuration file /etc/syslog.conf. pppd
logs to the &ldquo;daemon&rdquo; facility, so we add the following line to
syslog.conf:</p><pre     class="programlisting">
# Log daemon-related messages in a special place
daemon.*        /var/log/daemon.log
</pre><p>You should put the daemon log in the same place as your other
system logs; the Linux Filesystem Standard recommends /var/log. In
order to get syslogd to re-read its configuration file, send it a
hangup signal using the command <b  >kill -HUP
<i><tt>pid</tt></i></b>, where
<b  ><i><tt>pid</tt></i></b> is the numeric
process id for syslogd as shown in a listing made by a <b  >ps
ax</b> command. Alternately, use <b  >killall -HUP
syslogd</b>.</p><p>Since it can be a bit tedious trying to start and stop pppd
from the command line, I recommend creating two executable scripts
called ppp-on and ppp-off. The pppd package comes with sample
scripts in pppd-2.1.2d/chat, which you may wish to use as a guide.
Simple versions of each are shown in <span   class="bold"><b>Figure
1</b></span> and <span   class="bold"><b>Figure 2</b></span>. You
should probably install the scripts in the same place as you
install pppd (for my system, /usr/local/ppp/bin).</p><p>Figure 1. <a href="1174f1.html" target="_self">Example ppp-on
Script</a></p><p>Figure 2. <a href="1174f2.html" target="_self">Example ppp-off
Script</a></p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x154d320"></a>Making the Relationship Work</h2></div></div><p>With SLiRP installed on your remote host and pppd installed
on your Linux machine, it's time to try to get them to work
together. It's a good idea to dial into your Internet service
provider (the remote machine) using your favorite communications
package (such as kermit, minicom, or Seyon) for the first few times
in order to test the login and connection process. There are
several steps to take:</p><div class="itemizedlist"><ul type="disc"><li><p>Display the system routing table using the command
<b  >netstat -rn</b> on your local machine. If netstat is
not available, try using the command
<b  >/sbin/route</b>. If neither of those commands is
available, you may need to install a networking package from your
Linux distribution&mdash;stop here and check your distribution
documentation or consult your local Linux guru. Your routing table
should look similar to Figure 3.</p></li></ul></div><p>Figure 3. <a href="1174f3.html" target="_self">Initial Routing
      Table</a></p><div class="itemizedlist"><ul type="disc"><li><p>Start your favorite communications package.</p></li><li><p>Set your modem not to hang up when DTR is dropped
(consult your modem documentation for how to do this&mdash;for
Hayes-compatible modems, the command is usually
<b  >at&amp;d0</b>).</p></li><li><p>If your communications package has a session
logging feature (e.g., kermit's <b  >log session</b>
command), turn on session logging.</p></li><li><p>Dial the remote machine and log in as you normally
do. If your communications package doesn't have a session logging
feature, you should record the login procedure by hand, writing
down both what prompts appear and what you type in response.</p></li><li><p>Start SLiRP from your shell prompt, using the
command <b  >slirp</b>.</p></li><li><p>Stop session logging if you started it above, and
either suspend your communications program or disconnect it from
the modem (I recommend the second; in kermit you can say
<b  >set line</b> at the command prompt to disconnect
without hanging up or exiting kermit).</p></li><li><p>Start pppd using the command
<b  >ppp-on</b>.</p></li><li><p>Wait a few seconds for the connection to come up,
and then display the network routing table again. Your routing
table should now have entries for the remote host similar to Figure
4, where
<b  ><i><tt>xxx.xxx.xxx.xxx</tt></i></b> is
the IP address of the remote host.</p></li></ul></div><p>Figure 4. <a href="1174f4.html" target="_self">Final Routing Table</a></p><div class="itemizedlist"><ul type="disc"><li><p>If your routing table appears to be correct, try
connecting to the remote machine with the command <b  >telnet
<i><tt>xxx.xxx.xxx.xxx</tt></i></b>, using the IP
address shown in the routing table, and log in as you normally
would. If that works, try [telnet <span   class="emphasis"><em>hostname of the remote
machine</em></span> or telnet to another host that you know of.
You're connected! When you're done, use <b  >ppp-off</b>
to stop pppd, and resume your communications program. To stop
SLiRP, wait a moment and type <b  >0</b> (zero) five
times. SLiRP actually requires a short pause in between each 0 to
recognize it as a shutdown string, but normal typing speed works
fine. Log out, and hang up your modem.</p></li><li><p>If those routing table entries do not appear, first
check that your pppd configuration file /etc/ppp/options contains a
<b  >defaultroute</b> entry. Next, check that there is no
entry for <b  >passive</b> or <b  >silent</b>
in your pppd configuration file&mdash;by default, SLiRP silently waits
for the other end of the PPP connection (in this case, pppd) to
send configuration packets. If the entries are not there, check
that pppd is still active, using the command <b  >ps ax | grep
pppd</b>--if it's not in passive or silent mode, pppd will
time out if it receives no answer after sending a certain number
(10 by default) of configuration requests.</p></li><li><p>If pppd times out, check the system logs for
entries from pppd. If you didn't configure syslogd to catch
messages from pppd as described above, now would be a good time to
do that. Note that you can increase the level of system log
messages from pppd by putting a <b  >debug</b> entry in
pppd's configuration file. SLiRP will also perform several levels
of logging: <b  >slirp -d ~/slirp.log</b> will log
debugging output to the file ~/slirp.log on the remote host; adding
the entry <b  >log start</b> to the SLiRP configuration
file ~/.slirprc will log startup information to ~/.slirp_start; and
adding the entry <b  >debug</b> to the PPP section of the
SLiRP configuration file will log PPP debugging output to the file
~/ppplog.</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x154e660"></a>Gluing the Pieces Together</h2></div></div><p>Once you have pppd and SLiRP talking to each other, you can
create a more sophisticated ppp-on script to automatically dial the
remote host, log you in, start slirp, and then start pppd on your
Linux machine. I have created such a script which uses the &ldquo;chat&rdquo;
utility that came with the pppd package; it is shown in
<span   class="bold"><b>Figure 5</b></span>.</p><p>Figure 5. <a href="1174f5.html" target="_self">Sophisticated ppp-on
Script With chat Options</a></p><p>This shell script is designed to look in a certain directory
(such as ~/.ppp or /usr/local/ppp/script) for &ldquo;chat scripts&rdquo; to
use in dialing and logging in. When started with an argument, e.g.,
<b  >ppp-on <i><tt>my-isp-name</tt></i></b>,
this version of ppp-on will use a chat script called
~/.ppp/<span   class="emphasis"><em>my-isp-name</em></span>.chat for dialing and
logging in. Such a feature allows a single user to have multiple
dialing scripts for multiple Internet Service Providers, and allows
multiple users to keep their passwords private.</p><p>When started with the <b  >-c</b> option, this
ppp-on script can also execute a custom script after starting the
PPP connection. For example, <b  >ppp-on -c</b> would
perform a script called ~/.ppp/default.ppp after starting pppd, and
<b  >ppp-on -c <i><tt>my-isp-name</tt></i></b>
would dial and automatically log me in using the chat script as
described above, then perform
<b  >~/.ppp/<i><tt>my-isp-name</tt></i>.ppp</b>
after starting pppd. This can be a useful substitute for the
/etc/ppp/ip-up script in a multi-user environment. Additionally,
this ppp-on script allows a verbose option <b  >-v</b> to
log the execution of the chat script to the system logs for
debugging.</p><p>A chat script consists of a sequence of &ldquo;expect-send&rdquo;
strings separated by whitespace. chat expects to receive on its
standard input the first non-keyword string in the script; when it
does, it sends the next non-keyword string followed by a carriage
return to the standard output, and so on. To make a customized chat
script, you can use the session log you made above while logging
into your remote host. A sample session log and the resulting chat
script are shown here; you may wish to consult chat's manual page
as well.</p><p>First, the sample session log:</p><pre     class="programlisting">
at
OK
atz
OK
at&amp;b0s0=0
OK
atdt<span   class="emphasis"><em>MY-PHONE-NUMBER</em></span>
CARRIER 28800
PROTOCOL: LAP-M
CONNECT 115200
Welcome to My Internet Service Provider
suchandsuch login: <span   class="emphasis"><em>MY-LOGIN-ID</em></span>
Password:
--SYSTEM NEWS--
        blah blah blah blah
        blah blah blah blah blah blah.
TERM = unknown
TERM = (vt100) vt102
<span   class="emphasis"><em>MY-SHELL-PROMPT</em></span>% slirp
</pre><p>And this is the chat script that matches the session
log:</p><pre     class="programlisting">
ABORT BUSY
ABORT "NO CARRIER"
ABORT "NO DIALTONE"
TIMEOUT 2   OK-at-OK atz
TIMEOUT 5   OK at&amp;b0s0=0
            OK atdt<span   class="emphasis"><em>MY-PHONE-NUMBER</em></span>
TIMEOUT 60  CONNECT ""
TIMEOUT 10  ogin:--ogin: <span   class="emphasis"><em>MY-LOGIN-ID</em></span>
            ssword: \q<span   class="emphasis"><em>MY-PASSWORD</em></span>
            (vt100) vt102
            <span   class="emphasis"><em>MY-SHELL-PROMPT</em></span>% slirp
</pre><p>The script uses several features of chat which make it easier
to perform automated logins:</p><div class="itemizedlist"><ul type="disc"><li><p>The <b  >ABORT</b> keyword, which aborts
the script at any time if any of the strings listed is
received.</p></li><li><p>The <b  >TIMEOUT</b> keyword, which
adjusts the chat timeout in seconds, so you don't have to wait for
45 seconds to find out that your modem is not responding.</p></li><li><p>The &ldquo;empty&rdquo; send string surrounded by quotes,
<b  >""</b>, (chat accepts single or double quotes),
which simply sends a carriage return.</p></li><li><p>The &ldquo;sub-expect&rdquo; sequences using hyphens (if the
first string is not received, chat sends the string following the
first hyphen, followed by a carriage return, and then expects the
string following the second hyphen; if the first string is
received, the rest of the hyphenated sequence is skipped)</p></li><li><p>The <b  >\q</b> (&ldquo;quiet&rdquo;) escape
sequence, which keeps the string from being logged, making sure
that your remote password does not appear in the system
logs.</p></li></ul></div><p>If we can make it easier to log into a remote host using
SLiRP, pppd, and chat, we ought to be able to make it easier to log
out as well. The ppp-off script (see <span   class="bold"><b>Figure
2</b></span>) does some of this, but not quite enough. pppd does
have a <b  >disconnect</b> option, but since you may wish
to use pppd to connect to multiple Internet service providers, one
or more of which may not use SLiRP, there's a more flexible
solution: instead of trying to use pppd to hang up the phone (which
is not its job), we'll use chat to exit SLiRP and hang up the phone
after pppd has disconnected the PPP link.</p><p>Figure 6. <a href="1174f6.html" target="_self">The remote-slirp-off
script</a></p><p><span   class="bold"><b>Figure 6</b></span> contains a shell
script called remote-slirp-off, which does just that. This shell
script shows chat scripts included as arguments to chat instead of
read from a script file. Note the use of double-backslashes for
chat escape sequences&mdash;if they weren't doubled, the shell would
remove them, and the characters which follow would simply appear to
be part of the send string. The <b  >\d</b> escape delays
for one second, while the <b  >\p</b> escape delays for a
tenth of a second. <b  >\c</b> indicates not to send a
carriage return after the send string in which it appears. The
script also provides a verbose option <b  >-v</b> to log
the chats to the system logs for debugging. Like chat,
remote-slirp-off expects the modem to be on both standard input and
standard output.</p><p>Armed with the &ldquo;glue&rdquo; of the foregoing scripts, including
your custom-made chat script for dialing into your Internet
account, you can start a PPP connection between pppd and SLiRP
using the simple command:</p><pre     class="programlisting">
ppp-on <span   class="emphasis"><em>name-of-chat-script</em></span>
</pre><p>and you can stop the connection using the simple command
sequence:</p><pre     class="programlisting">
ppp-off
remote-slirp-ff &lt;/dev/modem &gt;/dev/modem
</pre><p>If you simply must have simple, one-word commands to perform
these actions, you can easily put them into an alias, shell
function, or yet another shell script.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1147580.0x17cb8e8"></a>Epilogue</h2></div></div><p>In addition to the features and capabilities I have discussed
here, SLiRP has more sophisticated facilities for load-balancing
and restarting interrupted connections, as well as utility programs
for starting a remote shell without having to log in via telnet or
for sending a file over a SLiRP connection without having to use
FTP; however, none of these are necessary for a working Internet
connection. Check out the documentation accompanying SLiRP and the
SLiRP WWW pages for more information about those extras.</p><p>Be careful not to get too addicted to a SLiRP connection.
Remember: it's like having a telephone, only more expensive.</p></div></div>
<div class="authorblurb"><p>
      <span   class="bold"><b>Jim Knoble</b></span>
      (<a href="mailto:jmknoble@mercury.interpath.com">jmknoble@mercury.interpath.com</a>)
      has been friends with computers since the days of homebuilt
      Heathkit Z80 machines running CP/M and has been learning about
      Linux since late 1992. When Jim's not at work, he enjoys
      international folk dancing, singing in his church choir, brushing
      up on his German, cycling, baking bread, hiking, and writing
      poetry. He lives in Chapel Hill, North Carolina, home to many fine
      Linux products and personalities. Jim hopes that one day the world
      will experience lasting peace.
    </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../024/toc024.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>