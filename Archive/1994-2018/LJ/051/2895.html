<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>ROOT: An Object-Oriented Data Analysis Framework</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    A report on a data analysis tool currently being developed&#10;    at CERN.&#10;    "><meta name="keywords" content="lab, science, analysis"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xb36580.0xc2dab0"></a>ROOT: An Object-Oriented Data Analysis Framework</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author">Fons Rademakers</h3></div><div class="author"><h3 class="author">Rene Brun</h3></div><div class="issuemoyr">Issue #51, July 1998</div></div></div><div><p>
    A report on a data analysis tool currently being developed
    at CERN.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc2e8c8"></a></h2></div></div><p>ROOT is a system for large scale data
analysis and data mining. It is being developed for the analysis of
Particle Physics data, but can be equally well used in other fields
where large amounts of data need to be processed.
</p><p>After many years of experience in developing interactive data
analysis systems like PAW and PIAF (see Resources), we realized
that the growth and maintainability of these products, written in
FORTRAN and using 20-year-old libraries, had reached its limits.
Although still popular in the physics community, these systems do
not scale up to the challenges offered by the next generation
particle accelerator, the Large Hadron Collider (LHC), currently
under construction at CERN, in Geneva, Switzerland. The expected
amount of data produced by the LHC will be on the order of several
petabytes (1PB = 1,000,000GB) per year. This is two to three orders
of magnitude more than what is being produced by the current
generation of accelerators.</p><p>Therefore, in early 1995, Rene Brun and I started developing
a system, intending to overcome the deficiencies of these previous
programs. One of the first decisions we made was to follow the
object-oriented analysis and design methodology and to use C++ as
our implementation language. Although all of our previous
programming experience was in FORTRAN, we soon realized the power
of OO and C++, and after some initial &ldquo;throw-away&rdquo; prototyping,
the ROOT system began to take shape.</p><p>In November 1995, we gave the first public presentation of
ROOT at CERN and, at the same time, version 0.5 was released via
the Web. By then, Nenad Buncic and Valery Fine had joined our
team.</p><p>Since the initial release, there has been a constantly
increasing number of users. In response to comments and feedback,
we've been regularly releasing new versions containing bug fixes
and new features. In January 1997, version 1.0 was released and in
March 1998 version 2.0. Since the release of version 1.0, more than
9,300 copies of the ROOT binaries have been downloaded from our web
site, about 500 people have registered as ROOT users, and the web
site gets up to 100,000 hits per month.</p><p>ROOT is currently being used in many different fields such as
physics, astronomy, biology, genetics, finance, insurance,
pharmaceuticals, etc.</p><p>The source and binaries for many different platforms can be
downloaded from the ROOT web site (http://root.cern.ch/). The
current version can be used and distributed freely as long as
proper credit is given and copyright notices are maintained. For
commercial use, the authors would like to be notified.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc2ebe0"></a>Main Features of ROOT</h2></div></div><p>The main components of the ROOT system are:</p><div class="itemizedlist"><ul type="disc"><li><p>A hierarchical object-oriented database (machine
independent, highly compressed, supporting schema evolution and
object versioning)</p></li><li><p>A C++ interpreter</p></li><li><p>Advanced statistical analysis tools (classes for
multi-dimensional histogramming, fitting and minimization)</p></li><li><p>Visualization tools (classes for 2D and 3D graphics
including an OpenGL interface)</p></li><li><p>A rich set of container classes that are fully I/O
aware (list, sorted list, map, btree, hashtable, object array,
etc.)</p></li><li><p>An extensive set of GUI classes (windows, buttons,
combo-box, tabs, menus, item lists, icon box, tool bar, status bar
and many others)</p></li><li><p>An automatic HTML documentation generation
facility</p></li><li><p>Run-time object inspection capabilities</p></li><li><p>Client/server networking classes</p></li><li><p>Shared memory support</p></li><li><p>Remote database access, either via a special daemon
or via the Apache web server</p></li><li><p>Ported to all known UNIX and Linux systems and also
to Windows 95 and NT</p></li></ul></div><p>The complete system consists of about 450,000 lines of C++
and 80,000 lines of C code. There are about 310 classes grouped in
24 different frameworks, each class represented by its own shared
library.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc2f5d8"></a>The CINT C/C++ Interpreter</h2></div></div><p>One of the key components of the ROOT system is the CINT
C/C++ interpreter. CINT, written by Masaharu Goto of Hewlett
Packard Japan, covers 95% of ANSI C and about 85% of C++. Template
support is being worked on, and exceptions are still missing. CINT
is complete enough to be able to interpret its own 70,000 lines of
C and to let the interpreted interpreter interpret a small
program.</p><p>The advantage of a C/C++ interpreter is that it allows for
fast prototyping, since it eliminates the typical time consuming
edit/compile/link cycle. Once a script or program is finished, you
can compile it with a standard C/C++ compiler
(<span   class="bold"><b>gcc</b></span>) to machine code and enjoy
full machine performance. Since CINT is very efficient (for
example, for/while loops are byte-code compiled on the fly), it is
quite possible to run small programs in the interpreter. In most
cases, CINT outperforms other interpreters like Perl and
Python.</p><p>Existing C and C++ libraries can easily be interfaced to the
interpreter. This is done by generating a dictionary from the
function and class definitions. The dictionary provides CINT with
all necessary information to be able to call functions, create
objects and call member functions. A dictionary is easily generated
by the program <span   class="bold"><b>rootcint</b></span> that uses
the library header files as input and produces a C++ file
containing the dictionary as output. You compile the dictionary and
link it with the library code into a single shared library. At
run-time, you dynamically link the shared library, and then you can
call the library code via the interpreter. This can be a very
convenient way to quickly test some specific library functions.
Instead of having to write a small test program, you just call the
functions directly from the interpreter prompt.</p><p>The CINT interpreter is fully embedded into the ROOT system.
It allows the ROOT command line, scripting and programming
languages to be identical. The embedded interpreter dictionaries
provide the necessary information to automatically create GUI
elements like context pop-up menus unique for each class and for
the generation of fully hyperized HTML class documentation.
Furthermore, the dictionary information provides complete run-time
type information (RTTI) and run-time object introspection
capabilities.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc2f898"></a>Installation</h2></div></div><p>The binaries and sources of ROOT can be downloaded from
http://root.cern.ch/root/Version200.html. After downloading,
uncompress and unarchive (using
<span   class="bold"><b>tar</b></span>) the file
root_v2.00.Linux.2.0.33.tar.gz in your home directory (or in a
system-wide location such as /opt). This procedure will produce the
directory /root. This directory contains the following files and
subdirectories:</p><div class="itemizedlist"><ul type="disc"><li><p>AA_README: read this file before starting</p></li><li><p>bin: directory containing executables</p></li><li><p>include: directory containing the ROOT header
files</p></li><li><p>lib: directory containing the ROOT libraries (in
shared library format)</p></li><li><p>macros: directory containing system macros (e.g.,
GL.C to load OpenGL libs)</p></li><li><p>icons: directory containing xpm icons</p></li><li><p>test: some ROOT test programs</p></li><li><p>tutorials: example macros that can be executed by
the bin/root module</p></li></ul></div><p>Before using the system, you must set the environment
variable ROOTSYS to the root directory, e.g., export
ROOTSYS=/home/rdm/root, and you must add $ROOTSYS/bin to your path.
Once done, you are all set to start rooting.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc268b8"></a>First Interactive Session</h2></div></div><p>In this first session, start the ROOT interactive program
<span   class="bold"><b>root</b></span>. This program gives access
via a command-line prompt to all available ROOT classes. By typing
C++ statements at the prompt, you can create objects, call
functions, execute scripts, etc. Go to the directory
$ROOTSYS/tutorials and type:</p><pre     class="programlisting">
bash$ root
root [0] 1+sqrt(9)
(double)4.000000000000e+00
root [1] for (int i = 0; i &lt; 5; i++)&lt;\n&gt;
printf("Hello %d\n", i)
Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
root [2] .q
</pre><p>As you can see, if you know C or C++, you can use ROOT. No
new command-line or scripting language to learn. To exit, use
<b  >.q</b>, which is one of the few &ldquo;raw&rdquo; interpreter
commands. The dot is the interpreter escape symbol. There are also
some dot commands to debug scripts (step, step over, set
breakpoint, etc.) or to load and execute scripts.
</p><p>Let's now try something more interesting. Again, start
root:</p><pre     class="programlisting">
bash$ root
root [0] TF1 f1("func1", "sin(x)/x", 0, 10)
root [1] f1.Draw()
root [2] f1.Dump()
root [3] f1.Inspect()
 // Select File/Close Canvas
root [4] .q
</pre><p><a href="2895f1.jpg" target="_self"><span   class="bold"><b>Figure 1.
Output of f1.Draw()</b></span></a>
</p><p>Here you create an object of class TF1, a one-dimensional
function. In the constructor, you specify a name for the object
(which is used if the object is stored in a database), the function
and the upper and lower value of x. After having created the
function object you can, for example, draw the object by executing
the <span   class="bold"><b>TF1::Draw</b></span> member function.
Figure 1 shows how this function looks. Now, move the mouse over
the picture and see how the shape of the cursor changes whenever
you cross an object. At any point, you can press the right mouse
button to pop-up a context menu showing the available member
functions for the current object. For example, move the cursor over
the function so that it becomes a pointing finger, and then press
the right button. The context menu shows the class and name of the
object. Select item <b  >SetRange</b> and put
<b  >-10, 10</b> in the dialog box fields. (This is
equivalent to executing the member function
<b  >f1.SetRange(-10,10)</b> from the command-line
prompt, followed by <b  >f1.Draw()</b>.) Using the
<span   class="bold"><b>Dump</b></span> member function (that each
ROOT class inherits from the basic ROOT class TObject), you can see
the complete state of the current object in memory. The
<span   class="bold"><b>Inspect</b></span> function shows the same
information in a graphics window.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc26f98"></a>Histogramming and Fitting</h2></div></div><p>Let's start root again and run the following two
macros:</p><pre     class="programlisting">
bash$ root
root [0] .x hsimple.C
root [1] .x ntuple1.C
 // interact with the pictures in the canvas
root [2] .q
</pre><p>Note: if the above doesn't work, make sure you are in the
tutorials directory.
</p><p><a href="2895f2.jpg" target="_self"><span   class="bold"><b>Figure 2.
Output of ntuple1.C</b></span></a></p><p>Macro hsimple.C (see $ROOTSYS/tutorials/hsimple.C) creates
some 1D and 2D histograms and an Ntuple object. (An Ntuple is a
collection of tuples; a tuple is a set of numbers.) The histograms
and Ntuple are filled with random numbers by executing a loop
25,000 times. During the filling, the 1D histogram is drawn in a
canvas and updated each 1,000 fills. At the end of the macro, the
histogram and Ntuple objects are stored in a ROOT database.</p><p>The ntuple1.C macro uses the database created in the previous
macro. It creates a canvas object and four graphics pads. In each
of the four pads, a distribution of different Ntuple quantities is
drawn. Typically, data analysis is done by drawing in a histogram
with one of the tuple quantities when some of the other quantities
pass a certain condition. For example, our Ntuple contains the
quantities px, py, pz, random and i. The command:</p><pre     class="programlisting">
ntuple-&gt;Draw("px", "pz &lt; 1")
</pre><p>will fill a histogram containing the distribution of the px
values for all tuples for which <b  >pz &lt; 1</b>.
Substitute for the abstract quantities used in this example
quantities such as name, sex, age, length, etc., and you can easily
understand that Ntuples can be used in many different ways. An
Ntuple of 25,000 tuples is quite small. In typical physics analysis
situations, Ntuples can contain many millions of tuples. Besides
the simple Ntuple, the ROOT system also provides a Tree. A Tree is
an Ntuple generalized to complete objects. That is, instead of sets
of tuples, a Tree can store sets of objects. The object attributes
can be analyzed in the same way as the tuple quantities. For more
information on Trees, see the ROOT HOWTOs at
http://root.cern.ch/root/Howto.html.
</p><p>During data analysis, you often need to test the data with a
hypothesis. A hypothesis is a theoretical/empirical function that
describes a model. To see if the data matches the model, you use
minimization techniques to tune the model parameters so that the
function best matches the data; this is called fitting. ROOT allows
you to fit standard functions like polynomials, Gaussian
exponentials or custom defined functions to your data. In the top
right pad in Figure 2, the data has been fit with a polynomial of
degree two (red curve). This was done by calling the
<span   class="bold"><b>Fit</b></span> member function of the
histogram object:</p><pre     class="programlisting">
hprofs-&gt;Fit("pol2")
</pre><p>Moving the cursor over the canvas allows you to interact with
the different objects. For example, the 3D plot in the lower-right
corner can be rotated by clicking the left mouse button and moving
the cursor.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc27570"></a>The GUI Classes and Object Browser</h2></div></div><p>Embedded in the ROOT system is an extensive set of GUI
classes. The GUI classes provide a full OO-GUI framework as opposed
to a simple wrapper around a GUI such as Motif. All GUI elements do
their drawing via the TGXW low-level graphics abstract base class.
Depending on the platform on which you run ROOT, the concrete
graphics class (inheriting from TGXW) is either TGX11 or TGWin32.
All GUI widgets are created from &ldquo;first principles&rdquo;, i.e., they
use only routines like <span   class="bold"><b>DrawLine</b></span>,
<span   class="bold"><b>FillRectangle</b></span>,
<span   class="bold"><b>CopyPixmap</b></span>, etc., and therefore,
the TGX11 implementation needs only the X11 and Xpm libraries. The
advantage of the abstract base class approach is that porting the
GUI classes to a new, non X11/Win32, platform requires only the
implementation of an appropriate version of TGXW (and of TSystem
for the OS interface).</p><p>All GUI classes are fully scriptable and accessible via the
interpreter. This allows for fast prototyping of widget
layouts.</p><p>The GUI classes are based on the XClass'95 library written by
David Barth and Hector Peraza. The widgets have the well-known
Windows 95 look and feel. For more information on XClass'95, see
ftp://mitac11.uia.ac.be/html-test/xclass.html.</p><p><a href="2895f3.jpg" target="_self"><span   class="bold"><b>Figure 3. ROOT
Object Browser</b></span></a></p><p>Using the ROOT Object Browser, all objects in the ROOT system
can be browsed and inspected. To create a browser object,
type:</p><pre     class="programlisting">
root [0] TBrowser *b = new TBrowser
</pre><p>The browser, as shown in Figure 3, displays in the left pane
the browse-able ROOT collections and in the right pane the objects
in the selected collection. Double clicking on an object will
execute a default action associated with the class of the object.
Double clicking on a histogram object will draw the histogram.
Double clicking on an Ntuple quantity will produce a histogram
showing the distribution of the quantity by looping over all tuples
in the Ntuple. Right clicking on an object will bring up a context
menu (just as in a canvas).
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc27a40"></a>Integrating Your Own Classes into ROOT</h2></div></div><p>In this section, I'll give a step-by-step method for
integrating your own classes into ROOT. Once integrated, you can
save instances of your class in a ROOT database, inspect objects at
run-time, create and manipulate objects via the interpreter,
generate HTML documentation, etc. A very simple class describing
some person attributes is shown in <a href="2895l1.html" target="_self">Listing
1</a>. The Person implementation file Person.cxx is shown in
<a href="2895l2.html" target="_self">Listing 2.</a></p><p>The macros <span   class="bold"><b>ClassDef</b></span> and
<span   class="bold"><b>ClassImp</b></span> provide some member
functions that allow a class to access its interpreter dictionary
information. Inheritance from the ROOT basic object, TObject,
provides the interface to the database and inspection
services.</p><p>Now run the <span   class="bold"><b>rootcint</b></span> program
to create a dictionary, including the special I/O streamer and
inspection methods for class Person:</p><pre     class="programlisting">
bash$ rootcint -f dict.cxx -c Person.h
</pre><p>Next, compile and link the source of the class and the
dictionary into a single shared library:
<pre     class="programlisting">
bash$ g++ -fPIC -I$ROOTSYS/include -c dict.cxx
bash$ g++ -fPIC -I$ROOTSYS/include -c Person.cxx
bash$ g++ -shared -o Person.so Person.o dict.o
</pre>


Now start the ROOT interactive program and see how we can create
and manipulate objects of class Person using the CINT C++
interpreter:
<pre     class="programlisting">
bash$ root
root [0] gSystem-&gt;Load("Person.so")
root [1] Person rdm(37, 181.0)
root [2] rdm.get_age()
(int)37
root [3] rdm.get_height()
(float)1.810000000000e+02
root [4] TFile db("test.root","new")
root [5] rdm.Write("rdm") // Write is inherited from the
TObject class
root [6] db.ls()
TFile** test.root
 TFile* test.root
 KEY: Person rdm;1
root [7] .q
</pre>


Here, the key statement was the command to dynamically load the
shared library containing the code of your class and the class
dictionary.
</p><p>In the next session, we access the
<span   class="bold"><b>rdm</b></span> object we just stored on the
database test.root:</p><pre     class="programlisting">
bash$ root
root [0] gSystem-&gt;Load("Person.so")
root [1] TFile db("test.root")
root [2] rdm-&gt;get_age()
(int)37
root [3] rdm-&gt;Dump() // Dump is inherited from the TObject
class"
age     37      age of person
height  181     height of person
fUniqueID       0       object unique identifier
fBits   50331648        bit field status word
root [4] .class Person
[follows listing of full dictionary of class Person]
root [5] .q
</pre><p>A C++ macro that creates and stores 1000 persons in a
database is shown in <a href="2895l3.html" target="_self">Listing 3.</a> To
execute this macro, do the following:</p><pre     class="programlisting">
bash$ root
root [0] .x fill.C
root [1] .q
</pre><p>This method of storing objects would be used only for several
thousands of objects. The special Tree object containers should be
used to store many millions of objects of the same class.
</p><p><a href="2895l4.html" target="_self">Listing 4</a> is a C++ macro
that queries the database and prints all persons in a certain age
bracket. To execute this macro, do the following:</p><pre     class="programlisting">
bash$ root
root [0] .x find.C(77,80)
age = 77, height = 10077.000000
age = 78, height = 10078.000000
age = 79, height = 10079.000000
age = 80, height = 10080.000000
NULL
root [1] find(888,895)
age = 888, height = 10888.000000
age = 889, height = 10889.000000
age = 890, height = 10890.000000
age = 891, height = 10891.000000
age = 892, height = 10892.000000
age = 893, height = 10893.000000
age = 894, height = 10894.000000
age = 895, height = 10895.000000
root [2] .q
</pre><p>With Person objects stored in a Tree, this kind of analysis
can be done in a single command.
</p><p>Finally, a small C++ macro that prints all methods defined in
class Person using the information stored in the dictionary is
shown in <a href="2895l5.html" target="_self">Listing 5.</a> To execute
this macro, type:</p><pre     class="programlisting">
bash$ root
root [0] .x method.C
class Person Person(int a = 0, float h = 0)
int get_age()
float get_height()
void set_age(int a)
void set_height(float h)
const char* DeclFileName()
int DeclFileLine()
const char* ImplFileName()
int ImplFileLine()
Version_t Class_Version()
class TClass* Class()
void Dictionary()
class TClass* IsA()
void ShowMembers(class TMemberInspector&amp; insp, char* parent)
void Streamer(class TBuffer&amp; b)
class Person Person(class Person&amp;)
void ~Person()
root [1] .q
</pre><p>The above examples prove the functionality that can be
obtained when you integrate, with a few simple steps, your classes
into the ROOT framework.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc28438"></a>Linux an Increasing Force in Scientific
Computing</h2></div></div><p>Analyzing the FTP logs of the more than 9,300 downloads of
the ROOT binaries reveals the popularity of the different computing
platforms in the mainly scientific community. Figure 4 shows the
number of ROOT binaries downloaded per platform.</p><p><a href="2895f4.jpg" target="_self"><span   class="bold"><b>Figure 4. ROOT
Download Statistics</b></span></a></p><p>Linux is the clear leader, followed by the Microsoft
platforms (Windows 95 and NT together equal Linux). The results for
the other UNIX machines should probably be corrected a bit, since
many machines are multi-user machines where a single download by a
system manager will cover more than one user. Linux and Windows are
typical single-user environments.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xb36580.0xc286a0"></a>Summary</h2></div></div><p>In this article I've given an overview of some of the main
features of the ROOT data-handling system. However, many aspects
and features of the system remain uncovered, such as the
client/server classes (the TSocket, TServerSocket, TMonitor and
TMessage classes), how to automatically generate HTML documentation
(using the THtml class), remote database access (via the rootd
daemon), advanced 3D graphics, etc. More on these topics can be
found on the ROOT web site.</p><p><a href="2895s1.html" target="_self">Resources</a></p><p><a href="2895s2.html" target="_self">Acknowledgements</a></p></div></div>
<div class="authorblurb"><p>
          <div       class="mediaobject"><img src="2895aa.jpg"></div>
          <span   class="bold"><b>Fons Rademakers</b></span> received a Ph.D. in particle
          physics from the University of Amsterdam. Since 1988 he has been
          working at CERN developing database, data analysis and graphics
          software. Fons started using Linux in 1993 and has been advocating
          it ever since. Besides developing ROOT, he is building several
          Linux PC farms for physics data processing (a joint project with
          Hewlett Packard). When not programming, he races go-carts and rides
          his trail bike. He can be reached via e-mail at
          <a href="mailto:Fons.Rademakers@cern.ch">Fons.Rademakers@cern.ch</a>.
        </p><p>
          <div       class="mediaobject"><img src="2895aa2.jpg"></div>
          <span   class="bold"><b>Rene Brun</b></span> received a Ph.D. from the University of
          Clermont-Ferrand, France. He joined CERN in 1973. Rene made major
          contributions to the CERN Program Library, creating and
          coordinating the development of major software projects such as
          GEANT and PAW. In 1989, he received the IEEE/CANPS award for his
          contribution to a general detector simulation framework for nuclear
          and particle physics. He can be reached via e-mail at
          <a href="mailto:Rene.Brun@cern.ch">Rene.Brun@cern.ch</a>.
        </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../051/toc051.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>