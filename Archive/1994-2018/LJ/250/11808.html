<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
JavaScript All the Way Down
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Use JavaScript for server and client programming.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1f66580.0x205dac0"></a>
JavaScript All the Way Down
</h1></div><div><div class="author"><h3 class="author">
Federico
 
Kereki
</h3></div><div class="issuemoyr">Issue #250, February 2015</div></div><div><p>
Use JavaScript for server and client programming.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x205e2a8"></a></h2></div></div><p>
There is a well known story about a scientist who gave a talk about the
Earth and its place in the solar system. At the end of the talk, a woman
refuted him with &ldquo;That's rubbish; the Earth is really like a flat dish,
supported on the back of a turtle.&rdquo; The scientist smiled and asked back
&ldquo;But what's the turtle standing on?&rdquo;, to which the woman, realizing
the logical trap, answered, &ldquo;It's very simple: it's turtles all the
way down!&rdquo; No matter the verity of the anecdote, the identity of the
scientist (Bertrand Russell or William James are sometimes mentioned),
or even if they were turtles or tortoises, today we may apply a similar
solution to Web development, with &ldquo;JavaScript all the way down&rdquo;.
</p><p>
If you are going to develop a Web site, for client-side development, you could
opt for Java applets, ActiveX controls, Adobe Flash animations and,
of course, plain JavaScript. On the other hand, for server-side coding,
you could go with C# (.Net), Java, Perl, PHP and more, running on
servers, such as Apache, Internet Information Server, Nginx, Tomcat and
the like. Currently, JavaScript allows you to do away with most of this
and use a single programming language, both on the client and the server
sides, and with even a JavaScript-based server. This way of working 
even has produced a totally JavaScript-oriented acronym along the lines of
the old LAMP (Linux+Apache+MySQL+PHP) one: MEAN, which stands for MongoDB
(a NoSQL database you can access with JavaScript), Express (a Node.js
module to structure your server-side code), Angular.JS (Google's Web
development framework for client-side code) and Node.js.
</p><p>
In this article, I cover several JavaScript tools for writing,
testing and deploying Web applications, so you can consider whether
you want to give a twirl to a &ldquo;JavaScript all the way down&rdquo; Web stack.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x205e6c8"></a></h2></div></div><div class="sidebar"><p class="title"><b>
What's in a Name?</b></p><p>
JavaScript originally was developed at Netscape in 1995, first under
the name Mocha, and then as LiveScript. Soon (after Netscape and Sun got
together; nowadays, it's the Mozilla Foundation that manages the language)
it was renamed JavaScript to ride the popularity wave, despite having
nothing to do with Java. In 1997, it became an industry standard under a
fourth name, ECMAScript. The most common current version of JavaScript is
5.1, dated June 2011, and version 6 is on its way. (However, if you want
to use the more modern features, but your browser won't support them, take
a look at the Traceur compiler, which will back-compile version 6 code
to version 5 level.) 
</p><p>
Some companies produced supersets of the language,
such as Microsoft, which developed JScript (renamed to avoid legal problems)
and Adobe, which created ActionScript for use with Flash. 
</p><p>
There are several
other derivative languages (which actually compile to JavaScript for
execution), such as the more concise CoffeeScript, Microsoft's TypeScript
or Google's most recent AtScript (JavaScript plus Annotations), which
was developed for the Angular.JS project. The asm.js project even uses a
JavaScript subset as a target language for efficient compilers for other
languages. Those are many different names for a single concept! 
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x205e988"></a>
Why JavaScript?</h2></div></div><p>
Although stacks like LAMP or its Java, Ruby or .Net peers do power
many Web applications today, using a single language both for client-
and server-side development has several advantages, and companies 
like Groupon, LinkedIn, Netflix, PayPal and Walmart, among many more,
are proof of it. 
</p><p>
Modern Web development is split between client-side and
server-side (or front-end and back-end) coding, and striving for the
best balance is more easily attained if your developers can work both
sides with the same ease. Of course, plenty of developers
are familiar with all the languages needed for both sides of coding, but
in any case, it's quite probable that they will be more productive at
one end or the other. 
</p><p>
Many tools are available for JavaScript (building,
testing, deploying and more), and you'll be able to use them for all
components in your system (Figure 1). So, by going with the same
single set of tools, your experienced JavaScript developers will be able
to play both sides, and you'll have fewer problems getting the needed
programmers for your company.
</p><div       class="mediaobject"><a href="11808f1.large.jpg"><img src="11808f1.jpg"></a><div class="caption"><p>
Figure 1. JavaScript can be used everywhere, on the client and the server
sides.
</p></div></div><p>
Of course, being able to use a single language isn't the single key
point. In the &ldquo;old days&rdquo; (just a few years ago!), JavaScript lived
exclusively in browsers to read and interpret JavaScript source
code. (Okay, if you want to be precise, that's not exactly true; Netscape
Enterprise Server ran server-side JavaScript code, but it wasn't widely
adopted.) About five years ago, when Firefox and Chrome started competing
seriously with (by then) the most popular Internet Explorer, new JavaScript
engines were developed, separated from the layout engines that actually
drew the HTML pages seen on browsers. Given the rising popularity of
AJAX-based applications, which required more processing power on the
client side, a competition to provide the fastest JavaScript started,
and it hasn't stopped yet. With the higher performance achieved,
it became possible to use JavaScript more widely (Table 1).
</p><div class="table"><a name="N0x1f66580.0x205eda8"></a><p class="title"><b>
Table 1. The Current Browsers and Their JavaScript Engines</b></p><table     summary="&#10;Table 1. The Current Browsers and Their JavaScript Engines11808t1.qrk" border="1"><colgroup><col><col></colgroup><thead><tr><th>Browser</th><th>JavaScript Engine</th></tr></thead><tbody><tr><td>Chrome</td><td>V8</td></tr><tr><td>Firefox</td><td>SpiderMonkey</td></tr><tr><td>Opera</td><td>Carakan</td></tr><tr><td>Safari</td><td>Nitro</td></tr></tbody></table></div><p>
Some of these engines apply advanced techniques to get the most speed
and power. For example, V8 compiles JavaScript to native machine code
before executing it (this is called JIT, Just In Time compilation, and
it's done on the run instead of pre-translating the whole program as
is traditional with compilers) and also applies several optimization and
caching techniques for even higher throughput. SpiderMonkey includes
IonMonkey, which also is capable of compiling JavaScript code to object
code, although working in a more traditional way. So, accepting that modern
JavaScript engines have enough power to do whatever you may need, let's
now start a review of the Web stack with a server that wouldn't have
existed if it weren't for that high-level language performance: Node.js.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x205f538"></a>
Node.js: a New Kind of Server</h2></div></div><p>
Node.js (or plain Node, as it's usually called) is a Web server,
mainly written itself in JavaScript, which uses that language for all
scripting. It originally was developed to simplify developing real-time
Web sites with push capabilities&mdash;so instead of all communications being
client-originated, the server might start a connection with a client
by itself. Node can work with lots of live connections, because it's
very lightweight in terms of requirements. There are two key concepts to
Node: it runs a single process (instead of many), and all I/O
(database queries, file accesses and so on) is implemented in a non-blocking,
asynchronous way.
</p><p>
Let's go a little deeper and further examine the main difference between
Node and more traditional servers like Apache. Whenever Apache receives
a request, it starts a new, separate thread (process) that uses RAM
of its own and CPU processing power. (If too many threads are running,
the request may have to wait a bit longer until it can be started.) When
the thread produces its answer, the thread is done. The maximum number of
possible threads depends on the average RAM requirements for a process;
it might be a few thousand at the same time, although numbers vary depending
on server size (Figure 2).
</p><div       class="mediaobject"><a href="11808f2.large.jpg"><img src="11808f2.jpg"></a><div class="caption"><p>
Figure 2. Apache and traditional Web servers run a separate thread for each
request.
</p></div></div><p>
On the other hand, Node runs a single thread. Whenever a request
is received, it is processed as soon as it's possible, and it will run
continuously until some I/O is required. Then, while the code waits for
the I/O results to be available, Node will be able to process other
waiting requests (Figure 3). Because all requests are served by
a single process, the possible number of running requests rises, and
there have been experiments with more than one million concurrent
connections&mdash;not shabby at all! This shows that an ideal use case for Node is having
server processes that are light in CPU processing, but high on
I/O.
This will allow more requests to run at the same time; CPU-intensive
server processes would block all other waiting requests and produce a
high drop in output.
</p><div       class="mediaobject"><a href="11808f3.large.jpg"><img src="11808f3.jpg"></a><div class="caption"><p>
Figure 3. Node runs a single thread for all requests.
</p></div></div><p>
A great asset of Node is that there are many available modules (an
estimate ran in the thousands) that help you get to production more
quickly. Though I obviously can't list all of them, you probably
should consider some of the modules listed in Table 2.
</p><div class="table"><a name="N0x1f66580.0x205fb10"></a><p class="title"><b>
Table 2. Some widely used Node.js modules that will help your development and
operation.</b></p><table     summary="&#10;Table 2. Some widely used Node.js modules that will help your development and&#10;operation.11808t2.qrk" border="1"><colgroup><col><col></colgroup><thead><tr><th>
Module</th><th>Description</th></tr></thead><tbody><tr><td>async</td><td>Simplifies asynchronous work, a possible alternative to promises.</td></tr><tr><td>cluster</td><td>Improves concurrency in multicore systems by forking worker processes.
(For further scalability, you also could set up a reverse proxy and run
several Node.js instances, but that goes beyond the objective of this
article.)</td></tr><tr><td>
connect</td><td>Works with &ldquo;middleware&rdquo; for common tasks, such as error handling,
logging, serving static files and more.</td></tr><tr><td>
ejs, handlebars or jade, EJS</td><td>Templating engines.</td></tr><tr><td>
express</td><td>A minimal Web framework&mdash;the E in MEAN.</td></tr><tr><td>
forever</td><td>A command-line tool that will keep your server up, restarting if needed
after a crash or other problem.</td></tr><tr><td>
mongoose, cradle, sequelize</td><td>Database ORM, for MongoDB, CouchDB and for relational databases, such as
MySQL and others.</td></tr><tr><td>
passport</td><td>Authentication middleware, which can work with OAuth providers, such as
Facebook, Twitter, Google and more.</td></tr><tr><td>
request or superagent</td><td>HTTP clients, quite useful for interacting with RESTful APIs.</td></tr><tr><td>
underscore or lodash</td><td>Tools for functional programming and for extending the JavaScript core
objects.</td></tr></tbody></table></div><p>
Of course, there are some caveats when using Node.js. An obvious one
is that no process should do heavy computations, which would
&ldquo;choke&rdquo;
Node's single processing thread. If such a process is needed,
it should be done by an external process (you might want to consider
using a message queue for this) so as not to block other requests. Also,
care must be taken with error processing. An unhandled exception might
cause the whole server to crash eventually, which wouldn't bode well
for the server as a whole. On the other hand, having a large community
of users and plenty of fully available, production-level, tested code
already on hand can save you quite a bit of development time and let
you set up a modern, fast server environment.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x2057210"></a>
Planning and Organizing Your Application</h2></div></div><p>
When starting out with a new project, you could set up your code from
zero and program everything from scratch, but several
frameworks can help you with much of the work and provide
clear structure and organization to your Web application. Choosing the
right framework will have an important impact on your development time,
on your testing and on the maintainability of your site. Of course,
there is no single answer to the question &ldquo;What framework is
best?&rdquo;,
and new frameworks appear almost on a daily basis, so I'm just going
with three of the top solutions that are available today: AngularJS,
Backbone and Ember. Basically, all of these frameworks are available under
permissive licenses and give you a head start on developing modern SPA
(single page applications). For the server side, several packages (such
as Sails, to give just one example) work with all frameworks.
</p><p>
AngularJS (or Angular.JS or just plain Angular&mdash;take your pick) was
developed in 2009 by Google, and its current version is 1.3.4, dated
November 2014. The framework is based on the idea that declarative
programming is best for interfaces (and imperative programming for the
business logic), so it extends HTML with custom tag attributes that
are used to bind input and output data to a JavaScript model. In this
fashion, programmers don't have to manipulate the Web page directly,
because it is updated automatically. Angular also focuses on testing,
because the difficulty of automatic testing heavily depends upon the code
structure. Note that Angular is the A in MEAN, so there are some other
frameworks that expand on it, such as MEAN.IO or MEAN.JS.
</p><p>
Backbone is a lighter, leaner framework, dated from 2010, which uses a
RESTful JSON interface to update the server side automatically. (Fun fact:
Backbone was created by Jeremy Ashkenas, who also developed CoffeeScript;
see the &ldquo;What's in a Name?&rdquo; sidebar.) In terms of community size, it's
second only to Angular, and in code size, it's by far the smallest
one. Backbone doesn't include a templating engine of its own, but it
works fine with Underscore's templating, and given that this library
is included by default, it is a simple choice to make. It's considered
to be less &ldquo;opinionated&rdquo; than other frameworks and to have a quite
shallow learning curve, which means that you'll be able to start
working quickly. A deficiency is that Backbone lacks two-way data binding, so
you'll have to write code to update the view whenever the model changes
and vice versa. Also, you'll probably be manipulating the Web
page directly, which will make your code harder to unit test.
</p><p>
Finally, Ember probably is harder to learn than the other frameworks, but
it rewards the coder with higher performance. It favors &ldquo;convention over
configuration&rdquo;, which likely will make Ruby on Rails or Symfony users
feel right at home. It integrates easily with a RESTful server side,
using JSON for communication. Ember includes Handlebars (see Table 2)
for templating and provides two-way updates. A negative point is the
usage of <tt  >&lt;script&gt;</tt> tags for markers, in order to keep templates
up to date with the model. If you try to debug a running application,
you'll find plenty of unexpected elements!
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x2057630"></a>
Simplify and Empower Your Coding</h2></div></div><p>
It's a sure bet that your application will need to work with HTML, handle
all kinds of events and do AJAX calls to connect with the server. This should
be reasonably easy&mdash;although it might be plenty of work&mdash;but even
today, browsers do not have exactly the same features. Thus, you might
have to go overboard with specific browser-detection techniques, so
your code will adapt and work everywhere. Modern application users have
grown accustomed to working with different events (tap, double tap, long tap,
drag and drop, and more), and you should be able to include that kind of
processing in your code, possibly with appropriate animations. Finally,
connecting to a server is a must, so you'll be using AJAX functions all
the time, and it shouldn't be a painful experience.
</p><p>
The most probable candidate library to help you with all these functions
is jQuery. Arguably, it's the most popular JavaScript library in use
today, employed at more than 60% of the most visited Web sites. jQuery provides
tools for navigating your application's Web document, handles events
with ease, applies animations and uses AJAX (Listing 1). Its current
version is 2.1.1 (or 1.11.1, if you want to support older browsers),
and it weighs in at only around 32K. Some frameworks (Angular, for example)
even will use it if available.

</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x20577e8"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 1. A simple jQuery example, showing how to process events, access the
page and use AJAX.</b></p><pre     class="programlisting">
var myButtonId = "#processButton");
$(myButtonId).click(function(e) {		 // when clicked...
    $(myButtonId).attr("disabled", "disabled");	 // disable button
    $.get("my/own/services", function(data) {	 // call server service
	window.alert("This came back: " + data); // show what it returns
	$(myButtonId).removeAttr("disabled");	 // re-enable the button
    }
});
</pre></div><p>
Other somewhat less used possibilities could be Prototype (current
version 1.7.2), MooTools (version 1.5.1) or Dojo Toolkit (version
11). One of the key selling points of all these libraries is the
abstraction of the differences between browsers, so you can write your
code without worrying if it will run on such or such browser. You 
probably should take a look at all of them to find which one best fits your
programming style.
</p><p>
Also, there's one more kind of library you may want. Callbacks are
familiar to JavaScript programmers who need them for AJAX calls, but
when programming for Node, there certainly will be plenty of them! You
should be looking at &ldquo;promises&rdquo;, a way of programming that will make
callback programming more readable and save you from &ldquo;callback
hell&rdquo;&mdash;a situation in which you need a callback, and that callback also needs
a callback, which also needs one and so on, making code really hard to
follow. See Listing 2, which also shows the growing indentation that
your code will need. I'm omitting error-processing code, which would
make the example even messier!
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x2057bb0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 2. Callback hell happens when callbacks include callbacks, which
include callbacks and so on.</b></p><pre     class="programlisting">
function nurseryRhyme(...) {
  ..., function eeny(...) {
    ..., function meeny(...) {
      ..., function miny(...) {
        ..., function moe(...) {
          ...
        }
      }
    }
  }
}
</pre></div><p>
The behavior of promises is standardized through the &ldquo;Promises/A+&rdquo;
open specification. Several packages provide promises
(jQuery and Dojo already include some support for them), and in
general, they even can interact, processing each other's promises. A
promise is an object that represents the future value of an (usually
asynchronous) operation. You can process this value through the
promise <tt  >.then(...)</tt> method and handle exceptions with its
<tt  >.catch(...)</tt> method. Promises can be chained, and a promise can
produce a new promise, the value of which will be processed in the next
<tt  >.then(...)</tt>. With this style, the callback hell example of
Listing 2 would be converted into more understandable code; see Listing
3. Code, instead of being more and more indented, stays aligned to
the left. Callbacks still are being (internally) used, but your code
doesn't explicitly work with them. Error handling is also simpler;
you simply would add appropriate <tt  >.catch(...)</tt> calls.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x2057fd0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 3. Using promises produces far more legible code.</b></p><pre     class="programlisting">
nurseryRhyme(...).
  .then(function eeny(...) {...})
  .then(function meeny(...) {...})
  .then(function miny(...) {...})
  .then(function moe(...) {...});
</pre></div><p>
You also can build promises out of more promises&mdash;for example, a service
might need the results of three different callbacks before producing an
answer. In this case, you could build a new single promise out of the
three individual promises and specify that the new one will be
fulfilled only when the other three have been fulfilled. There also are other
constructs that let you fulfill a promise when a given number (possibly
just one) of &ldquo;sub-promises&rdquo; have been fulfilled. See the Resources
section for several possible libraries you might want to try.
</p><p>
I have commented on several tools you might use to write your application,
so now let's consider the final steps: building the application,
testing it and eventually deploying it for operation.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x20582e8"></a>
Testing Your Application</h2></div></div><p>
No matter whether you program on your own or as a part of a large
development group, testing your code is a basic need, and doing it in an
automated way is a must. Several frameworks can help you
with this, such as Intern, Jasmine or Mocha (see Resources). In essence,
they are really similar. You define &ldquo;suites&rdquo;, each of which runs one
or more &ldquo;test cases&rdquo;, which test that your code does some specific
function. To test results and see if they satisfy your expectations,
you write &ldquo;assertions&rdquo;, which basically are conditions that must be
satisfied (see Listing 4 for a simple example). You can run test suites
as part of the build process (which I explain below) to see if anything
was broken before attempting to deploy the newer version of your code.

</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x2058550"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 4. Suites usually include several test cases.</b></p><pre     class="programlisting">
describe("Prime numbers tests", function() {
  it("Test prime numbers", function() {
    expect(isPrime(2)).to.be.true();
    expect(isPrime(5)).to.be.true();
  });
  
  it("Test non-prime numbers", function() {
    expect(isPrime(1).to.be.false();
    expect(isPrime(4).to.be.not.true();	// just for variety!
    expect(isPrime(NaN)).to.throw(err);  
  });
});
</pre></div><p>
Tests can be written in &ldquo;fluent&rdquo; style, using many matchers (see Listing
5 for some examples). Several libraries provide different ways
to write your tests, including Chai, Unit.js, Should.js and Expect.js;
check them out to decide which one suits you best.

</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236ab38"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 5. Some examples of the many available matchers you can use to write
assertions.</b></p><pre     class="programlisting">
expect(someFunction(...)).to.be.false();  // or .true(), .null(), 
                                          // .undefined(), .empty()
expect(someFunction(...)).to.not.equal(33);  // also .above(33), 
                                             // .below(33)
expect(someFunction(...)).to.be.within(30,40);
expect(someObject(...)).to.be.an.instanceOf(someClass);
expect(someObject(...)).to.have.property("key", 22);
expect(someResult(...)).to.have.length.above(2);
expect(someString(...)).to.match(/^aRegularExpression/);
expect(failedCall(...)).to.throw(err);
</pre></div><p>
If you want to run tests that involve a browser, PhantomJS and
Zombie provide a fake Web environment, so you can run tests with greater
speed than using tools like Selenium, which would be more appropriate
for final acceptance tests.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236adf8"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 6. A sample test with Zombie (using promises, by the way) requires no
actual browser.</b></p><pre     class="programlisting">
var browser = require("zombie").create();
browser.localhost("your.own.url.com", 3000);
browser.visit("/")
  .then(function() { // when loaded, enter data and click
    return browser
      .fill("User", "fkereki")
      .fill("Password", &Acirc;&iexcl;")
      .pressButton("Log in");
  })
  .done(function() { // page loaded
    browser.assert.success();
    browser.assert.text("#greeting", "Hi, fkereki!");
  });
</pre></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236b008"></a></h2></div></div><div class="sidebar"><p class="title"><b>
A Slew of DDs!</b></p><p>
Modern agile development processes usually emphasize very short cycles,
based on writing tests for code yet unwritten, and then actually writing
the desired code, the tests being both a check that the code works as
desired and as a sort of specification in itself. This process is called
TDD (Test-Driven Development), and it usually leads to modularized and
flexible code, which also is easier to understand, because the tests
help with understanding. BDD (Behavior-Driven Development) is a process
based on TDD, which even specifies requirements in a form quite similar
to the matchers mentioned in this article. Yet another &ldquo;DD&rdquo; is ATDD
(Acceptance Test-Driven Development), which highlights the idea of writing
the (automated) acceptance tests even before programmers start coding.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236b270"></a>
Building and Deploying</h2></div></div><p>
Whenever your code is ready for deployment, you almost certainly will
have to do several repetitive tasks, and you'd better automate them. Of
course, you could go with classic tools like <tt  >make</tt> or Apache's
<tt  >ant</tt>, but keeping to the &ldquo;JavaScript all the
way down&rdquo; idea, let's look at
a pair of tools, Grunt and Gulp, which work well.
</p><p>
Grunt can be installed with <tt  >npm</tt>. Do <tt  >sudo npm install -g
grunt-cli</tt>,
but this isn't enough; you'll have to prepare a gruntfile to let it know
what it should do. Basically, you require a package.json file that
describes the packages your system requires and a Gruntfile.js file
that describes the tasks you need. Tasks may have subtasks of their own,
and you may choose to run the whole task or a specific subtask. For
each task, you will define (in JavaScript, of course) what needs to be
done (Listing 7). Running <tt  >grunt</tt> with no parameters will run
a default (if given) task or the whole gamut of tasks.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236b5e0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 7. A Sample Grunt File</b></p><pre     class="programlisting">
module.exports = function(grunt) {
  grunt.initConfig({
    concat: {
      dist: {
	  dest: 'dist/build.js',
	  src: ['src/**.js'],
      },
      options: 	{ 
	separator: ';',
	stripBanners : true,
      },
    },
    
    uglify: {
      dist: {
        files: 	{ 'dist/build.min.js': 
           &#8618;['&lt;%= concat.dist.dest %&gt;'] },
      }
    },
  });

  grunt.loadNpmTasks('grunt-contrib-concat');
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.registerTask('default', ['concat', 'uglify']);
};
</pre></div><p>
Gulp is somewhat simpler to set up (in fact, it was created to simplify
Grunt's configuration files), and it depends on what its authors call
&ldquo;code-over-configuration&rdquo;. Gulp works in &ldquo;stream&rdquo; or
&ldquo;pipeline&rdquo; fashion,
along the lines of Linux's command line, but with JavaScript
plugins. Each plugin takes one input and produces one output, which
automatically is fed to the next plugin in the queue. This is simpler
to understand and set up, and it even may be faster for tasks involving
several steps. On the other hand, being a newer project implies a smaller
community of users and fewer available plugins, although both situations
are likely to work out in the near future.
</p><p>
You can use them either from within a development environment (think
Eclipse or NetBeans, for example), from the command line or as
&ldquo;watchers&rdquo;, setting them up to monitor specific files or directories
and run certain tasks whenever changes are detected to streamline
your development process further in a completely automatic way. You can set up
things so that templates will be processed, code will be minified,
SASS or LESS styles will be converted in pure CSS, and the resulting
files will be moved to the server, wherever it is appropriate for them. Both
tools have their fans, and you should try your hand at both to decide
which you prefer.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236ba00"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Getting and Updating Packages</b></p><p>
Because modern systems depend on lots of packages (frameworks, libraries,
styles, utilities and what not), getting all of them and, even worse,
keeping them updated, can become a chore. There are two tools for this:
Node's own <tt  >npm</tt> (mainly for server-side packages, although it can
work for client-side code too) and Twitter's <tt  >bower</tt> (more geared to
the client-side parts). The former deals mainly with Node packages and
will let you keep your server updated based on a configuration file. The
latter, on the other hand, can install and update all kinds of front-end
components (that is, not only JavaScript files) your Web applications might
need also based on separate configuration metadata files. 
</p><p>
Usage for
both utilities is the same; just substitute <tt  >bower</tt> for
<tt  >npm</tt>, and
you're done. Using <tt  >npm search for.some.package</tt> can help you find a
given package. Typing <tt  >npm install some.package</tt> will install it, and adding
a <tt  >--save</tt> option will update the appropriate configuration file,
so future <tt  >npm update</tt> commands will get everything up to
date. In
a pinch, <tt  >npm</tt> also can be used as a replacement for
<tt  >bower</tt>,
although then you'll possibly want to look at <tt  >browserify</tt> to organize
your code and prepare your Web application for deployment. Give it a
look just in case. 
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236c030"></a>
Conclusion</h2></div></div><p>
Modern fast JavaScript engines, plus the availability of plenty of
specific tools to help you structure, test or deploy your systems
make it possible to create Web applications with &ldquo;JavaScript
all the way down&rdquo;, helping your developers be more productive and giving
them the possibility of working on both client and server sides with the
same tools they already are proficient with. For modern development,
you certainly should give this a thought.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x236c190"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
Keep up to date with JavaScript releases, features and more at
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_self">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>.
</p><p>
Get the Traceur compiler at
<a href="https://github.com/google/traceur-compiler" target="_self">https://github.com/google/traceur-compiler</a>. CoffeeScript
can be found at <a href="http://coffeescript.org" target="_self">coffeescript.org</a>, and TypeScript
is at <a href="http://www.typescriptlang.org" target="_self">www.typescriptlang.org</a>. You
can read a draft version of the AtScript Primer at
<a href="https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/mobilebasic" target="_self">https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/mobilebasic</a>.
Finally, for more details on asm.js, go to <a href="http://asmjs.org" target="_self">asmjs.org</a>.
</p><p>
Common client-side frameworks are AngularJS at <a href="https://angularjs.org" target="_self">https://angularjs.org</a>,
Backbone at <a href="http://backbonejs.org" target="_self">backbonejs.org</a> and Ember at <a href="http://emberjs.com" target="_self">emberjs.com</a>,
among many others. With Backbone, you also might consider Chaplin 
(<a href="http://chaplinjs.org" target="_self">chaplinjs.org</a>) or Marionette (<a href="http://marionettejs.com" target="_self">marionettejs.com</a>) for
large-scale JavaScript Web applications. MEAN.JS is at <a href="http://meanjs.org" target="_self">meanjs.org</a>,
MEAN.IO is at <a href="http://mean.io" target="_self">mean.io</a>, and Sails is at <a href="http://sailsjs.org" target="_self">sailsjs.org</a>.
</p><p>
You certainly should use libraries like jQuery (<a href="http://jquery.com" target="_self">jquery.com</a>),
MooTools (<a href="http://mootools.net" target="_self">mootools.net</a>), Dojo (<a href="http://dojotoolkit.org" target="_self">dojotoolkit.org</a>)
or Prototype (<a href="http://prototypejs.org" target="_self">prototypejs.org</a>).
</p><p>
Use &ldquo;promises&rdquo; to simplify callback work in Node; you can choose among Q 
(<a href="https://github.com/kriskowal/q" target="_self">https://github.com/kriskowal/q</a>), when (<a href="https://github.com/cujojs/when" target="_self">https://github.com/cujojs/when</a>),
bluebird (<a href="https://github.com/petkaantonov/bluebird" target="_self">https://github.com/petkaantonov/bluebird</a>) or kew
(actually, an optimized subset of Q, at <a href="https://github.com/Medium/kew" target="_self">https://github.com/Medium/kew</a>),
among many more. You can find the standard &ldquo;Promises/A+&rdquo; documentation at
<a href="https://promisesaplus.com" target="_self">https://promisesaplus.com</a>. An alternative to promises could be async
(<a href="https://github.com/caolan/async" target="_self">https://github.com/caolan/async</a>).
</p><p>
For server-side package management, use npm from <a href="https://www.npmjs.org" target="_self">https://www.npmjs.org</a>.
For client-side packages, either add browserify from
<a href="http://browserify.org" target="_self">browserify.org</a>, or get bower from <a href="http://bower.io" target="_self">bower.io</a>.
</p><p>
Working with CSS is simpler with Sass (<a href="http://sass-lang.com" target="_self">sass-lang.com</a>) or
{less} (<a href="http://lesscss.org" target="_self">lesscss.org</a>); note that the latter can be installed
with npm.
</p><p>
Use testing frameworks, such as Intern (<a href="http://theintern.io" target="_self">theintern.io</a>), Jasmine
(<a href="http://jasmine.github.io" target="_self">jasmine.github.io</a>) or Mocha (<a href="http://mochajs.org" target="_self">mochajs.org</a>). Chai
(<a href="http://chaijs.com" target="_self">chaijs.com</a>), Should.js (<a href="https://github.com/tj/should.js" target="_self">https://github.com/tj/should.js</a>), Expect.js (<a href="https://github.com/mjackson/expect" target="_self">https://github.com/mjackson/expect</a>) and UnitJS 
(<a href="http://unitjs.com" target="_self">unitjs.com</a>) are complete assertion libraries with different
interfaces to suit your preferences. (UnitJS actually includes Should.js
and Expect.js to give you more freedom in choosing your preferred
assertion writing style.) PhantomJS (<a href="http://phantomjs.org" target="_self">phantomjs.org</a>) and
Zombie.js (<a href="http://zombie.labnotes.org" target="_self">zombie.labnotes.org</a>) allow you to run your tests
without using an actual browser, for higher speeds, while Selenium
(<a href="http://www.seleniumhq.org" target="_self">www.seleniumhq.org</a>) is preferred for actual acceptance tests.
</p><p>
Deploy your systems with Grunt (<a href="http://gruntjs.com" target="_self">gruntjs.com</a>) or Gulp
(<a href="http://gulpjs.com" target="_self">gulpjs.com</a>).
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1f66580.0x25e9208"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Federico Kereki is a Uruguayan systems engineer with more than 25 years of
experience developing systems, doing consulting work and teaching at
universities. He currently is working as a UI Architect at Globant, using
a good mixture of development frameworks, programming tools and operating
systems&mdash;and FLOSS, whenever possible! A couple years ago, he wrote
the <span   class="emphasis"><em>Essential GWT</em></span> book, in which you also can find some
security concerns
for Web applications. You can reach Federico at
<a href="mailto:fkereki@gmail.com">fkereki@gmail.com</a>.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../250/toc250.html">Issue Table of Contents</a>
    <a class="link3" href="../250/11808.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>