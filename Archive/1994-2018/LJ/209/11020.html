<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
jEdit: a Text Editor and More
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Getting started with this extensible GUI text editor.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xda4580.0xe9bac0"></a>
jEdit: a Text Editor and More
</h1></div><div><div class="author"><h3 class="author">
Adrian
 
Klaver
</h3></div><div class="issuemoyr">Issue #209, September 2011</div></div><div><p>
Getting started with this extensible GUI text editor.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xda4580.0xe9c1f8"></a></h2></div></div><p>
jEdit is a cross-platform text editor written in Java. The current stable
version at time of this writing is 4.3.2, and it's available at <a href="http://jedit.org" target="_self">jedit.org</a>.
Besides the cross-platform capabilities, jEdit offers other
features, such as a sophisticated plugin system, syntax highlighting for 130
languages, a built-in macro language and extensive encoding support. I wrote
this
article using jEdit, and I demonstrate some of its features here, especially
some of the plugins I have found useful. 
</p><p>
Before I start, jEdit is a
GUI text editor of some heft. It is not a replacement for using vi on the
command line to edit a configuration file on a remote server. It does serve well
in handling many files simultaneously with visual feedback and with the benefits
of a GUI interface. To put it another way, I use vi or jEdit depending on the
need.
</p><p>
Installation is fairly easy; just go to the download page and grab the installer
jar. Be sure to check out the compatibility link if you have a non-Sun (Oracle)
or Apple version of Java. From personal experience, I have not had success
running jEdit on gcj. Assuming you have a compatible version of Java, use the following to install:

<pre     class="programlisting">
java -jar jedit4.3.2install.jar
</pre>
</p><p>
This launches an installer program that guides you through the process.
For the sake of reference, jEdit keeps its configuration files, on Linux anyway, in
~/.jedit/. I mention this because I keep that directory synced between my laptop
and my desktop machines. As a result, I have a consistent working environment
between the two.
</p><p>
At its heart, jEdit is a just a text editor, although it's a text editor with a lot of
options. You can make these options global or apply them on a per-buffer
basis. You can reach the
options via the Utilities menu item. The global options stick
between editing sessions, but the buffer options do not, unless you use the buffer-local
method. This consists of embedding colon-separated hints to jEdit in the file.
jEdit checks the first or last ten lines for these hints. As an example, to
specify an indentation of 2, use spaces for tabs and &ldquo;hard&rdquo; wrap, the embedded
hints would be: 

<pre     class="programlisting">
:identSize=2:noTabs=True:wrap=hard: 
</pre>
</p><p>
jEdit checks anywhere in
those lines, so you can place the hints behind comment symbols. 
</p><p>
Also note
that jEdit supports mode-specific settings, where a mode is a file type, such as
Python (*.py), C (*.c), HTML (*.html) and so on. The various modes come with default
settings, but they can be overridden. One of the key benefits is that the mode
system pulls in file-type-specific syntax highlighting. Other options
are available for the editor's layout. As you can see in the screenshots for this
article, 
I tend to run jEdit with two buffers open, split vertically and with
line-numbering enabled. The ability to look at the beginning and end of file at
the same time, especially source code, is invaluable.
</p><p>
You can use jEdit in a great number of ways.
Watching me enter text, although it has
its moments, is not terribly inspiring. So to keep things interesting, here I 
demonstrate some of the plugins I have found useful. Plugins are code that
scratches an itch. The base jEdit program does a lot, but it does not cover the
universe that is text editing, or other chores for that matter. 
</p><p>
jEdit has a macro
system (not covered in this article), so you can whip up your own solutions to
problems or scope out the plugins available and not re-invent the wheel.
So, before getting into the plugins themselves, here's an overlook at the plugin system
itself. They can be found at <a href="http://plugins.jedit.org" target="_self">plugins.jedit.org</a> or via the
Plugins item on the menu bar. Click on the Plugin Manager item and then the
Install tab for a list of available plugins. Clicking on an item shows a
description at the bottom of the page. Check the box of any plugin(s) you want
to install, and then click Install. If the plugin has dependencies, they
also will
be installed.
</p><p>
So, where to start with the plugins? Let's go from less-involved to
more-involved, beginning
with one suggested to me by a member of the Bellingham Linux User Group:
WhiteSpace. It does what it says&mdash;tracks whitespace. I have it set up to show
trailing whitespace and, additionally, to eliminate any such whitespace when I save. I also have
it show tabs and modify them according to my jEdit soft tab setting. This
setting, when enabled, converts tabs into a defined number of spaces. WhiteSpace
uses the setting to convert preexisting tabs into spaces or vice versa. All of
the above helps when I work in Python code, keeping that pesky whitespace in
order. This also is valuable when writing for <span   class="emphasis"><em>Linux
Journal</em></span>, which requires that writers
use spaces not tabs. See Figure 1 for WhiteSpace in action on a
Python file. From the screenshot, you can see one way to set it up. The
other way is
to go to Plugins&rarr;Plugin Options&rarr;WhiteSpace. This is how most of the
plugins work, although you will find there often are differences in options
available between the two locations.
</p><div       class="mediaobject"><a href="11020f1.large.jpg"><img src="11020f1.jpg"></a><div class="caption"><p>
Figure 1. WhiteSpace Plugin Settings and at Work
</p></div></div><p>
Another plugin I use quite often is JDiff. As the name implies, it shows the diff
between files. Of course, you could use the command line to do the same thing. The
benefit of the plugin is the graphical presentation it provides. Figure 2
shows the dual-diff mode using this article as the files. From here, you can create
a diff output. You also can walk through the diffs and apply them from one side
to another. 
</p><div       class="mediaobject"><a href="11020f2.large.jpg"><img src="11020f2.jpg"></a><div class="caption"><p>
Figure 2. JDiff Plugin in Dual-Diff Mode
</p></div></div><p>
The JDiff plugin has a dockable component that allows
you to drill down into the lines of the files for differences (Figure
3). In the
dual-diff screenshot (Figure 2), you can see another plugin at work, VoxSpell. The
underlining is the spell-checker at work. If you look at the file, you can see
that plugin/plugins go from being underlined to not underlined. I right-clicked on the
words and added them to the dictionary as acceptable, at least for the purposes
of this article. Note that VoxSpell has a dependency on the Spell Check
plugin.
It also uses quite a bit of memory, so that may be an issue.
</p><div       class="mediaobject"><a href="11020f3.large.jpg"><img src="11020f3.jpg"></a><div class="caption"><p>
Figure 3. JDiff Dockable Showing Line Differences
</p></div></div><p>
Next is a chicken-and-egg problem. I ran across a reference to the SQL plugin
for jEdit. In the course of installing it, I found it had a dependency on
the Project Viewer plugin, which meant I had to learn how to use Project Viewer
in order to use the SQL plugin. It turns out that was a good thing. In fact, this
article was written using Project Viewer. First, I will cover the SQL plugin
and later expand on the Project Viewer plugin. 
</p><p>
SQL allows you to work with SQL
databases from within the editor. Setting things up to use the plugin is a two-step
process. First, you need to do the general setup in the SQL options dialog. Go to
the menu, then Plugins&rarr;Plugins Options&rarr;SQL. Go to the JDBC page and use
the Add Element button to indicate the path(s) to the JDBC drivers you want to
make known to the program. At the time of this writing, SQL can work with Oracle, MySQL,
PostgreSQL, Firebird, DB2, Progress, MS SQL Server 2000, Sybase and Teradata,
assuming you have the requisite JDBC drivers. This previous step
&ldquo;registers&rdquo; the
database so it can be used in the next step. 
</p><p>
The next step is to configure a
specific database (or maybe more than one) with a project. This is where Project
Viewer comes in. You use it to create the project (more detail on that
later).
For now, I will use the project that is this article. From the project pane,
right-click on the project name and select properties. This will lead to a series of
dialogs that allow you to fill in the needed information (Figure 4). In this
case, I am using the Pagila demo database for Postgres. From a jEdit
buffer, you
now have access to the database (Figure 5). There is quite a
bit going on there, so let's take it a step at a time. 
</p><div       class="mediaobject"><a href="11020f4.large.jpg"><img src="11020f4.jpg"></a><div class="caption"><p>
Figure 4. Adding SQL Server to a Project
</p></div></div><div       class="mediaobject"><a href="11020f5.large.jpg"><img src="11020f5.jpg"></a><div class="caption"><p>
Figure 5. SQL Plugin Returning a Result Set
</p></div></div><p>
Just above the buffers is
the SQL toolbar. First, above the left buffer is a Database: drop-down list with
the previously configured database selected. To the right of that are four
buttons: the first is Execute selection, the second is Execute buffer, the third
is Load object, and the last is Repeat last query. To the right of the last button
is the Preprocessors drop-down. For this example, I am using the Variable
substitution preprocessor. This can be seen in the &ldquo;actor_id &gt;
?&rdquo; expression in
the SQL statement in the right buffer. 
(As a side note, notice the SQL syntax
highlighting prompted by the use of the *.sql extension.) To continue, I have
selected the statement I want to run and then clicked the Execute selection
button. Because I have variable substitution in force, an input box was presented
(not shown) for me to enter the value for actor_id, in this case 35. The result
is presented in a separate window. From the result set, it is possible to save the
data as CSV or tab format or as INSERT statements. You also can show/hide
columns. Additionally, it's possible to run multiple statements at once
(Figure 6).
This is a somewhat contrived example, but it does show what's possible. The
previous feature allows me to create database DDL files and run them from within the
editor. 
</p><p>
The last feature is SqlVFS (Sql Virtual File System). This allows you to
browse the selected database as a filesystem. To get there, go to
File&rarr;Open&rarr;Commands&rarr;Plugins&rarr;Show databases. Figure 7
shows what you get. Note that 
although Data says 0 bytes, double-clicking on it gives a result set from
the table.
</p><div       class="mediaobject"><a href="11020f6.large.jpg"><img src="11020f6.jpg"></a><div class="caption"><p>
Figure 6. SQL Plugin Running Multiple Statements
</p></div></div><div       class="mediaobject"><a href="11020f7.large.jpg"><img src="11020f7.jpg"></a><div class="caption"><p>
Figure 7. SqlVFS, Database as a Filesystem
</p></div></div><p>
Project Viewer is a plugin to make handling a group of related files (a
project)
easier. For demonstration purposes, I'm using the files that make up this
article. Project Viewer creates a docked button below the menu bar. Click 
it,
and a drop-down appears with All Projects listed. Click this, and a window
opens. Right-click on All Projects, and select Add project, and you get
another window (Figure 8) to enter the required information. Click OK to
create the project. Project Viewer then takes you to that project and puts up a
prompt about importing files into the project. By default, it imports
everything below the root directory. 
</p><div       class="mediaobject"><a href="11020f8.large.jpg"><img src="11020f8.jpg"></a><div class="caption"><p>
Figure 8. Setting Up a Project Using Project Viewer
</p></div></div><p>
At this point, the group of files is bound
together as a project. The benefit is that Project Viewer keeps track of their
state and allows you to return to that state at a later time. Note that it's possible
to add other directories/files to the project later. Simply right-click on the
project name, select Add files and navigate to the desired location(s). You
can
add new files from the existing directory in two ways: one is manual and the
other automatic. The manual option is to right-click the project name and select
Re-import files. The automatic option is to open the project name context
menu,
select Properties&rarr;Auto Reimport and enable it with a time parameter.
Figure 9 shows the visual indicators as to the status of files,
where underlining represents open files and color indicates type of files. 
</p><div       class="mediaobject"><a href="11020f9.large.jpg"><img src="11020f9.jpg"></a><div class="caption"><p>
Figure 9. Files in Project Viewer
</p></div></div><p>
One really handy feature is the Compact View of a project. This is enabled
in the General Options of the Project Viewer plugin options. It presents a
flattened view of a directory structure. This article does not really have
the directory
depth to illustrate the benefit, so take a look at a screenshot from
another project (Figure 10). Each line takes you directly to a directory.
Also of note is the Working Files tab in the project window. This groups all
your current open files together, which is handy in a large project. 
</p><div       class="mediaobject"><a href="11020f10.large.jpg"><img src="11020f10.jpg"></a><div class="caption"><p>
Figure 10. Project Viewer Compact View
</p></div></div><p>
Some other features
include archiving the project files in a JAR file and searching in the project
or project subdirectory files for a string. The ability to consolidate all of
the files related to a project in a single interface is something I've
come to appreciate even more as time passes. Walking through a Project Viewer
directory tree renaming/moving/deleting files while looking at the actual files
is priceless.
</p><p>
What I have presented above barely scratches the surface of what is possible with
jEdit. It has a macro facility that I have not even started to explore. The most
important part of jEdit, to me, is that it lets me get work done without getting
in my way. Furthermore, it makes that work easier, and I hope you find it useful also.
</p></div></div>
<div class="authorblurb"><p>
Adrian Klaver works with computers, and when that proves frustrating, he pushes
wheelbarrows of heavy stuff around to remind himself that maybe computers are not
so
bad after all.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../209/toc209.html">Issue Table of Contents</a>
    <a class="link3" href="../209/11020.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>