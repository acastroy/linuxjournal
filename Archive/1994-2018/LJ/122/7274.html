<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
The Linux Soundfile Editor Roundup</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Whether you're making nifty sounds for desktop events or recording&#10;a whole album, you'll need one of these featureful sound apps.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0xf17580.0x100eab0"></a>
The Linux Soundfile Editor Roundup</h1></div><div><div class="author"><h3 class="author">
Dave
 
Phillips
</h3></div><div class="issuemoyr">Issue #122, June 2004</div></div><div><p>
Whether you're making nifty sounds for desktop events or recording
a whole album, you'll need one of these featureful sound apps.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x100f348"></a></h2></div></div><p>
A soundfile editor is the audio worker's essential utility for performing
various editing operations to massage and finesse recorded sound. Some
of these operations are analogous to those of a text editor, such as
cut/copy/paste actions, while others are unique to editing audio data.
</p><p>
This article takes you on a whirlwind tour of soundfile editors for
Linux. You don't need to know anything special about digital audio or
DSP theory, and if you'd like to try any of these programs, all you need
on your machine is a working sound system. But,
before taking the tour, let's consider what a typical soundfile editor
does and how it's typically used.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x100f4a8"></a>
Common Features</h2></div></div><p>
Editing audio is best accomplished with a graphical interface. By
representing audio data visually, it is simple to locate those
parts of the sound that require attention, such as gaps and amplitude
spikes. This ability to find quickly where an operation is needed
speeds up the editing process. Regions can be marked or selected
accurately,
and zoom routines let users enlarge or diminish their view of a
file at any given point, making it possible to perform large-scale and
sample-accurate edits easily and quickly.
</p><p>
A well-designed soundfile editor should include at least these
basic operations and capabilities:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Cut/copy/paste.
</p></li><li><p>
Splice/insert/replace.
</p></li><li><p>
Move samples.
</p></li><li><p>
Mix tracks.
</p></li><li><p>
Synchronize files/tracks.
</p></li><li><p>
Compress/expand time scale.
</p></li><li><p>
Pitch shifting.
</p></li><li><p>
Equalization/filtering.
</p></li><li><p>
Sample rate conversion.
</p></li><li><p>
Display in different time formats.
</p></li><li><p>
Display multiple views of file.
</p></li><li><p>
Display multiple files simultaneously.
</p></li><li><p>
Independent X/Y axis control.
</p></li><li><p>
Find maximum sample value.
</p></li><li><p>
Display amplitude envelope in various representations (db, peak, RMS).
</p></li><li><p>
Edit pitch and amplitude envelopes.
</p></li><li><p>
Varispeed playback.
</p></li><li><p>
Print out display of samples.
</p></li><li><p>
Spectrum analysis.
</p></li></ul></div><p>
As we shall see, the editors profiled in this article meet most of these
baseline criteria, often adding unique functions and routines.
</p><p>
Table 1 presents a further set of features, most but not all
Linux-specific, and outlines how the editors presented here accommodate them.
</p><div class="table"><a name="N0xf17580.0x1010420"></a><p class="title"><b>
Table 1. Soundfile Editor Features</b></p><table     summary="&#10;Table 1. Soundfile Editor Features7274t1.qrk" border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>
Editor</th><th>ALSA</th><th>JACK</th><th>LADSPA</th><th>GUI</th><th>Size limit</th><th>License</th></tr></thead><tbody><tr><td>Snd</td><td>y</td><td>y</td><td>y</td><td>Motif, GTK [1]</td><td>disk</td><td>GPL</td></tr><tr><td>MiXViews</td><td>n [2]</td><td>n</td><td>n</td><td>InterViews</td><td>memory</td><td>[3]</td></tr><tr><td>DAP</td><td>n [2]</td><td>n</td><td>n</td><td>XForms</td><td>memory</td><td>GPL</td></tr><tr><td>Audacity</td><td>y</td><td>y</td><td>y</td><td>wxGTK</td><td>disk</td><td>GPL</td></tr><tr><td>ReZound</td><td>y</td><td>y</td><td>y</td><td>FOX</td><td>disk</td><td>GPL</td></tr><tr><td>Sweep</td><td>y</td><td>y</td><td>y</td><td>GTK</td><td>disk</td><td>GPL</td></tr><tr><td>GLAME</td><td>y</td><td>n</td><td>y</td><td>GTK</td><td>disk</td><td>GPL</td></tr><tr><td>LAoE</td><td>n [2]</td><td>n</td><td>n</td><td>Java</td><td>disk</td><td>GPL</td></tr><tr><td>Swami</td><td>y</td><td>y</td><td>y</td><td>GTK</td><td>disk</td><td>GPL</td></tr><tr><td>WaveSurfer</td><td>y</td><td>y</td><td>y</td><td>Tcl/Tk</td><td>disk</td><td>[4]</td></tr><tr><td>GNUsound</td><td>y</td><td>n</td><td>y</td><td>GTK</td><td>memory</td><td>GPL</td></tr><tr><td>KWave</td><td>n [2]</td><td>n</td><td>n</td><td>Qt</td><td>memory</td><td>GPL</td></tr></tbody></table></div><p>
[1] Can be compiled without graphics.
[2] Works with ALSA's OSS/Free emulation.
[3] Free for noncommercial use, freely distributable.
[4] Free for unrestricted use, freely distributable.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x1009330"></a>
Common Uses</h2></div></div><p>
Now, let's consider some possible uses for a soundfile editor. The
following list is by no means a complete summary, it merely indicates
how I typically employ an editor in my own work:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Trimming excess silence from recordings.
</p></li><li><p>
Cutting large files into smaller pieces.
</p></li><li><p>
Normalizing.
</p></li><li><p>
Adding effects such as reverb, chorus and flanging.
</p></li><li><p>
Slowing playback speed without changing pitch.
</p></li><li><p>
Removing cracks and pops from recordings.
</p></li><li><p>
Converting sample rate.
</p></li><li><p>
Converting file format.
</p></li><li><p>
Equalizing or filtering the sound to make it brighter or give it more bass.
</p></li><li><p>
Using the editor as a music and sound composition tool.
</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131d110"></a></h2></div></div><p>
Dozens of other operations can be added to this list, and each user will
find special uses for a soundfile editor.
</p><p>
Slowing the playback speed of a file without changing its pitch comes in
handy when I am teaching. Students often bring in recordings that are not
particularly easy to hear or transcribe when played at normal speed. I
convert the original recording (CD or MP3) to a WAV file, load it into
the Snd editor and slow the playback speed, still keeping the original
pitch, until I can hear each note clearly. This makes it easier to
write out an accurate transcription. Some editors let you do this
in real time, and some allow a defined looping region to be arbitrarily
redefined during playback, a very helpful feature.
</p><p>
Normalization raises the amplitudes of a file to their relative peaks,
so all amplitude values are raised relative to the peak value. By
normalizing my project files before burning them to CD, I balance the
volume differences between pieces. Normalization is a common premastering
operation in professionally produced recordings.
</p><p>
A soundfile editor also is useful for repairing badly formed compressed
soundfiles. Some editors load MP3 and Ogg files directly, while
others perform a format conversion and then load the converted file. I can
remove excess silence and fix damaged spots in the recording by removing
or redrawing them. The waveform display represents damaged spots as broken
or incomplete curves. I also normalize and equalize the sound before
converting it back to its original format. Converting a lossy-encoded
file to a soundfile format and back again to a lossy format typically
results in less than optimal audio quality, so I rebalance the sound's
frequencies with the editor's equalization tools.
</p><p>
In the space allotted for this article, I can scratch only the surface of
each profiled editor. We look at each program's salient aspects, but
you should try each one yourself to measure the depths. Let's start
this roundup with some of the older soundfile editors available for Linux.
</p><p>
The first wave of soundfile editors for Linux arrived at a time when
OSS/Free was the system audio interface and Motif was the most attractive
GUI toolkit. They were all designed to
compile and run on a variety of UNIX systems, not only Linux.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131d3d0"></a>
Snd 7.0</h2></div></div><p>
Bill Schottstaedt has been crafting Snd in one form or another since the
era of the PDP minicomputers. However, Snd as we know it dates from late
1996, with Linux support added in 1997.
Snd is a remarkable program. It can be regarded as an exceptionally
powerful soundfile editor, as an infinitely programmable audio editing
toolkit or as a graphic component of the Common environment of
music and sound applications. The Common family of audio applications
include Bill Schottstaedt's Common Lisp Music (software sound synthesis)
and Common Music Notation and Rick Taube's Common Music (metalanguage
for music composition). These are all Lisp-based applications that can be
configured for complex interactivity. The key to unlocking Snd's power lies
in its Guile interface, based on the Lisp-like Scheme programming language.
Snd's interface includes a window called the Listener in which the user
can enter Guile commands for customizing and redefining every aspect of
the program.
</p><p>
The screenshots illustrate how extensively Snd can be configured. Figure
1 shows the Motif version of Snd in its default appearance. In Figure
2, the user interface has been customized extensively. New menus have
been added for Snd's internal DSP modules and LADSPA plugins, the
background and colors are user-defined, and some complex widgets have
been custom-built for some of Snd's effects processors. Figure 2 also
shows off Snd's amplitude waveform view along with its OpenGL display of
the sound's spectrum, its frequency content. Context-sensitive pop-up
menus are available for the different displays as well as for selected
and unselected regions of a file.
</p><p>
Snd is my favorite soundfile editor, but I admit that it may not be the
editor for everyone. If you learn a little Lisp, you can discover more
of Snd's power. Fortunately, Snd comes with exhaustive documentation
to ease difficulties in the learning process. Predefined configuration
files also are available for quicker and easier customization.
</p><div       class="mediaobject"><a href="7274f1.large.jpg"><img src="7274f1.jpg"></a><div class="caption"><p>
Figure 1. The Default Snd
</p></div></div><div       class="mediaobject"><a href="7274f2.large.jpg"><img src="7274f2.jpg"></a><div class="caption"><p>
Figure 2. The Author's Snd
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131d8f8"></a>
MiXViews 1.30</h2></div></div><p>
The 1.0 release of Doug Scott's MiXViews occurred in 1995, making it
the longest-living Linux soundfile editor profiled here. MiXViews was
and is a one-man effort to provide UNIX and Linux with a high-quality audio
editor. The project continues to be a solo development effort, and it
still provides a high-quality editor.
</p><p>
MiXViews provides a strong suite of the basic soundfile editing
functions and adds some features found in no other Linux soundfile
editor. Phase vocoding and linear predictive coding (LPC) are digital
signal analysis/resynthesis tools more commonly associated with software
sound synthesis programs such as Csound or Common Lisp Music. These
tools analyze a sound for its frequency and amplitude values and store
those values in special analysis file formats. An analysis file can
be read by a program such as Csound that gives the user
independent control over the frequency and amplitude components of the
analysis data before its resynthesis to a soundfile. MiXViews provides
a complete suite of its own LPC and phase vocoder utilities; it also
can read and edit analysis files created by the Csound phase
vocoder.
</p><p>
Figure 3 displays some of MiXViews' graphic tools
for editing phase vocoder and LPC analysis data. Although the theory
and mathematics behind these tools can be intimidating, the MiXViews
interface invites experimentation, making the tools themselves easier
and more interesting to use.
</p><p>
If you want to try MiXViews, I suggest using the prebuilt
binary. Compiling MiXViews is somewhat tricky, and it requires an uncommon
graphics toolkit (InterViews), so simply download the static binary and
start using it.
</p><div       class="mediaobject"><a href="7274f3.large.jpg"><img src="7274f3.jpg"></a><div class="caption"><p>
Figure 3. MiXViews
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131dd18"></a>
DAP 2.1.4</h2></div></div><p>
DAP (the Digital Audio Processor) is programmer Richard Kent's
contribution to multiplatform soundfile editors. Like MiXViews,
DAP's GUI is based on a not-so-new GUI toolkit, the XForms library.
Also like MiXViews, DAP's workable soundfile size is limited by your
system RAM. In addition, DAP includes
some exceptionally well-implemented loop editing tools
for AIFF soundfiles. DAP also includes a good selection of DSP modules
(extended from Kai Lassfolk's SPKit code) and a handy mono-to-stereo
and mono/stereo-to-quad converter.
</p><p>
Some of DAP's editing tools deserve special mention, particularly
those found in the Resample and Edit/Mix dialogs. The Resample menu
provides pitch and sample rate change with or without time stretching,
while the Edit/Mix dialogs (Mix and Mix Range) provide a neat graphic
control over the balance of the mixed file amplitudes. The influence
of the AIFF file format and its loop support is found throughout the
program. For example, when an effect is applied to a file the DSP dialog
panel provides a control for the iterations of the sustain and release
loops (Figure 4). Although DAP's design is biased toward the AIFF format,
it also imports and exports files in RAW and WAV formats.
</p><p>
Alas, DAP is no longer consistently maintained. Its XForms GUI is showing
its age, and its file size limitation is a serious drawback. The author
is honest about DAP's limitations, but if you're working with AIFF
files with embedded loop points, DAP is still a useful tool.
</p><div       class="mediaobject"><a href="7274f4.large.jpg"><img src="7274f4.jpg"></a><div class="caption"><p>
Figure 4. DAP
</p></div></div><p>
The next group of editors belong to the new wave of Linux audio
development. Their natural environment includes the modern graphic
interface toolkits and the newer Linux sound system components, such as
ALSA, JACK and LADSPA. They also are conceptually more homogenous than
their predecessors, offering resemblance to the popular editors
familiar to Windows and Mac users.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131e0e0"></a>
Audacity 1.1.3</h2></div></div><p>
Audacity is a fitting first representative of this new wave of
Linux soundfile editors. It is written in C/C++, uses the wxWindows
cross-platform GUI toolkit and supports native and LADSPA signal
processing plugins. Recent versions also are JACK-aware, giving Audacity
the ability to route its I/O to or from other active JACK-aware programs.
</p><p>
Figure 5 illustrates Audacity with three soundfiles opened&mdash;a mono WAV
file, a stereo AIFF file and a file in Sun's AU format. Audacity also
imports MP3 and Ogg files. It exports Ogg files directly, thanks
to the Ogg/Vorbis libraries, but MP3 export depends on a user-supplied
encoder. Figure 5 also shows Audacity's native equalizer plugin at work.
</p><p>
Audacity's graphic editing tools are a pleasure to use. Figure 6 shows off the
envelope tool's effect on the amplitude contour of one of the soundfiles
seen in Figure 5. At the individual sample level, Audacity's drawing
tool makes it easy to remove or repair amplitude spikes and other
discontinuities.
</p><p>
Like Snd, Audacity features an interface to a Lisp-based programming
language, Roger Dannenberg's Nyquist. Nyquist is a language designed
for sound synthesis and signal processing, and Audacity's Effects menu
provides a Nyquist Prompt that works essentially like Snd's Listener. You
enter a Nyquist expression in the prompt dialog, click on the OK button
and if the expression is valid, Audacity performs the intended process
on the active soundfile.
</p><p>
There's far more to Audacity than I can possibly describe
here. Fortunately, the program is easy to learn and use, so check
it out for yourself.
</p><div       class="mediaobject"><a href="7274f5.large.jpg"><img src="7274f5.jpg"></a><div class="caption"><p>
Figure 5. Audacity
</p></div></div><div       class="mediaobject"><a href="7274f6.large.jpg"><img src="7274f6.jpg"></a><div class="caption"><p>
Figure 6. Audacity's Envelope Tool
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131e6b8"></a>
ReZound 0.9.0beta</h2></div></div><p>
With its colorful interface and excellent organization, Davy Durham's
ReZound is a pleasure to see as well to use. But eye candy is the least of
ReZound's features; the program also provides a complete suite of editing
tools, excellent transport controls, some impressive native filters,
support for LADSPA plugins and a unique audio remastering/burn-to-CD
facility.
</p><p>
Figure 7 illustrates ReZound with three soundfiles loaded and the
Curved Balance tool at work on the active file. Curved Balance is one
of ReZound's remastering utilities; others include a noise gate, a
dynamics compressor and gain and normalization controls. These tools,
along with ReZound's other editing amenities, let you massage your
sounds to perfection before burning them to CD. ReZound even
provides a simple dialog for burning the CD (by way of the cdrdao program)
directly from ReZound's File menu.
</p><p>
ReZound's LADSPA support extends to good basic support of the LADSPA VST
host plugin (vst.so) from Kjetil Matheussen. This plugin to support
plugins provides a usable interface based on WINE for running
VST/VSTi plugins under Linux. The vst.so plugin currently is in its
early stages, and its degree of harmony with the hosting application
varies considerably. Figure 8 shows ReZound employing a VST plugin to
apply an effect to the active soundfile.
</p><p>
The most recent version of ReZound supports the JACK audio server,
connecting ReZound to the JACK network of intercommunicating audio
applications. More JACK enhancements are planned, along with effects
previewing, noise removal tools, native time/pitch scaling and many
other features and improvements.
</p><div       class="mediaobject"><a href="7274f7.large.jpg"><img src="7274f7.jpg"></a><div class="caption"><p>
Figure 7. ReZound
</p></div></div><div       class="mediaobject"><a href="7274f8.large.jpg"><img src="7274f8.jpg"></a><div class="caption"><p>
Figure 8. ReZound with LADSPA/VST Support
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x131ec38"></a>
Sweep 0.8.2</h2></div></div><p>
At first look, Conrad Parker's Sweep seems much like the other newer
editors profiled here. It's ALSA-aware, provides a good basic editing
suite, supports LADSPA plugins and shows off a nice modern GTK
interface. Sweep offers two unusual tools, though, that give it special
value. One is the ability to define multiple regions for nonlinear
editing; the other is an interesting little tool named Scrubby.
</p><p>
Defining a selection in a soundfile typically is achieved by placing the
cursor at the selection start, then left-clicking and holding as you sweep the
cursor to the selection end. This selection method is a common practice
employed by all the editors reviewed here. That's how it's done in
Sweep too, but Sweep also lets you define multiple selections. Hold down
the Ctrl key while making your selections, and voil&agrave;, you have
multiple-defined selections available for further processing.
</p><p>
An Invert Selection function provides a neat way to create a
dialog
of effects over a soundfile. Figure 9 illustrates the aftermath of this
series of alterations: define multiple selections;
apply reverse effect to those selections;
invert selection areas (non-selected becomes selected, and vice versa);
and
apply LADSPA effect to new selections.
This is fun stuff and a powerful and creative feature.
</p><p>
Scrubby is Sweep's virtual stylus, essentially functioning as a freely
movable playback head with features more typically associated with a DJ's
turntable system. Scrubby transforms Sweep into a performance tool, an
unusual characteristic for a soundfile editor. A screenshot can't possibly
do justice to Scrubby; you have to use the software to see and hear it
in action.
</p><div       class="mediaobject"><a href="7274f9.large.jpg"><img src="7274f9.jpg"></a><div class="caption"><p>
Figure 9. Sweep
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x1599a10"></a>
Swami 0.9.1a</h2></div></div><p>
The soundfont format (SF2) is a complex soundfile format that includes not
only audio data but also data regarding various effects and performance
controls. Soundfonts have become ubiquitous in the audio world, finding
employment in applications such as Csound, jMax, Pd, Fluidsynth and
many others.
</p><p>
If you want to work with soundfonts, you definitely want Josh Green's
excellent Swami in your toolkit. Swami is a soundfont-only editor with a
well-designed GUI and a wealth of useful features. You can edit existing
soundfonts and create your own from the level of individual samples up to
the composite instrument. You also can edit and design your own soundfont
banks. Other tools are available for setting an instrument's velocity
response curves, keyboard zoning (mapping) and modulator routing. Because
of Swami's strict focus, I don't have much more to say about it;
it is first-rate and is highly recommended Linux audio software.
</p><div       class="mediaobject"><a href="7274f10.large.jpg"><img src="7274f10.jpg"></a><div class="caption"><p>
Figure 10. Swami
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x1599d28"></a>
WaveSurfer 1.5.7</h2></div></div><p>
K&acirc;re Sj&ouml;lander and Jonas Beskow have developed WaveSurfer to
function best in the context of speech research, a domain covering a
variety of audio-related disciplines. WaveSurfer is a perfectly useful
general-purpose soundfile editor, but its special strengths reside in
its tools for analyzing, editing and visualizing the spoken word.
</p><p>
WaveSurfer is written in the popular Tcl/Tk scripting language and widget
toolkit, providing the motivated user complete access to the program's
internals. Sound processing in WaveSurfer is handled by the SNACK audio
functions library, also written by K&acirc;re Sj&ouml;lander. SNACK itself may
be extended by user-defined plugins written in C/C++.
</p><p>
Figure 11 illustrates a simple use of WaveSurfer in speech analysis
and representation. The main panel displays the region highlighted in
the complete waveform, and the label display indicates the sound's
phonemes. The label track is only one example of WaveSurfer's
speech-oriented amenities. Others include spectrographic displays,
pitch curve extraction and support for a variety of soundfile and
transcription formats.
</p><div       class="mediaobject"><a href="7274f11.large.jpg"><img src="7274f11.jpg"></a><div class="caption"><p>
Figure 11. WaveSurfer
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x159a098"></a>
GLAME 1.0.1</h2></div></div><p>
GLAME's developers have implemented an unusual design philosophy
in their editor. GLAME (GNU/Linux Audio MEchanics) supplies the
expected palette of tools for audio editing, but it also includes a
powerful synthesis and processing environment called the filternetwork. A
filternetwork provides a canvas on which icons representing synthesis
primitives are patched together to create a processing or synthesis
chain. Current primitives include oscillators, envelope generators,
filters, I/O modules and LADSPA plugins. Once a synthesis network
has been designed, it can be run to produce real-time audio or output
to a file for further processing (in GLAME, of course). Right-clicking
on the waveform display pops up a menu that includes the Apply Custom
item. By selecting this item, you can apply your filternetwork to the
active soundfile, suggesting some interesting processing possibilities.
</p><p>
Figure 12 illustrates a simple example. The selection in the waveform
display has been processed by a filternetwork composed of a gain control,
a LADSPA delay plugin and a flanger. The track modules are included as
the default I/O ports, representing the original input and the processed
audio output.
</p><div       class="mediaobject"><a href="7274f12.large.jpg"><img src="7274f12.jpg"></a><div class="caption"><p>
Figure 12. GLAME
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x159a3b0"></a>
LAoE 0.6.03beta</h2></div></div><p>
Olivier G&auml;umann's Layer-based Audio Editor (LAoE) offers yet another unique
design philosophy. An editing session in LAoE consists of building a
stack of soundfiles and then opening the desired editing and processing
tools for application upon one or more of the layers (soundfiles)
in the stack. At first it felt like a rather strange way to work, but
after comprehending the program's organization, I began to enjoy its
layout and developed a fast work mode with it.
</p><p>
LAoE receives extra points for originality by providing direct editing in
its spectral display. A user-defined brush is used to paint over areas
for FFT filtering, and the filter itself can be adjusted for finer
resolution. Most of this article's editors offer spectral displays,
but only LAoE permits direct spectral editing.
</p><p>
LAoE also is the only Java-based editor reviewed here. I've installed
Sun's JDK 1.4 on my 800MHz machine, not exactly a fast machine by
today's standards,
but LAoE's interface was quick and responsive throughout.
</p><div       class="mediaobject"><a href="7274f13.large.jpg"><img src="7274f13.jpg"></a><div class="caption"><p>
Figure 13. LAoE
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x159a720"></a>
GNUsound 0.6.1</h2></div></div><p>
Pascal Haakmat's GNUsound is modest in appearance but rich in
content. Once again we have a full complement of the basic editing tools,
LADSPA plugin support and some special tools for marking, selecting
and viewing soundfiles. GNUsound also adopts the concept of tracks, that
is, you can designate a number of files for mixdown in a process similar to
the mixing process in a multitrack recorder.
</p><p>
Another neat aspect of GNUsound is its implementation of envelopes for
effects processing. One of two user-defined envelopes may be selected
as control curves for an associated processing parameter, giving a more
dynamic contour to your effects processing.
</p><p>
Although GNUsound is intended for use in the GNOME environment, I had no
trouble building it under a Planet CCRMA Red Hat 9.0 system and using
it in the BlackBox window manager.
</p><div       class="mediaobject"><a href="7274f14.large.jpg"><img src="7274f14.jpg"></a><div class="caption"><p>
Figure 14. GNUsound
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x159aa90"></a>
KWave 0.7.0-1</h2></div></div><p>
KWave has been in development since 1999, so perhaps I should have
included it along with the venerable stalwarts. However, its development
team has kept pace with its intended target environment, KDE, thus giving
KWave a more modern look and feel along with some interesting improvements.
</p><p>
The new KWave has also retained the original's emphasis on graphical tools
for processing your files. Figure 15 shows off KWave's low-pass filter
editor, complete with a processing preview function. The Listen button
loop plays your file or selection while you adjust the filter in
real time, a handy feature for testing effect parameters.
</p><p>
Some of my favorite tools, such as the additive synthesis generator,
from the original KWave have not yet been reimplemented. Those tools
currently are grayed-out in the menus, but the developers plan to restore
those functions and add new features. Like GNUsound, KWave's file size
is limited to available memory, but it otherwise is a fine editor and is
well suited for casual use on the KDE desktop.
</p><div       class="mediaobject"><a href="7274f15.large.jpg"><img src="7274f15.jpg"></a><div class="caption"><p>
Figure 15. KWave
</p></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0xf17580.0x159ae00"></a>
Final Remarks</h2></div></div><p>
I hope this article has stimulated interest in checking out some of
these applications. Believe it or not, other soundfile
editors are available, though I have tried here to focus on the most
popular ones. The Soundfile Editors section of the Linux
Sound &amp; MIDI Applications site has a full listing of the available Linux
soundfile editors (see the on-line Resources section).
</p><p>
So which one is right for you? It's hard to say. I'm partial to Snd for
its vast programmability and to ReZound for its GUI and organization,
but you have to try some and see which fit your needs best. Above
all, don't be intimidated by the apparent complexity of some of these
editors. Approach them as you would The GIMP, testing their features
at random until you have a sense of what they can do&mdash;don't be shy
about clicking on the Undo button. Playing around with this kind of
software can be fun and open some interesting creative avenues. And if
you come up with some sounds to share, feel free to let me know about
it. Now, go forth and edit those joyful noises.
</p><p>
<span   class="bold"><b>Resources for this article:</b></span> <a href="../122/7506.html" target="_self">/article/7506</a>.
</p></div></div>
<div class="authorblurb"><p>
Dave Phillips is a musician, teacher and writer living in
Findlay, Ohio. He has been an active member of the Linux audio community
since his first contact with Linux in 1995. He is the author of
<span   class="emphasis"><em>The
Book of Linux Music &amp; Sound</em></span>, as well as numerous articles in
<i  >Linux Journal</i>.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../122/toc122.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>