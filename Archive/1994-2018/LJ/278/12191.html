<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
BYOC: Build Your Own Cluster, 
Part II&mdash;Installation
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Installing Linux can be fun. Installing it hundreds of times isn't. Learn how&#10;Linux installations can be automated, making the installation of a cluster&#10;scalable to any number of nodes. &#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x295b580.0x2a52ac0"></a>
BYOC: Build Your Own Cluster, 
Part II&mdash;Installation
</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author">
Nathan
 R. 
Vance
</h3></div><div class="author"><h3 class="author">
Michael
 L. 
Poublon
</h3></div><div class="author"><h3 class="author">
William
 F. 
Polik
</h3></div><div class="issuemoyr">Issue #278, June 2017</div></div></div><div><p>
Installing Linux can be fun. Installing it hundreds of times isn't. Learn how
Linux installations can be automated, making the installation of a cluster
scalable to any number of nodes. 
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a536c8"></a></h2></div></div><p>
In Part I of this three-part series, we left off with bare-metal hardware assembled,
a disk partitioning scheme for the head node and compute nodes, and a design for the
network.
</p><p>
In this article, we bootstrap ourselves up to performing fully automated
operating system installations on both the head node and compute nodes, a vitally
important step for the cluster to be scalable to large numbers of compute nodes. To
create the kickstart scripts used in automated installations, we'll perform the
installation many times, each time with a larger amount of the process being
automated. By the end of this article, we'll have an operating system on all
nodes and network connectivity.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a538d8"></a>
Head Node Manual Installation</h2></div></div><p>
We like to start with doing things manually for several reasons. First, it's a great
opportunity to make sure that the hardware is set up correctly. Second, a manual
installation generates the kickstart file template that will be used in subsequent
installations. Although you can find examples of kickstart files online, it's more
useful to generate it yourself, because then you can be sure it contains the
specifics for your hardware setup.
</p><p>
To perform the installation, you'll need to download the distribution as an ISO
file, burn it to a DVD and boot from it. This guide uses CentOS 7, the
redistributable version of Red Hat Enterprise Linux. Alternatively, you could burn it
to a USB drive; however, Linux currently names hard disks and flash drives in an
arbitrary order, changing the sda and sdb labels on different boots. This will
become a problem when you start kickstarting installations. There are
workarounds,
like using the more verbose UUID naming scheme, but to avoid confusion, we're
going to
assume you use the DVD.
</p><p>
When installing, we assume the disk partitions as described in Part I of this
series:
</p><div class="itemizedlist"><ul type="disc"><li><p>
/ &mdash; 200GB
</p></li><li><p>
/admin &mdash; 200GB
</p></li><li><p>
/home &mdash;rest of space
</p></li></ul></div><p>
For networking, configure the interface on the external network as your network
administrator dictates. As you've probably discovered by now, it's important 
always to be on your network administrator's good side, since he or she has nearly
unlimited power over your internet connectivity. But, you have full control over the
internal network of the cluster.
</p><p>
When configuring the network interface on the internal network, set it to use a
statically assigned IP address. The address should be selected from one of the
private IP address ranges, which are the following:
</p><div class="itemizedlist"><ul type="disc"><li><p>
192.168.0.0 &ndash; 192.168.255.255 
</p></li><li><p>
172.16.0.0 &ndash; 172.31.255.255
</p></li><li><p>
10.0.0.0 &ndash; 10.255.255.255
</p></li></ul></div><p>
In this article, we use a subset of the 192.168 range, specifically
192.168.1.100 &ndash; 192.168.1.199, which provides 100 IP addresses. The head node should
use the first IP address in the range. Therefore, the configuration for the head
node on the internal network is:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Address: 192.168.1.100
</p></li><li><p>
Netmask: 255.255.255.0
</p></li></ul></div><p>
When you select packages to install, choose Server With GUI, and choose E-mail
Server and Development Tools as add-ons. We'll fine-tune this selection later, but
this is a good starting point.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a54278"></a>
Head Node Automated Installation</h2></div></div><p>
To achieve reliability, one needs to have a reproducible installation method that
provides consistent results. Luckily, Red Hat's installer, anaconda, has a
reliable and scalable method called kickstart. Kickstarting means that the
installer uses a configuration file to install Linux automatically. Anaconda
generates a kickstart file after every installation, which you can find at
/root/anaconda-ks.cfg.
</p><p>
After manually installing the head node, locate this file and copy it as ks.cfg to a
separate computer as a backup. You'll be editing ks.cfg over the course of this
article if you're following along, and if the only copy resides on the same
machine being re-installed, a typo
could result in its destruction.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a54430"></a>
Editing the ks.cfg File</h2></div></div><p>
You can edit the kickstart file
to include all desired installation options and
post-installation configurations. The kickstart file must use UNIX end-of-line
characters, so if you're going to edit the file on a Windows machine, use an editor
like notepad++ that respects this difference. Otherwise, it's easiest just to edit
it on the head node and back it up to some other machine.
</p><p>
Kickstart files have a specific formatting so that they can be parsed by the system
installer. A few important features include:
</p><div class="itemizedlist"><ul type="disc"><li><p>
<span   class="bold"><b>Comments</b></span> &mdash; the installer ignores any
line with a leading #.
Such lines are used to comment on code or to disable small sections of code.
</p></li><li><p>
<span   class="bold"><b>Partitioning</b></span> &mdash; there are several lines with partition info that you
selected during the manual installation. Add the option
<tt  >--noformat</tt> to the partition
entries that you don't want to be formatted by the installer, such as /admin and
/home. Do not add this option to the / partition, as it contains the previously
installed OS, which should be erased and replaced during a re-installation.
</p></li><li><p>
<span   class="bold"><b>Repository</b></span> &mdash; this tells the installer
where to find the repository from which to install.
Currently, it is set to install from a CD:

<pre     class="programlisting">
# Use CDROM installation media
cdrom
</pre>
</p><p>
The repository line will be modified several times during this guide.
</p></li><li><p>
<span   class="bold"><b>Miscellaneous Settings</b></span> &mdash; settings may
be applied, such as disabling
SELinux, changing bootloader options and much more. Modify them to disable SELinux:
<tt  >selinux --disabled</tt>.
Visit Red Hat's Kickstart Options guide for an exhaustive list of kickstart options
at
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Installation_Guide/sect-kickstart-syntax.html" target="_self">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Installation_Guide/sect-kickstart-syntax.html</a>.
</p></li><li><p>
<span   class="bold"><b>Packages</b></span> &mdash; after the
<tt  >%packages</tt> tag is a list of packages to be
installed. Those that start with <tt  >@</tt> correspond to groups of
packages, such as <tt  >@
Base</tt>. The others are individual packages.
</p></li><li><p>
<span   class="bold"><b>Postscript</b></span> &mdash; at the end of the
installation, some additional commands
may be executed. Add the following to the end of the file:

<pre     class="programlisting">
%post
%end
</pre>
</p><p>
Between these tags, you'll add post installation scripts that will be executed once
the installation completes. In the DHCP configuration section later in this
article,
we give a sample script to configure DHCP automatically.
We highly recommend
that you include all similar system modifications here as well for
documentation, backup and re-installation purposes.
</p></li></ul></div><p>
Creating an automated installation is an iterative process in which one modifies the
kickstart file, re-installs the system and verifies that the changes took hold as
intended. For example, to check that /admin and /home (and any others that you
specified) don't get formatted during the install, create a file on the
partition and see if it exists after anaconda finishes re-installing. Also check that
SELinux is indeed disabled. You will perform a multitude of installations during the
creation of the cluster, each time automating and then testing a new capability or
feature added to the cluster. Hence, it is vital to automate the process.
</p><p>
You can access the kickstart file for an automated installation in a variety
of ways. The kickstart file can be located on an ext2- or fat32-formatted USB drive,
or on a partition on the hard drive from where it can be read by the installer.
</p><p>
Table 1 summarizes the different installation methods we use to
bootstrap ourselves up to a fully automated installation without removable media. In
this table, the boot/installer is the collection of files from which the CentOS
installer boots, which currently resides on the DVD. Likewise, the distro is the
repository of software that the installer uses to set up the CentOS operating
system, also currently located on the DVD.
</p><div class="table"><a name="N0x295b580.0x2a4b978"></a><p class="title"><b>Table 1. Installation Plan for the Head Node</b></p><table     summary="Table 1. Installation Plan for the Head Node12191t1.qrk" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Installation Method</th><th>Boot/Installer Location</th><th>Kickstart Location</th><th>Distro Location</th></tr></thead><tbody><tr><td>Manual</td><td>DVD</td><td>None</td><td>DVD</td></tr><tr><td>Automated DVD</td><td>DVD</td><td>USB</td><td>DVD</td></tr><tr><td>Automated Hard Drive</td><td>DVD</td><td>Hard Drive</td><td>Hard Drive</td></tr><tr><td>Sans Removable Media</td><td>Hard Drive</td><td>Hard Drive</td><td>Hard Drive</td></tr></tbody></table></div><p>
The end goal is to eliminate the need for removable media and instead to use the
hard disk for the entire installation process.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a4c478"></a>
DVD-Based Booting with Kickstart on USB</h2></div></div><p>
Before starting, this method has one caveat: depending on the hardware configuration
of your system, when the installer boots, the USB drive <span   class="emphasis"><em>may</em></span> show up as a different
drive from normal. For example, in a configuration with two hard drives, sda and sdb,
when you insert a USB drive, it comes up as sdc. However, upon booting into the
installer, the USB drive might be sda, while the hard drives are sdb and sdc. This
scenario would require the kickstart file to be edited so that
<span   class="emphasis"><em>all</em></span> references to any
sdX hard drives are shifted one letter.
</p><p>
To install CentOS using a kickstart file on a USB drive, perform the
following steps.
</p><p>
1) Copy the kickstart file to a blank ext2- or fat32-formatted USB
drive. Make sure the repository line is set to:

<pre     class="programlisting">
cdrom
</pre>
</p><p>
2) With the USB inserted into the head node, you now can use the
kickstart file while booting from the DVD by pressing Tab at the initial welcome
screen and appending the following to the boot options:

<pre     class="programlisting">
inst.ks=hd:sdX1:/ks.cfg
</pre>
</p><p>
Note that sdX corresponds to the USB device when booting with it in place, and that
the drive letter X might not be the same as when you inserted it into a running
operating system. The installer will allow you to edit this line if it fails to find
the kickstart file on the specified device.
</p><p>
By performing an installation this way, you have verified that the kickstart file is
formatted properly. The next step is to eliminate the USB drive and reduce
your
reliance on the DVD.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a4c898"></a>
DVD-Based Booting with Kickstart and Distro on Hard Drive</h2></div></div><p>
The first step in migrating away from external media is to move the kickstart and
distro to the hard drive, thus eliminating the USB drive and reducing the
responsibility of the DVD down to just booting.
</p><p>
To use the kickstart and distro from the hard drive, complete the following steps.
</p><p>
1) Make sure you know the device name of the partition mounted as
/admin. You can discover this information with the <tt  >lsblk</tt> command.
</p><p>
2) Create the following folder hierarchy in /admin:

<pre     class="programlisting">
# mkdir -p /admin/iso/centos7/
# mkdir -p /admin/ks/headnode/
</pre>
</p><p>
3) Copy the installation media to iso/centos7. If you have the original
ISO file floating around, you simply can copy it across the network. If not, you can
use the <tt  >dd</tt> command to create it from the DVD:

<pre     class="programlisting">
# dd if=/dev/cdrom of=/admin/iso/centos7/CentOS-7-x86_64-DVD-1511.iso
</pre>
</p><p>
4) Copy the kickstart file to the newly created ks/headnode folder. In
the ks.cfg file, comment out the repository line and replace it with the following:

<pre     class="programlisting">
harddrive --partition=sdXY --dir=/iso/centos7/
</pre>
</p><p>
Note that <tt  >sdXY</tt> is the partition in which /admin is
located. You can discover this
using the <tt  >lsblk</tt> command. Also, while you have ks.cfg open, verify that it isn't set
to format /admin. You've just made some fairly significant additions to that
partition, and it would be a bummer to wipe them all out.
</p><p>
5) Insert the DVD and reboot. Press Tab at the initial welcome screen
and append the following options: 

<pre     class="programlisting">
inst.ks=hd:sdXY:/ks/headnode/ks.cfg
</pre>
</p><p>
The installation now should proceed using both ks.cfg and the ISO from the hard
drive. This makes the installation go much faster, since it doesn't have to read
everything from the DVD.
</p><p>
The next step in eliminating external media is to set up the /admin partition to be
the installer.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2a4cf78"></a>
Installation Sans Removable Media</h2></div></div><p>
Currently, the only role the DVD serves is to boot the installer. In this
final step,
you'll transfer that role to the hard drive, eliminating the need for all external
media. To do so, you'll configure grub to boot directly into the installer, pass it
the boot options for locating the kickstart file, and install CentOS completely
automatically, without any external media or typing
<tt  >inst.ks=&lt;location&gt;</tt> options into
the terminal.
</p><p>
To run the installer from the hard drive, do the following steps.
</p><p>
1) Make a directory to house boot files:

<pre     class="programlisting">
# mkdir /admin/boot/
</pre>
</p><p>
2) Mount the iso and copy the internal files to the boot directory:

<pre     class="programlisting">
# mount -o loop /admin/iso/centos7/CentOS-7-x86_64-DVD-1511.iso /mnt
# cp -a /mnt/* /admin/boot/
</pre>
</p><p>
3) At the bottom of /etc/grub.d/40_custom, insert the following:

<pre     class="programlisting">
menuentry "Install" {
    set root=(hdW,msdosZ)
    linux /boot/images/pxeboot/vmlinuz ks=hd:sdXY:/ks/headnode/ks.cfg
    initrd /boot/images/pxeboot/initrd.img
}
</pre>
</p><p>
Note the <tt  >(hdW,msdosZ)</tt> and <tt  >ks=hd:sdXY</tt> lines. These correspond to the drive and
partition for /admin. Use the <tt  >lsblk</tt> command to find the partition in sdXY format. W
then corresponds to the drive number; sda is 0, sdb is 1 and so forth. Z is the
partition number /admin is on. So, if /admin is located on sda2, use
<tt  >(hd0,msdos2)</tt>.
</p><p>
4) Regenerate grub.cfg:

<pre     class="programlisting">
# grub2-mkconfig -o /boot/grub2/grub.cfg
</pre>
</p><p>
5) At the end of the ks.cfg file, between <tt  >%post</tt> and
<tt  >%end</tt>, insert the
following:

<pre     class="programlisting">

#grub configuration
cp -p /boot/grub/grub.conf /boot/grub/grub.conf.000
cat &gt;&gt; /etc/grub.d/40_custom &lt;&lt; EOF
menuentry "Install" {
    set root=(hdW,msdosZ)
    linux /boot/images/pxeboot/vmlinuz ks=hd:sdXY:/ks/headnode/ks.cfg
    initrd /boot/images/pxeboot/initrd.img
}
EOF
grub2-mkconfig -o /boot/grub2/grub.cfg

</pre>
</p><p>
This script now will modify your grub.cfg file automatically, as done in steps 3 and
4. Make sure to modify the <tt  >(hdW,msdosZ)</tt> and
<tt  >sdXY</tt> lines as shown in step 3. The method used
here for writing this text to /etc/grub.d/40_custom is called a here file.
As
opposed to using the <tt  >echo</tt> command, here files have far fewer characters that must be
escaped, although some characters still need to be&mdash;for example, every
$ or ` symbol must be escaped with \$ or \`. Otherwise, bash will attempt to resolve
it as a variable or executable script.
</p><p>
6) Reboot. At grub's splash screen, arrow down to the entry titled
&ldquo;Install&rdquo; and press Enter. The system should install.
Now the system installs automatically without external media. This is a very useful
ability to have when rebuilding the head node, and it will be essential for building
compute nodes!
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d5fc40"></a>
Head Node DHCP</h2></div></div><p>
Before installing the compute nodes, Dynamic Host Configuration Protocol (DHCP) must
be configured on the head node. DHCP allows the compute nodes to receive their
network configuration from a central server. This step is vital for a scalable
system, because it allows the nodes to be configured identically but have unique IP
numbers.
</p><p>
To configure DHCP on the head node, complete these steps:
</p><p>
1) Install DHCP:

<pre     class="programlisting">
# yum install dhcp
</pre>
</p><p>
2) Add the following to /etc/dhcp/dhcpd.conf:

<pre     class="programlisting">
#dhcpd config options
authoritative;
default-lease-time -1;
option broadcast-address 192.168.1.255;
ddns-update-style none;
next-server 192.168.1.100;
filename "pxelinux.0";

subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.101 192.168.1.199;
    option subnet-mask 255.255.255.0;
    option domain-name-servers 8.8.8.8;
    option routers 192.168.1.100;
}
</pre>
</p><p>
Change the range option to include enough addresses for all of your nodes. Note that
some options may need to be adjusted if the head node's internal IP is
not 192.168.1.100. The <tt  >domain-name-servers</tt> option may point to whatever DNS you
desire; in this example we use Google's at 8.8.8.8, although some network
administrators may require you to use their own.
</p><p>
3) To start the DHCP service on the head node at boot time, execute the
command:	

<pre     class="programlisting">
# systemctl enable dhcpd
</pre>
</p><p>
And to start the service immediately, execute the command:

<pre     class="programlisting">
# systemctl start dhcpd
</pre>
</p><p>
4) To automate this process, in ks.cfg, append <tt  >dhcp</tt> to the
<tt  >%packages</tt>
list, and between the <tt  >%post</tt> and
<tt  >%end</tt> tags, add the following:

<pre     class="programlisting">

#dhcp
cp -p /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.000
cat &gt; /etc/dhcp/dhcpd.conf &lt;&lt; EOF
	[Contents of dhcpd.conf as determined in step 2 go here]
EOF
systemctl enable dhcpd

</pre>
</p><p>
5) To use DHCP, the firewall must allow it. Since you want all
communications on the internal network to go unobstructed, you simply can add the
interface on that network to firewalld's trusted zone:

<pre     class="programlisting">
# firewall-cmd --permanent --zone=trusted 
 &#8618;--change-interface=[INTERNAL INTERFACE]
# echo "ZONE=trusted" &gt;&gt; 
 &#8618;/etc/sysconfig/network-scripts/ifcfg-[INTERNAL INTERFACE]
# nmcli con reload
# firewall-cmd --reload
</pre>
</p><p>
Use the <tt  >ip addr</tt> command to discover <tt  >[INTERNAL
INTERFACE]</tt>. Add these changes to the
kickstart using the following lines:

<pre     class="programlisting">
firewall-offline-cmd --zone=trusted 
 &#8618;--change-interface=[INTERNAL INTERFACE]
echo "ZONE=trusted" &gt;&gt; 
 &#8618;/etc/sysconfig/network-scripts/ifcfg-[INTERNAL INTERFACE]
</pre>
</p><p>
Note: we'll include a 
more thorough explanation on firewalld in Part III of this series.
</p><p>
Now that the head node is installed fully automatically, and support for a basic
network is in place, you can proceed to the compute nodes.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d605e0"></a>
Compute Node Manual Installation</h2></div></div><p>
On a single compute node, boot from the installation DVD and perform a manual
installation. 
</p><p>
Compute nodes have a different partition table, network setup and package selection
from the head node. The example partitioning scheme we used in Part 1 of this series
is:
</p><div class="itemizedlist"><ul type="disc"><li><p>
/ &mdash; 200GB
</p></li><li><p>
/scratch &mdash; rest of space
</p></li></ul></div><p>
When configuring networking for the compute node, connect using a dynamic IP
address. If DHCP is set up on the head node correctly, you should receive an
address.
</p><p>
For now, make the package selection a Minimal installation.
</p><p>
The generated kickstart file on the newly installed compute node is located at
/root/anaconda-ks.cfg and should be transferred to the head node. In /admin, create
a directory to house the compute node kickstart file:

<pre     class="programlisting">
# mkdir /admin/ks/computenode/
</pre>
</p><p>
Copy it over the network from the compute node to the head node:

<pre     class="programlisting">
# scp 192.168.1.101:/root/anaconda-ks.cfg /admin/ks/computenode/ks.cfg
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d60b60"></a></h2></div></div><p>
substituting the node's actual IP address as determined by running the
<tt  >ip addr</tt> command on it.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d60cc0"></a>
Compute Node Automated Installation</h2></div></div><p>
Automated installations are incredibly important for compute nodes in a cluster.
While manual installations may be practical (though still undesirable because of
reliability) for small test clusters, they scale poorly and are impractical for
medium to large clusters.
</p><p>
For the compute nodes, the process of automating the installation will be similar to
that of the head node. In the kickstart file, be sure to disable SELinux as
you did
for the head node, and also disable the firewall because the compute nodes
won't
be connected to the outside world anyway:

<pre     class="programlisting">
selinux --disabled
firewall --disabled
</pre>
</p><p>
Like with the head node, you'll transfer responsibilities away from the DVD. This
time, rather than the final destination for installation files being the compute
node itself, it will be the head node accessed over the network. In the final
configuration shown in Table 2, the compute nodes will boot over Pre-boot eXecution Environment
(PXE), and they'll retrieve their kickstart files and distributions via a Network File
System (NFS).
</p><div class="table"><a name="N0x295b580.0x2d60ed0"></a><p class="title"><b>Table 2. Installation Plan for the Compute Nodes</b></p><table     summary="Table 2. Installation Plan for the Compute Nodes12191t2.qrk" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>
Method</th><th>
Boot/Installer Location</th><th>
Kickstart Location</th><th>
Distro Location</th></tr></thead><tbody><tr><td>
Manual</td><td>
DVD</td><td>
None</td><td>
DVD</td></tr><tr><td>
Automated DVD</td><td>
DVD</td><td>
USB</td><td>
DVD</td></tr><tr><td>
Automated NFS</td><td>
DVD</td><td>
NFS</td><td>
NFS</td></tr><tr><td>
Automated PXE</td><td>
PXE</td><td>
NFS</td><td>
NFS</td></tr></tbody></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d61978"></a>
DVD-Based Booting with Kickstart on USB</h2></div></div><p>
The procedure here is the same as under the head node. If you are still learning
about kickstart files, feel free to follow the DVD-Based Booting with Kickstart on
USB instructions under the head node section. But otherwise, save yourself time and
use NFS as described in the next section.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2d61a80"></a>
DVD-Based Booting with Kickstart and Distro on NFS</h2></div></div><p>
NFS allows compute nodes to access files stored on the head node over the internal
network. This is a necessary step for the scalability of the cluster, since it would
be impractical to have a copy of the kickstart and distro locally on each node at
installation time.
</p><p>
In this section, we assume that you've configured the directory structure on the head node 
as follows:
</p><div class="itemizedlist"><ul type="disc"><li><p>
/admin/boot contains the contents of the DVD as in the Head Node
Installation Sans Removable Media section.
</p></li><li><p>
/admin/ks/computenode/ks.cfg is the kickstart file for the compute
nodes.
</p></li><li><p>
The head node's IP address on the internal network is
192.168.1.100.
</p></li><li><p>
The head node is assigning addresses using DHCP (this was verified
during the compute node manual installation).
</p></li></ul></div><p>
If your setup differs, modify the following commands accordingly.
</p><p>
To install over NFS, do the following steps.
</p><p>
1) On the head node, open the /etc/exports file in a text editor and
add the following:

<pre     class="programlisting">
/admin 192.168.1.100/255.255.255.0(ro,sync,no_root_squash)
</pre>
</p><p>
This gives all computers on the 192.168.1.0/24 subnet read-only (ro) access to the
/admin directory.
</p><p>
2) Restart the NFS service so that this change takes effect. If NFS
wasn't already running, this will start it:

<pre     class="programlisting">
# systemctl restart nfs
</pre>
</p><p>
3) In the compute node ks.cfg file (located on the head node), comment
out the repository line and replace it with:

<pre     class="programlisting">
nfs --server=192.168.1.100 --dir=/admin/boot
</pre>
</p><p>
This tells the installer to look for the installation files on the network rather
than on a DVD.
</p><p>
4) On a compute node, determine the name of the network interface that
connects to the internal network using the <tt  >ip addr</tt>
command. The interface name could
be formatted in one of several different ways depending on your motherboard, such as
<tt  >ethX</tt>, <tt  >enoX</tt>,
<tt  >enpXsY</tt>, or if you're unlucky, <tt  >en&lt;mac
address&gt;</tt>.
</p><p>
5) Now you can use the kickstart file while booting from the DVD by
pressing Tab at the initial welcome screen and appending the following to the boot
options:

<pre     class="programlisting">
ks=nfs:192.168.1.100:/admin/ks/computenode/ks.cfg ksdevice=ethX
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fde260"></a></h2></div></div><p>
substituting <tt  >ethX</tt> for the interface name found in step 4.
</p><p>
6) To make the changes on the head node persistent between installs,
add the following to the end of the ks.cfg file for the head node between the
<tt  >%post</tt>
and <tt  >%end</tt> tags:

<pre     class="programlisting">
#nfs
echo "/admin 192.168.1.100/255.255.255.0(rw,sync,no_root_squash)" &gt;&gt; 
 &#8618;/etc/exports
systemctl enable nfs
</pre>
</p><p>
The compute nodes now are capable of retrieving kickstarts and installation files
over the network, but that is only half the story. To make the installation
proceed without any media, the nodes must boot over the network as well.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fde578"></a>
PXE-Based NFS</h2></div></div><p>
Pre-boot eXecution Environment (PXE), called MBA on some BIOSes, allows nodes to
retrieve their boot media via the network. Here are some basic prerequisites before
using PXE:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Your motherboard supports PXE.
</p></li><li><p>
PXE is enabled in your BIOS.
</p></li><li><p>
PXE is set before local boot methods on the BIOS boot order.
</p></li></ul></div><p>
PXE allows you to perform kickstart installations on the nodes without having to
load any disks physically. It's then possible to start an automated installation
merely by powering on the cluster. Think about it: throw a switch, take a lunch
break, and when you get back, the entire cluster is installed. That's
scalability!
</p><p>
To make this claim a reality and install the compute nodes from the head
node, do the following.
</p><p>
1) On the head node, install syslinux, tftp-server and tftp using yum.
Add these to the Packages section of the kickstart file for documentation and
re-installation purposes.
</p><p>
2) On the head node, make and populate the directory /admin/tftpboot:

<pre     class="programlisting">
# mkdir /admin/tftpboot
# cp /usr/share/syslinux/pxelinux.0 /admin/tftpboot/
# cp /usr/share/syslinux/menu.c32 /admin/tftpboot/
# mkdir -p /admin/tftpboot/images/centos7/
</pre>
</p><p>
3) Copy in a compressed kernel and initial ramdisk from which the
compute nodes can boot:

<pre     class="programlisting">
# cp /admin/boot/images/pxeboot/vmlinuz 
 &#8618;/admin/tftpboot/images/centos7/
# cp /admin/boot/images/pxeboot/initrd.img 
 &#8618;/admin/tftpboot/images/centos7/
</pre>
</p><p>
Those two files are necessary for booting a bare-bones Linux system. vmlinuz is a
compressed Linux kernel, and initrd.img is a temporary root filesystem. When
you boot
a compute node over PXE, those two files will be transferred to the compute node,
giving it the software required to access the kickstart file and the rest of the
installation files over NFS.
</p><p>
4) Create a directory to hold the PXE configuration files:

<pre     class="programlisting">
# mkdir /admin/tftpboot/pxelinux.cfg
</pre>
</p><p>
5) Create the new /admin/tftpboot/pxelinux.cfg/default file containing
the following:

<pre     class="programlisting">
DEFAULT menu.c32
PROMPT 0
TIMEOUT 100
ONTIMEOUT kickstart
MENU TITLE PXE Menu
MENU separator
LABEL local
LOCALBOOT 0
MENU separator
LABEL   kickstart
        kernel images/centos7/vmlinuz
        append initrd=images/centos7/initrd.img
         &#8618;ks=nfs:192.168.1.100:/admin/ks/computenode/ks.cfg 
         &#8618;ksdevice=ethX
</pre>
</p><p>
Modify the <tt  >ksdevice</tt> as needed. Notice that when the menu times out (ONTIMEOUT), it
defaults to the <tt  >kickstart</tt> option. This is useful for installing the cluster without
manual intervention. But this must be changed later to local for the cluster to
reboot without re-installing the OS.
</p><p>
6) Edit the /usr/lib/systemd/system/tftp.service file, changing the
line:

<pre     class="programlisting">
ExecStart/usr/sbin/in.tftpd -s /var/lib/tftpboot
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fdef18"></a></h2></div></div><p>
to:

<pre     class="programlisting">
ExecStart/usr/sbin/in.tftpd -s /admin/tftpboot
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fdf078"></a></h2></div></div><p>
and restart the service so that this change takes effect. This change could be added
to the head node's kickstart file using a here file, but it's more concise to
use <tt  >sed</tt>:

<pre     class="programlisting">
# sed -i.000 's|/var/lib/tftpboot|/admin/tftpboot|'
# /usr/lib/systemd/system/tftp.service
</pre>
</p><p>
In this command, the <tt  >-i.000</tt> flag specifies that
<tt  >sed</tt> is to do the modification in
place&mdash;that is, it will perform the change and write it back to the original file.
The <tt  >.000</tt> part makes it so that
<tt  >sed</tt> will save the original file with a .000 extension
as a backup. The next component, in single quotes, specifies the operation
that <tt  >sed</tt>
is to perform. The <tt  >s</tt> tells it to do a substitution (as opposed to a
deletion or insertion), the pipe (|) serves as a delimiter between parts of the
command, and the two strings are the parts to exchange. Finally, the file path at
the end of the command specifies the file that <tt  >sed</tt> operates on.
</p><p>
7) Reboot a compute node&mdash;or all of them. If everything is set up
correctly, they will install automatically.
</p><p>
8) Change <tt  >ONTIMEOUT kickstart</tt> to <tt  >ONTIMEOUT
local</tt>. Otherwise, every
reboot will result in a re-install.
</p><p>
An explanation on the inner workings of PXE booting is in order. When
<tt  >pxelinux.0</tt>
boots on a machine, it tftps back to the boot server and tries to find a
configuration file in the pxelinux.cfg directory. The filename is determined by
converting the IP address given to it by the DHCP server to hexadecimal. For
example:

<pre     class="programlisting">
192	168	1	101
C0	A8	01	65	-&gt; C0A80165
</pre>
</p><p>
<tt  >pxelinux.0</tt> attempts to find files in pxelinux.cfg in the
following order:
</p><div class="itemizedlist"><ul type="disc"><li><p>
C0A80165
</p></li><li><p>
C0A8016
</p></li><li><p>
C0A801
</p></li><li><p>
C0A80
</p></li><li><p>
C0A8
</p></li><li><p>
C0A
</p></li><li><p>
C0
</p></li><li><p>
C
</p></li><li><p>
default
</p></li></ul></div><p>
This PXE feature is useful for supplying specific kickstart files for different sets
of compute nodes because of hardware differences; for example, it can supply
different partitioning schemes for different hard disk sizes. Right now DHCP on the
head node is configured to dole out IP addresses in an arbitrary order, making it
hard to take advantage of this feature. (In the next article, we'll fix
that.)
</p><p>
When booting a compute node over the network, vmlinuz (the compressed kernel) and
initrd.img (the compressed initial filesystem) are transferred back to the compute
node, along with the boot options.
</p><p>
In the case with the <tt  >kickstart</tt> option, the boot options tell the installer (included
in initrd.img) the location from which to retrieve ks.cfg, which in turn includes
the location of the distro.
</p><p>
PXE also is useful for booting other images, such as Memtest and other diagnostic
tools.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fe2650"></a>
Conclusion</h2></div></div><p>
In this article, we covered the basics of kickstart files on CentOS, and we set up a
scalable method for installing the entire cluster. The resulting system is capable
of intercommunication over ssh as root, but it doesn't have any useful cluster-wide
application software or users on it yet.
</p><p>
In the final article, we'll address the Linux services that are vital for cluster
operation, culminating on a resource manager called SLURM. With this software in
place, the cluster will be fully fledged and ready for its end users.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x295b580.0x2fe27b0"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Nathan Vance is a computer science major at Hope College in Holland,
Michigan. He discovered Linux as a high-school junior and currently uses
Arch Linux. In his free time, he enjoys running, skiing and writing
software.
</p><p>
Mike Poublon is a senior data-center network engineer and technical lead at
Secant Technologies in Kalamazoo, Michigan. He has extensive professional
experience in networking and high-performance computing systems. As a
student, he built Hope College's first production computer cluster.
</p><p>
William Polik is a computational chemistry professor at Hope College in
Holland, Michigan. His research involves high-accuracy quantum chemistry
using computer clusters. He co-founded WebMO LLC, a software company that
provides web and portable device interfaces to computational chemistry
programs.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../278/toc278.html">Issue Table of Contents</a>
    <a class="link3" href="../278/12191.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>