<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>What's GNU</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    This month's column takes a brief look at the GNU coding&#10;    standards, a document that describes how to write and&#10;    package GNU software.&#10;    "><meta name="keywords" content="GNU, software"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1a04580.0x1afbab0"></a>What's GNU</h1></div><div><div class="author"><h3 class="author">Arnold Robbins</h3></div><div class="issuemoyr">Issue #16, August 1995</div></div><div><p>
    This month's column takes a brief look at the GNU coding
    standards, a document that describes how to write and
    package GNU software.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afc3a0"></a></h2></div></div><p>What is it that makes a GNU program a GNU
program? What makes GNU software &ldquo;better&rdquo; than other (free or
non-free) software? The most obvious difference is the GNU General
Public License (GPL), which describes the distribution terms for
GNU software. But this is usually not the reason you hear people
saying &ldquo;Get the GNU version of <b  >xyz</b>, it's much
better.&rdquo; GNU software is usually more robust, and performs better,
than standard Unix versions. We're going to look at some of the
reasons why, and at the document that describes the principles of
GNU software design.
</p><p>The <span   class="emphasis"><em>GNU Coding Standards</em></span> describe how to
write software for the GNU project. It covers a range of topics. As
of this writing, related chapters are not grouped together, so
we'll look at the chapters by topics, not in the order they
appear.</p><p>You can find the <span   class="emphasis"><em>GNU Coding Standards</em></span> in
the Autoconf distribution, currently
<b  >autoconf-2.3.tar.gz</b>, from your nearest GNU
mirror site. An ASCII copy (<b  >standards.txt</b>)
should also be available as a standalone file from your nearest GNU
mirror site, as well.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afc710"></a>Intellectual Property Rights</h2></div></div><p>The first issue discussed has to do with intellectual
ownership. If you're GOING to write a GNU program that
re-implements a Unix utility, <span   class="emphasis"><em>don't</em></span> look at
the Unix source code! (Source code licenses are harder and harder
to get these days, so this is less of a problem than it was 10
years ago.) The other issue has to do with copyright assignment. If
you're going to write or work on a GNU program, you have to either
declare your work to be in the public domain, or assign the
copyright in it to the FSF. (Small changes don't have to do this,
so don't be scared off by this if you want to submit a bug fix. On
the other hand, if you enhance GNU [cw]find[ecw] so that it can
read <b  >cpio</b> archive tapes, you probably would have
to do paperwork. Even this is usually painless.)</p><p>You can, of course, write a program from scratch, release it
under the GPL, and keep the copyright. You may also generate your
own changes to a program for which the FSF owns the copyright, and
distribute your version separately from the FSF's version, under
the GPL. Assigning copyright to the FSF is only a necessity when
you want your changes to be folded back into the main distribution
of a GNU program.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afc920"></a>Program Design</h2></div></div><p>A number of chapters provide general advice about program
design. The four main issues are compatibility (with standards and
Unix), what language to write in, whether to rely on non-standard
features of other programs (in a word, &ldquo;don't&rdquo;), and what
&ldquo;portability&rdquo; means.</p><p>Compatibility with ANSI, POSIX, and Berkeley Unix is an
important goal. But it's not an overriding one. The general idea is
to provide all necessary functionality, with command line switches
to provide a strict ANSI or POSIX mode.</p><p>C is the preferred language for writing GNU software, since
it is the most commonly available language. In the Unix world, ANSI
C is only now becoming common (sad but true), so K&amp;R C is still
the most widely portable dialect. This is changing rapidly though,
with C++ becoming more commonplace. One widely used GNU package
written in C++ is <b  >groff</b> (GNU troff). With GCC
supporting C++, it has been my experience that installing groff is
not difficult.</p><p>The standards state that portability is a bit of red herring.
GNU utilities are ultimately intended to run on the GNU kernel with
the GNU C library. But since the kernel isn't finished yet, and
users are using GNU tools on non-GNU systems, portability is
desirable, just not paramount. The standard recommends using
Autoconf (about which I one day hope to write a column) for
achieving portability among different Unix systems.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afcb88"></a>Program Behavior</h2></div></div><p>The next group of chapters provides general advice about
program behavior. We will return to look at one of these chapters
in detail, below. These chapters focuses on how to design your
program, how error messages should be formatted, how to write
libraries (make them reentrant), and standards for the command line
interface.</p><p>Error message formatting is important, since several tools,
notably Emacs, use the error messages to help you go straight to
the point in the source file or data file where an error
occurred.</p><p>GNU utilities should use a function named
<b  >getopt_long</b> for processing the command line.
This function provides command line option parsing for both
traditional Unix style options (<b  >gawk -F: ...</b>)
and GNU style long options (<b  >gawk --field-separator=:
...</b>). All programs should provide
<b  >--help</b> and <b  >--version</b> options,
and when a long name is used in one program, it should be used the
same way in other GNU programs. To this end, there is a rather
exhaustive list of long options used by current GNU
programs.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afcef8"></a>Writing C Code</h2></div></div><p>The most substantive part of the manual describes how to
write C code, covering things like formatting the code, comments,
how to use C cleanly, how to name your functions and variables, and
how to declare, or not declare, standard system functions that you
wish to use.</p><p>Code formatting is a religious issue; many people have
different styles that they prefer. I personally don't like the
FSF's style, and if you look at gawk, which I maintain, you'll see
it's formatted in standard K&amp;R style. But this is the only
variation in <b  >gawk</b> from this part of the coding
standards (other variations will go away in <b  >gawk</b>
3.0, coming this year).</p><p>Nevertheless, while I don't like the FSF's style, I consider
it of the utmost importance, when modifying some other program, to
stick to the coding style already used. Having a consistent coding
style is more important than which coding style you pick.</p><p>What I find important about the chapters on C coding is that
the advice is good for <span   class="emphasis"><em>any</em></span> C coding, not just
if you happen to be working on a GNU project. So, if you're just
learning C, or even if you've been working in C (or C++) for a
while, I would recommend these chapters to you, since they
encapsulate many years of experience.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afd210"></a>Documenting Programs</h2></div></div><p>Two chapters cover writing documentation for your program.
The preferred way is to write a manual using Texinfo, which was
discussed in an earlier column (Issue #6, October 1994). There is
some nice advice in here about writing manuals. And, as described
earlier, Texinfo is an enjoyable language in which to write
documentation.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afd318"></a>How to make releases</h2></div></div><p>Finally, there are three chapters devoted to the mechanics of
making a release. These chapters discuss the conventions to use for
Makefiles, how configuration should work, and other generalities
about how a release should work.</p><p>These chapters, together with the Autoconf manual, provide
the needed information for packaging up a program and making the
final released <b  >tar</b>] file.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1afd4d0"></a>What Makes A GNU Program Better?</h2></div></div><p>We'll take a look now at the chapter entitled
<span   class="emphasis"><em>Program Behavior for All Programs</em></span>. This
chapter provides the principles of software design that make GNU
programs better than their Unix counterparts. We will quote
selected parts of the chapter, with some examples of where these
principles have paid off.</p><div class="blockquote"><blockquote class="blockquote"><p>Avoid arbitrary limits on the length or number of
<span   class="emphasis"><em>any</em></span> data structure, including file names,
lines, files, and symbols, by allocating all data structures
dynamically. In most Unix utilities, &ldquo;long lines are silently
truncated&rdquo;. This is not acceptable in a GNU utility.</p></blockquote></div><p>This is perhaps the single most important rule in GNU
software design, &ldquo;no arbitrary limits.&rdquo; All GNU utilities should
be able to manage arbitrary amounts of data.</p><p>While this makes it harder for the programmer, it makes
things much better for the user. I have one gawk user who runs an
awk program on over 650,000 files (no, that's not a typo) to gather
statistics. gawk grows to over 192 Megabytes of data space, and the
program runs for around seven CPU hours. He would simply not be
able to run his program using another awk implementation.</p><div class="blockquote"><blockquote class="blockquote"><p>Utilities reading files should not drop NUL
characters, or any other nonprinting characters (including those
with codes above 0177). The only sensible exceptions would be
utilities specifically intended for interface to certain types of
printers that can't handle those characters.</p></blockquote></div><p>It is also well known that Emacs can edit any arbitrary file,
including files containing binary data!</p><div class="blockquote"><blockquote class="blockquote"><p>Check every system call for an error return,
unless you know you wish to ignore errors. Include the system error
text (from perror or equivalent) in <span   class="emphasis"><em>every</em></span>
error message resulting from a failing system call, as well as the
name of the file if any and the name of the utility. Just &ldquo;cannot
open foo.c&rdquo; or &ldquo;stat failed&rdquo; is not sufficient.</p></blockquote></div><p>Checking every system call provides robustness. This is
another case where life is harder for the programmer, but better
for the user. An error message detailing what exactly went wrong
makes finding and solving any problems much easier.</p><div class="blockquote"><blockquote class="blockquote"><p>Check every call to malloc or realloc to see if
it returned zero. Check realloc even if you are making the block
smaller; in a system that rounds block sizes to a power of 2,
realloc may get a different block if you ask for less space.</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>In Unix, <b  >realloc</b> can destroy
the storage block if it returns zero. GNU
<b  >realloc</b> does not have this bug: if it fails, the
original block is unchanged. Feel free to assume the bug is fixed.
If you wish to run your program on Unix, and wish to avoid lossage
in this case, you can use the GNU <b  >malloc</b>.</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>You must expect <b  >free</b> to alter
the contents of the block that was freed. Anything you want to
fetch from the block, you must fetch before calling
<b  >free</b>.</p></blockquote></div><p>In three short paragraphs, Richard Stallman has distilled the
important principles for doing dynamic memory management using
<b  >malloc</b>. It is the use of dynamic memory, and the
&ldquo;no arbitrary limits&rdquo; principle that makes GNU programs so robust
and more capable than their Unix counterparts.</p><div class="blockquote"><blockquote class="blockquote"><p>Use <b  >getopt_long</b> to decode
arguments, unless the argument syntax makes this
unreasonable.</p></blockquote></div><p>Long options were mentioned earlier. Their use is intended to
make GNU programs easier to use and more consistent than the Unix
versions. The <b  >getopt_long</b> function is a nice
one; it provides you all the flexibility and capabilities you may
need for argument parsing. As a simple yet obvious example,
<b  >--verbose</b> is spelled exactly the same way in
<span   class="emphasis"><em>all</em></span> GNU programs. Contrast this to
<b  >-v</b>, <b  >-V</b>, <b  >-d</b>
etc.</p><p>Finally, we'll quote from an earlier chapter that discusses
how to write your program differently than the way a Unix program
may have been written.</p><div class="blockquote"><blockquote class="blockquote"><p>For example, Unix utilities were generally
optimized to minimize memory use; if you go for speed instead, your
program will be very different. You could keep the entire input
file in core and scan it there instead of using stdio. Use a
smarter algorithm discovered more recently than the Unix program.
Eliminate use of temporary files. Do it in one pass instead of two
(we did this in the assembler).</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>Or, on the contrary, emphasize simplicity instead
of speed. For some applications, the speed of today's computers
makes simpler algorithms adequate. Or go for generality. For
example, Unix programs often have static tables or fixed-size
strings, which make for arbitrary limits; use dynamic allocation
instead. Make sure your program handles NULs and other funny
characters in the input files. Add a programming language for
extensibility and write part of the program in that
language.</p></blockquote></div><p>An excellent example of the difference an algorithm can make
is GNU <b  >diff</b>. My computer's previous incarnation
was an AT&amp;T 3B1; a system with a MC68010 processor, a whopping
two megabytes of memory and 80 megabytes of MFM disk.</p><p>I did (and do) lots of editing on the manual for gawk, a file
that is currently over 17,000 lines long (although at the time, it
was only in the 10,000 lines range). I used to use <b  >diff
-c</b> quite frequently to look at my changes. On this slow
system, switching to GNU <b  >diff</b> made an extremely
noticeable difference in the amount of time it took for the context
diff to appear. The difference is almost entirely due to the better
algorithm that GNU <b  >diff</b> uses.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1ef6850"></a>Summary</h2></div></div><p>The <span   class="emphasis"><em>GNU Coding Standards</em></span> is a worthwhile
document to read if you wish to develop new GNU software, enhance
existing GNU software, or just wish to learn how to be a better
programmer. The principles and techniques it espouses are what make
GNU software the preferred choice of the Unix community.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1a04580.0x1ef69b0"></a>Epilogue</h2></div></div><p>As mentioned, the released version of the standards covers
its topics in a rather haphazard order. As a result of working on
this column, I volunteered to re-organize them into several related
chapters. This new version may be available by the time you read
this article; keep an eye on your nearest GNU mirror site.</p></div></div>
<div class="authorblurb"><p>
      <span   class="bold"><b>Arnold Robbins</b></span>
      is a professional programmer and
      semi-professional author. He has been doing volunteer work for the
      GNU project since 1987 and working with UNIX and UNIX-like systems
      since 1981. Questions and/or comments can be sent by e-mail to
      <a href="mailto:arnold@gnu.ai.mit.edu">arnold@gnu.ai.mit.edu</a></p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../016/toc016.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>