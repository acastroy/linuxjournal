<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>XForms: Review and Tutorial</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Exploring XForms, a graphical user interface toolkit for X.&#10;    "><meta name="keywords" content="tutorials, applications, X, Window, System, programming, business"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1c08580.0x1cffab0"></a>XForms: Review and Tutorial</h1></div><div><div class="author"><h3 class="author">Karel Kubat</h3></div><div class="issuemoyr">Issue #22, February 1996</div></div><div><p>
    Exploring XForms, a graphical user interface toolkit for X.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d003f8"></a></h2></div></div><p>In this article I would like to introduce
you to XForms, a graphical user interface (GUI) toolkit for C and
C++ I discovered a few months ago. I've been writing programs for
several platforms (including, of course, Linux) for some time now
and lately have been snooping around for a good GUI toolkit for X:
one that works, can be obtained free of charge, and (most
importantly) one that you can use right away, without any knowledge
of X intrinsics. Then I heard about XForms, downloaded it, and
tried it out. I wrote my first X program in less than a day.
Impressive!
</p><p>If you have ever looked into one of the programmer's books
about the bare X library, you understand the difficulties I'm
talking about. Writing a &ldquo;hello world&rdquo; program using only X11
itself is no small task. Even the smallest program will require
several hundreds of lines of C code.</p><p>This is where toolkits come in. A GUI toolkit is a library of
functions that make the creation and maintenance of a user
interface more programmer-friendly. One of the better-known
packages is, of course, Motif. If you're lucky, the Motif package
you buy comes with a code generator which enables you to define a
simplified GUI, which is then converted into C code. If you're
<span   class="emphasis"><em>very</em></span> lucky, your package has an interactive
GUI builder, where you can see how your interface will look once
coded. Many GUI toolkits are, however, expensive; and many GUI
toolkits aren't at all friendly to a novice X-programmer.</p><p>The XForms GUI package is not only free (for non-commercial
applications), but it also makes good-looking programs, has an
excellent interactive design builder, comes with good
documentation, and is very easy for novices to use.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d00660"></a>Obtaining XForms</h2></div></div><p>XForms is written by T.C. Zhao and Mark Overmars.</p><p>You can obtain XForms via anonymous ftp at:</p><p>ftp://bloch.phys.uwm.edu/pub/xforms
andftp://ftp.cs.ruu.nl/pub/XFORMS</p><p>You should download the documentation and the XForms toolkit
archive itself. The documentation is contained in a subdirectory
DOC and is available in single or double sided postscript and dvi
format. Since July 1995, the Linux ELF executable format is
supported, as well as the a.out format. To download the toolkit in
a.out format, get the file bxform-075.tgz from the directory linux.
The ELF-based library is in linux/elf. The package is also
available for other platforms; see the documentation.</p><p>Related WWW pages are at
<a href="http://bragg.phys.uwm.edu/xforms" target="_self">http://bragg.phys.uwm.edu/xforms/</a>
and
<a href="http://www.uwm.edu/~zhao" target="_self">www.uwm.edu/~zhao</a></p><p>Finally, you can join a mailing list. Send a message to
<a href="mailto:listserv@imageek.york.cuny.edu">listserv@imageek.york.cuny.edu</a>
and put in the body of the mail message:</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d00a28"></a>subscribe xforms <span   class="emphasis"><em>Your
Name</em></span></h2></div></div><p>The authors can be reached through this list.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d00b88"></a>XForms Basics</h2></div></div><p>Every program that uses XForms for its user interface manages
one or more &ldquo;forms&rdquo;. A form is simply a window under X: with or
without a border, with or without resizing capabilities, with some
window title, etc. The form is a box, into which you can put
&ldquo;objects&rdquo;: buttons, dials, input fields and lots more. Objects
are what many other toolboxes call &ldquo;widgets&rdquo;. Each object is one
of a given &ldquo;class&rdquo;. For instance, XForms supports the object
class &ldquo;button&rdquo;, of which many flavors exist (a simple button,
with a light-bulb on it, round ones, check buttons, radio buttons
etc.). Most programs can be written using XForms' built-in classes,
though XForms supports a free object class to handle special
situations.</p><p>The concepts of XForms, such as classes and objects, resemble
object-oriented programming (and C++ in particular). However, the
XForms code is strictly C, which means that you can use it for both
C and C++. What's more, XForms is built on top of the bare X11
library. Linking an XForms program requires only the presence of
the XForms library, the X11 library and the math library; no other
libraries are necessary.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d00ce8"></a>One Input Source vs. Many</h2></div></div><p>The programming paradigm you have to use with XForms (and in
fact, with any X application) is somewhat different from what you
might be used to. When writing an interactive program that reads
its input from only one source (say, the keyboard), you are likely
to use the following scheme:</p><pre     class="programlisting">
/* forever do: */
while (1)
{
    /* fetch user's input */
    input = get_input ();
    /* determine what it is and
     * take appropriate action
     */
    if (input == one_thing)
        do_one_thing ();
    else if (input == other_thing)
        do_other_thing ();
    .
    .
    .
    /* if `quit` signaled: we're
     * all done here
     */
    else if (input == all_done)
        break;
}
</pre><p>Conversely, when you build a user interface for X, you are
likely to create several input sources. For example, you can have
several buttons which, when pressed, activate some part of your
program's code. Input sources can even be objects that are not
selectable by a user, such as a timer that runs out. The
programming paradigm that represents this is implemented in X with
callbacks. You create several buttons, each with its own specific
callback function. The main program loop then consists of polling
the events at the various input sources and activating the
appropriate callback when something happens. This is the approach
taken by XForms, and we will see a typical program with callbacks
later on.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d00ea0"></a>Code Setup</h2></div></div><p>In general, an XForms program has two types of code: the user
interface that uses the XForms toolkit and the code that performs
some useful actions, i.e., what you want the program to do when,
for instance, a button is pressed. The user interface part of a the
program consists of the initializing code, the definition of the
forms and commands to put the forms on-screen. Then, the program
activates XForms' main loop. This loop does the event polling
described above.</p><p>For example, a tiny program that only shows a &ldquo;quit&rdquo; button
would look as follows:</p><pre     class="programlisting">
#include &lt;forms.h&gt;
/* Call back function, called when `quit`
 * button is pressed
 */
void quit_button_cb (FL_OBJECT *obj, long data)
{
    exit (0);
}
void main (int argc, char **argv)
{
    FL_FORM
        *myform;        /* form to display */
    FL_OBJECT
        *quitbutton;    /* temp variable */
    /* Initializer code: */
    fl_initialize (argv [0], "XMyprog", 0, 0,
                   &amp;argc, argv);
    /* Form definition: */
    myform = fl_bgn_form (FL_FLAT_BOX, 200, 150);
    quitbutton = fl_add_button (FL_NORMAL_BUTTON,
                 50, 50, 100, 50, "Quit");
    fl_set_object_callback (quitbutton,
        quit_button_cb, 0);
    fl_end_form ();
    /* Putting the form on-screen: */
    fl_show_form (myform, FL_PLACE_FREE,
        FL_FULLBORDER, "Button program");
    /* Main XForms loop: */
    fl_do_forms ();
    /* Never reached.. */
}
</pre><p>The definition of a function
<b  >quit_button_cb()</b> can be seen in this listing.
This function is the callback, which is activated when the user
presses the quit button. All following code is in the
<b  >main()</b> function: the initialization, the form
definition, the placing of the form on-screen, and the activation
of the main XForms loop. The initialization part is done by the
function <b  >fl_initialize()</b>, which connects to the
X server, parses the command line, etc. In this example,
<b  >fl_initialize()</b> doesn't need to parse any
application-specific flags; hence the two zero arguments.</p><p>The form definition is enclosed by
<b  >fl_bgn_form()</b> and
<b  >fl_end_form()</b>. Normally you do not write this
code by hand, but leave it to the designer (discussed below). The
form is started by stating the box type and the size of the form.
Between the <b  >fl_bgn_form()</b> and
<b  >fl_end_form()</b> statements, objects can be added
to the form. An object is added using
<b  >fl_add_...()</b>. In this example, only one button
is put in the form at the x and y coordinates 50,50 (relative to
the form's lower left corner) and with a size of 100 by 50 pixels.
The button text is <b  >Quit</b>.</p><p>Following the button definition, the callback of the button
is assigned. Normally you leave even this definition to the
designer. In our case, activation of the button leads to a call to
<b  >quit_button_cb()</b>.</p><p>Note that to add the button, a local variable
<b  >quitbutton</b> is used. The same variable is used in
the next statement to assign the callback. These are the only
statements that require the variable; in other words, an object can
be created (typically in a dedicated function generated by fdesign)
without having to use a global variable. Readability and
maintenance are usually improved by minimal use of global
variables. Later on, you can always find the object when its
callback function is invoked&mdash;the first argument to the callback
is always a pointer to the object in question.</p><p>After the form definition (terminated by
<b  >fl_end_form()</b>), the form is placed on the screen
using <b  >fl_show_form()</b>. The placement type
(resizing capabilities, etc.), border type and window title are
stated here. After this, XForms' main loop
<b  >fl_do_forms()</b> is called. This function never
returns; the program terminates via the callback.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d01738"></a>The Designer</h2></div></div><p>The XForms package contains an excellent designer called
<span   class="bold"><b>fdesign</b></span> to create and maintain a
graphical user interface. The designer lets you create forms, add
objects to the forms, set the objects' properties, such as colors,
etc., and define the callbacks of the objects.</p><p>The designer can be finely tuned. I strongly suggest that you
read the chapter in the documentation about the subject. When
tuning the designer, you specify the type of the generated code,
whether the designer should emit a <b  >main()</b>
function and/or templates for your callbacks, the stepsize in
pixels of the size and placement of objects when designing a form,
and lots more.</p><p>In fact, you should never modify the code the designer
generates; if you want to add special <b  >fl_...()</b>
calls to modify the objects' appearance, do so outside of the
generated code. The reason for this is that later on you may want
to change the look of your program, e.g., by changing some colors.
All you have to do then is to start up the designer, perform your
changes, save the files and re-make. If you modify the generated
code, the changes are lost once you re-save the designer file. (Of
course, I came to this conclusion the hard way&mdash;I made the mistake
of modifying fdesign's output.)</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1d019f8"></a>Installing XForms</h2></div></div><p>The archive containing the XForms toolkit is currently named
bxform-075.tgz, 075 being the version number. After you obtain the
archive, change-dir to a sources directory (such as /usr/src) and
extract the archive using <b  >tar xvzf
bxform-075.tgz</b></p><p>The archive spills into a subdirectory
<span   class="bold"><b>xforms</b></span> where you will find the
Makefile. By default, a <b  >make install</b> copies the
library libforms.a and the header file forms.h to respectively
/usr/lib and /usr/include. The designer, fdesign, goes in
/usr/local/bin. If you want to use other paths, edit the file
mkconfig.h before you <b  >make install</b>.</p><p>If you want to see the demos, type
<b  >make</b>/and wait (this takes some time to
complete). Then <b  >cd DEMOS</b> and type
<b  >./demo</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf86a8"></a>An Example</h2></div></div><p>Having introduced XForms, I want to show you the steps to
create a real XForms program. For the sake of simplicity, I present
a program that manages only two forms. One of the forms has an
input object, in which a user can enter a filename. This form also
has a quit button to terminate the program. The other form has a
browser object, in which the contents of the file are displayed.
Using the scroll bar in the browser, the user can view different
parts of the file.</p><p>As for the behavior of the program, we'll decide that only
the form with the input object and the quit button is initially
on-screen. When the user enters a filename, the form with the
browser containing the file's contents appears. When an empty
filename is entered, the form with the browser disappears
again.</p><p>First of all, we should decide on some names. The forms will
be called respectively <b  >name_form</b> and
<b  >browser_form</b>. Inside the
<b  >name_form</b> there will be two objects: one input
object to allow the user to type a filename and one button to quit.
Both objects will need callbacks to take the appropriate actions:
the functions will be respectively <b  >input_cb()</b>
and <b  >exit_cb()</b>. These objects can remain
nameless, which means that the designer will not generate global
variables to address them.</p><p>The <b  >browser_form</b> needs only one object in
it: a browser object. This object does not need a callback since
the browser will not accept user interaction (except the movement
of the scroll-bar, which is handled internally by the browser).
However, we will need a global variable for this browser since the
callback of the input object of the first form must be able to fill
the browser with the contents of a given file. We will call the
browser <b  >file_browser</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf8b20"></a>Using the Designer</h2></div></div><p>Now that we have decided on the names of forms and objects,
we can design the forms. The XForms designer can be started with
<b  >fdesign design &amp;</b>, telling it to save its
output in the files design.fd (the design itself), design.c
(generated C code) and design.h (generated header file). The
ampersand starts fdesign in the background.</p><p>Once the designer comes up, click on the &ldquo;New Form&rdquo; button
to start a new form and enter the form name
<b  >name_form</b>. You can rescale the window that
appears to a suitable size. After this, put the required objects in
the form: an input object and a button. These objects can be
selected in the &ldquo;Objects&rdquo; menu of the designer. Once an object is
placed in the form, you can resize or move it using the mouse. The
&ldquo;Align&rdquo; button lets you define the stepsize in pixels by which
the objects are scaled or moved. Pressing F1 activates an
&ldquo;Attributes&rdquo; window, in which the object attributes (such as
font, color, callback) can be defined.</p><p>As far as the <b  >name_form</b> is concerned, you
should create something that looks like the screen dumps in
<a href="1188f1.html" target="_self">figures 1</a> and
<a href="1188f2.html" target="_self">Figure 2</a>. Figure 1 shows the
designer window itself, the name form, and the attribute window of
the input object. (Yes, I wrote the program around noon.) In this
figure the input object is &ldquo;active&rdquo; as can be seen by the red box
around it.</p><p>Figure 2 shows the quit button and its properties.</p><p>To define the browser form, click again on &ldquo;New Form&rdquo; to
start a second form. Enter <b  >browser_form</b> as the
form name, and resize the form window to your liking. Then select a
&ldquo;browser&rdquo; object from the Objects menu and add it to the form.
The form, its browser object and the properties of the browser are
shown in <a href="1188f3.html" target="_self">Figure 3</a>.</p><p>Having defined the form, we can let fdesign generate its
code. Click on the &ldquo;Options&rdquo; button and toggle the &ldquo;Alt format&rdquo;
entry to light up the button in front of this menu entry. This
instructs fdesign to generate simple code, instead of placing form
and object variables into structs. For this application, simple
code suffices. Then click on the &ldquo;File&rdquo; button, save the file,
and exit fdesign.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf9048"></a>Putting It All Together</h2></div></div><p>We can rely on fdesign to generate the code for the
definition of all forms and objects. That leaves us with two tasks:
the initialization code and the callback code.</p><p>The initialization code is shown in listing 1. This code
defines the <b  >main()</b> function in which XForms is
initialized, the forms are created, the first form is put
on-screen, and the main XForms loop is entered. You can see the
call to <b  >create_the_forms()</b>; the code of this
function is generated by fdesign in the file design.c.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf9258"></a>Listing 1: xviewfile.c</h2></div></div><pre     class="programlisting">
/* xviewfile.c -- main function of xviewfile */
#include \&lt;&gt;forms.h
#include "design.h"
void main (int argc, char **argv)
{
    /* initialize XForms, parse arguments */
    fl_initialize (argv [0], "XViewfile", 0, 0, &amp;argc, argv);
    /* create the forms (fdesign-generated function) */
    create_the_forms ();
    /* show the name input form */
    fl_show_form (name_form, FL_PLACE_MOUSE, FL_FULLBORDER, "Enter a name");
    /* enter XForms loop */
    fl_do_forms ();
    /* not reached... */
}
</pre><p>Now for the second task, the callback code. The callback
functions are shown in listing 2. The names of the callback
functions were already mentioned in the design specifications; it
is therefore important that the exact names are used when writing
the functions.</p><p>Each callback activated by an object is passed two arguments.
The first argument is a pointer to a <b  >FL_OBJECT</b>.
This argument points by definition to the object which invoked the
callback. We will see how this argument is used in the
<b  >input_cb()</b> function. The second argument is a
long int&mdash;a value which can be set to any number when defining the
callback in the designer. For example, you could have two different
objects invoking the same callback function but providing different
numeric arguments; inside the function you could distinguish by
inspecting the second argument. We won't use this approach in this
application.</p><p>The callback activated by the quit button is called
<b  >exit_cb()</b>. This is the easy one&mdash;all it does is
<b  >exit(0)</b>. The callback for the input object,
<b  >input_cb()</b>, needs to perform more tasks. First,
the name which was typed by the user must be retrieved. This is
done by XForms' function <b  >fl_get_input()</b>. Then,
we must decide what to do with the input. As specified by the
program description above, an empty name should lead to the removal
of the browser window from the screen. A non-empty name should be
interpreted as a request to view a file.</p><p>To accomplish this, <b  >input_cb()</b> uses a
static <b  >int</b> variable to flag whether the browser
form is yet on-screen. When a non-empty name is entered and when
the browser form is not yet on the screen,
<b  >fl_show_form()</b> is called to show the browser.
Similarly, when an empty name is entered and when the browser form
is on-screen, <b  >fl_hide_form()</b> is called to remove
the browser form. (Instead of using an extra static
<b  >int</b>, you could also inspect the field int
<b  >visible</b>, which is part of the
<b  >FL_FORM</b> struct. I leave such optimizations to
the reader.)</p><p>The browser itself is manipulated with browser-specific
functions <b  >fl_clear_browser()</b> and
<b  >fl_load_browser()</b>.</p><pre     class="programlisting">
/* callbacks.c --contains the callback routines */
#include &lt;\&lt;&gt;forms.h&gt;
#include "design.h"
void exit_cb (FL_OBJECT *obj, long data)
{
    exit (0);
}
void input_cb (FL_OBJECT *obj, long data)
{
    char const
        *name;                              /* entered filename */
    static int
        browser_on_screen = 0;              /* is browser on-screen yet ? */
    /* determine the entered name */
    name = fl_get_input (obj);
    if (name &amp;&amp; *name)                      /* a name was entered */
    {
        if (! browser_on_screen)            /* make sure browser is there */
        {
            fl_show_form (browser_form, FL_PLACE_CENTER,
                          FL_FULLBORDER, name);
            browser_on_screen = 1;
        }
        fl_clear_browser (file_browser);    /* clear previous contents */
        fl_load_browser (file_browser,      /* load in file */
                         name);
    }
    else                                    /* empty input was given */
    {
        if (browser_on_screen)              /* remove browser from screen */
        {
            fl_hide_form (browser_form);
            browser_on_screen = 0;
        }
    }
}
</pre><p>Finally, no program is complete without an automatic
maintenance description in a Makefile. Here is an example:</p><pre     class="programlisting">
# Makefile -- makefile for xviewfile.
# Used objects:
OBJ = xviewfile.o callbacks.o design.o
# Compilation flags:
CFLAGS = -c -O2 -Wall
# How to make the program:
xviewfile: $(OBJ)
        $(CC) -o xviewfile $(OBJ) -lforms -lX11 -lm
-s
# How to clean up the mess.
clean:
        rm -f $(OBJ)
</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf9b48"></a>Loose Ends</h2></div></div><p>The listings show only the tip of the iceberg of as far as
XForms' possibilities are concerned. For the sake of brevity, I did
not address subjects such as color definition or font
selection.</p><p>One thing you will want to try is making resizable forms.
Whether a form can be resized is defined in the call to
<b  >fl_show_form()</b>, which displays the form. How the
form is resized is defined in the form definition itself. Again,
you should use fdesign to set these options. For example, you might
have a form with a button and an input object at the top, and with
a browser below thrm. When such a form would be resized, you'd
probably want only the browser to expand or shrink, not the button
and input object. Such capabilities are set with objects' resizing
options and gravities. XForms, and hence the designer, supports
&ldquo;object groups&rdquo; for this purpose: you can group objects and
define the resizing options and gravities to apply to a whole
group.</p><p>Another useful property of any X program is the ability to
let the user overrule settings of the program via command line
flags, resources set via xrdb, or resources set via an application
defaults file. XForms supports all of these;
<b  >fl_initialize()</b> can be used in combination with
<b  >fl_get_resources()</b> to scan for meaningful flags
or resource settings. Implementing the resource recognition is not
entirely trivial but goes beyond the scope of this article. If
you're interested, look at some of the programs built using XForms.
The XForms distribution as well as the WWW resources contain
pointers to useful and illustrative programs.</p><p>Naturally, there are lots of other useful XForms
possibilities. I leave it to you to read through the excellent
documentation on a quiet evening with a glass of (virtual)
beer.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c08580.0x1cf9e60"></a>Review of Xforms</h2></div></div><p>Needless to say, I am very enthusiastic about XForms. The
setup of the XForms toolkit (using forms, objects, classes) is very
intuitive even when you have no previous experience with X
programming at all. You do need good knowledge of C, though.</p><p>The range of object classes in XForms is so wide that I
haven't (yet) needed to define a free object class. If you plan to
write everyday programs, XForms probably has the classes to suit
your needs, and the classes have plenty of dedicated functions to
make the objects appear the way you like.</p><p>As far as the designer is concerned, I have come to cherish
this tool, even though I first regarded it as just a flashy extra.
The ease with which you can adapt a program to perform an extra
task, by expanding an existing form to hold, say, an extra button,
is incredible. No more code editing to adjust the coordinates of
all widgets!</p><p>There are, of course, drawbacks. I think it's a shame that
XForms is not distributed with the full sources. The fact that
XForms can be used free of charge for non-commercial applications
is of course a huge advantage, but still, I'd rather have the
sources at hand. This irritation can be overcome if you're willing
to pay the price: the authors do sell license agreements that
include the source files.</p><p>Another drawback is that if you do not use the ELF-based
version of XForms, you have to link your programs against a static
libforms.a. There is no shared a.out-based library for XForms.
Therefore, unless you migrate to the ELF executable format, even
the smallest program turns out to be about 130KB. (On the other
hand, I also use statically linked Motif programs. The 130KB is, by
comparison, trivial.)</p><p>The XForms library is &ldquo;nice&rdquo; to programmers, which is an
advantage when you are a new user or when you're developing a
program. For example, when a program tries to remove a form from
the screen which is not on-screen in the first place, XForms will
pop up a warning window. You are then presented with three choices:
to ignore the action, to abort the program, or to suppress such
warnings. This feature is very handy when you are testing a
program. However, such safety nets add &ldquo;superfluous&rdquo; code to a
program. Once a program has been tested, such precautions are, in
my opinion, no longer necessary and therefore only a burden.
Ideally, I'd prefer two flavors of the XForms library: a
developer's version with the full safety features and a production
version without them. On the authors' part this would require only
some <b  >#ifdef</b>/<b  >#endif</b>
compilation directives in the code.</p><p>On the whole, I find that there are many more advantages to
XForms than there are disadvantages. I use XForms now and I'm
planning to continue to do so. I still haven't hit a wall in my X
programming efforts that could not be overcome using XForms' own
features. And I haven't even explored all possibilities of XForms
yet.</p><p>Karel Kubat lives in the northern part of the Netherlands and
is currently working on his PhD thesis. He is a Linux fanatic and
therefore pretends to know everything about the subject, since
that's what being a fanatic is all about. He can be reached via
e-mail at the University of Groningen at
<a href="mailto:karel@icce.rug.nl">karel@icce.rug.nl</a>.</p></div></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../022/toc022.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>