<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Back Up GitHub and GitLab Repositories Using Golang
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;Want to learn Golang and build something useful? Learn how to write a&#10;tool to back up your GitHub and GitLab repositories.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1530580.0x1627ac0"></a>
Back Up GitHub and GitLab Repositories Using Golang
</h1></div><div><div class="author"><h3 class="author">
Amit
 
Saha
</h3></div><div class="issuemoyr">Issue #279, July 2017</div></div><div><p>
Want to learn Golang and build something useful? Learn how to write a
tool to back up your GitHub and GitLab repositories.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1628300"></a></h2></div></div><p>
GitHub and GitLab are two
popular Git repository hosting services that are used to host and manage
open-source projects. They also have become an easy way for content
creators to be able to invite others to share and collaborate without
needing to have their own infrastructure setup.
</p><p>
Using hosted services that you don't manage yourself, however, comes with a
downside. Systems fail, services go down and disks crash. Content
hosted on remote services can simply vanish. Wouldn't it be nice if you
could have an easy way to back up your git repositories periodically into
a place you control?
</p><p>
If you follow along with this article, you will write a Golang program to back up git
repositories from <a href="https://github.com" target="_self">https://github.com</a> and <a href="https://about.gitlab.com" target="_self">https://about.gitlab.com</a> (including custom GitLab
installations). Being familiar with Golang basics will be helpful, but
not required. Let's get started!
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1628618"></a>
Hello Golang</h2></div></div><p>
The latest stable release of Golang at the time of this writing is 1.8. The package name is
usually golang, but if your Linux distro doesn't have this release,
you can download the Golang compiler and other tools for Linux
from <a href="https://golang.org/dl" target="_self">https://golang.org/dl</a>. Once downloaded, extract it to
/usr/local:

<pre     class="programlisting">

$ sudo tar -C /usr/local -xzf &lt;filename-from-above&gt;
$ export PATH=$PATH:/usr/local/go/bin

</pre>
</p><p>
Opening a new terminal and typing <tt  >$ go version</tt> should show the
following:


<pre     class="programlisting">
$ go version
go version go1.8 linux/amd64
</pre>
</p><p>
Let's write your first program. Listing 1 shows a program that expects
a <tt  >-name</tt> flag (or argument) when run and prints a greeting using the
specified name. Compile and run the program as follows:

<pre     class="programlisting">
$ go build listing1.go
$ ./listing1 -name "Amit"
Hello Amit

$ ./listing1
./listing1
2017/02/18 22:48:25 Please specify your name using -name
$ echo $?
1
</pre>
</p><p>
If you don't specify the <tt  >-name</tt> argument, it exits printing a message
with a non-zero exit code. You can combine both compiling and running
the program using <tt  >go run</tt>:

<pre     class="programlisting">
$ go run listing1.go -name Amit
2017/03/04 23:08:11 Hello Amit
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1628b40"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Listing 1. Example Program listing1.go</b></p><pre     class="programlisting">
package main

import (
    "flag"
    "log"
)

func main() {
    name := flag.String("name", "", "Your Name")
    flag.Parse()

    if len(*name) != 0 {
            log.Printf("Hello %s", *name)
    } else {
            log.Fatal("Please specify your name using -name")
    }
}
</pre></div><p>
The first line in the program declares the package for the program. The
<tt  >main</tt> package is special, and any executable Go program must live in
the <tt  >main</tt> package. Next, the program imports two packages from the Golang standard
library using the <tt  >import</tt> statement:

<pre     class="programlisting">
import (
	"flag"
	"log"
)
</pre>
</p><p>
The <tt  >"flag"</tt> package is used to handle command-line
arguments to programs,
and the <tt  >"log"</tt> package is used for logging. 
</p><p>
Next, the program defines the <tt  >main()</tt>
function where the program execution starts:

<pre     class="programlisting">
func main() {
    name := flag.String("name", "", "Your Name")
    flag.Parse()

    if len(*name) != 0 {
        log.Printf("Hello %s", *name)
    } else {
        log.Fatal("Please specify your name using -name")
    }
}
</pre>
</p><p>
Unlike other functions you'll write, the <tt  >main</tt> function doesn't return
anything nor does it take any arguments. The first statement in the
<tt  >main()</tt> function above defines a string flag,
<tt  >"name"</tt>, with a default value
of an empty string and <tt  >"Your Name"</tt> as the help message. The return value
of the function is a string pointer stored in the variable,
<tt  >name</tt>. The
<tt  >:=</tt>
is a shorthand notation of declaring a variable where its type is inferred
from the value being assigned to it. In this case, it is of type
<tt  >*string</tt>&mdash;a reference or pointer to a string value.
</p><p>
The <tt  >Parse()</tt> function parses the flags and makes the specified flag values
available via the returned pointer. If a value has been provided to
the <tt  >"-name"</tt> flag when executing the program, the value will be stored
in <tt  >"name"</tt> and is accessible via
<tt  >*name</tt> (recall that <tt  >name</tt> is a string
pointer). Hence, you can check whether the length of the string referred to
via <tt  >name</tt> is non-zero, and if so, print a greeting
via the <tt  >Printf()</tt>
function of the log package. If, however, no value was specified, you use
the <tt  >Fatal()</tt> function to print a message. The
<tt  >Fatal()</tt> function prints
the specified message and terminates the program execution.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1629748"></a>
Structures, Slices and Maps</h2></div></div><p>
The program shown in Listing 2 demonstrates the following different things:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Defining a struct data type.
</p></li><li><p>
Creating a map.
</p></li><li><p>
Creating a slice and iterating over it.
</p></li><li><p>
Defining a user-defined function.
</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1629b68"></a></h2></div></div><div class="sidebar"><p class="title"><b>Listing 2. Structures, Slices and Maps Example</b></p><pre     class="programlisting">
package main

import (
    "log"
)

type Repository struct {
    GitURL string
    Name   string
}

func getRepo(id int) Repository {
    repos := map[int]Repository{
        1: Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
         &#8618;Name: "gitbackup"},
        2: Repository{GitURL: "ssh://github.com/amitsaha/lj_gitbackup", 
         &#8618;Name: "lj_gitbackup"},
    }

    return repos[id]
}

func backUp(r *Repository) {
    log.Printf("Backing up %s\n", r.Name)
}

func main() {
    var repositories []Repository
    repositories = append(repositories, getRepo(1))
    repositories = append(repositories, getRepo(2))
    repositories = append(repositories, getRepo(3))

    for _, r := range repositories {
            if (Repository{}) != r {
                    backUp(&amp;r)
            }
    }
}
</pre></div><p>
At the beginning, you define a new struct data type
<tt  >Repository</tt>
as follows:


<pre     class="programlisting">
type Repository struct {
    GitURL string
    Name   string
}
</pre>
</p><p>
The structure <tt  >Repository</tt> has two members:
<tt  >GitURL</tt> and <tt  >Name</tt>, both of type
<tt  >string</tt>. You can define a variable of this structure type using <tt  >r
:= Repository{"git+ssh://git.mydomain.com/myrepo", "myrepo"}</tt>.
You
can choose to leave one or both members out when defining a structure
variable. For example, you can leave the <tt  >GitURL</tt>
unset using <tt  >r :=
Repository{Name: "myrepo"}</tt>, or you even can leave both out.
When you leave
a member unset, the value defaults to the zero value for that type&mdash;0 for int, empty string for string type.
</p><p>
Next, you define a function, <tt  >getRepo</tt>, which takes an integer as argument
and returns a value of type <tt  >Repository</tt>:

<pre     class="programlisting">
func getRepo(id int) Repository {
    repos := map[int]Repository{
        1: Repository{GitURL: "git+ssh://github.com/amitsaha/gitbackup", 
 &#8618;Name: "gitbackup"},
        2: Repository{GitURL: 
 &#8618;"git+ssh://github.com/amitsaha/lj_gitbackup", Name: "lj_gitbackup"},
    }

    return repos[id]
}
</pre>
</p><p>
In the <tt  >getRepo()</tt> function, you create a map or a hash table of key-value
pairs&mdash;the key being an integer and a value of type
<tt  >Repository</tt>. The map
is initialized with two key-value pairs.
</p><p>
The function returns the <tt  >Repository</tt>, which corresponds to the specified
integer. If a specified key is not found in a map, a zero value of the
value's type is returned. In this case, if an integer other than 1 or
2 is supplied, a value of type <tt  >Repository</tt> is returned with both the
members set to empty strings.
</p><p>
Next, you define a function <tt  >backUp()</tt>, which accepts a pointer to a
variable of type <tt  >Repository</tt> as an argument and
prints the <tt  >Name</tt> of the
repository. In the final program, this function actually will create a
backup of a repository.
</p><p>
Finally, there is the <tt  >main()</tt> function:

<pre     class="programlisting">
func main() {
    var repositories []Repository
    repositories = append(repositories, getRepo(1))
    repositories = append(repositories, getRepo(2))
    repositories = append(repositories, getRepo(3))

    for _, r := range repositories {
        if (Repository{}) != r {
            backUp(&amp;r)
        }
    }
}
</pre>
</p><p>
In the first statement, you create a slice, <tt  >repositories</tt>, that will store
elements of type <tt  >Repository</tt>. A slice in Golang is an dynamically sized
array&mdash;similar to a list in Python. You then call the
<tt  >getRepo()</tt> function
to obtain a repository corresponding to the key 1 and store the returned
value in the <tt  >repositories</tt> slice using the <tt  >append()</tt>
function. You do the
same in the next two statements. When you call the
<tt  >getRepo()</tt> function
with the key, 3, you get back an empty value of type
<tt  >Repository</tt>.
</p><p>
You then use a for loop with the <tt  >range</tt> clause to iterate over the elements
of the slice, <tt  >repositories</tt>. The index of the element in a slice is
stored in the <tt  >_</tt> variable, and the element itself is
referred to via the
<tt  >r</tt>
variable. You check if the element is not an empty
<tt  >Repository</tt> variable,
and if it isn't, you call the <tt  >backUp()</tt> function, passing the address of
the element. It is worth mentioning that there is no reason to pass the
element's address; you could have passed the element's value itself. However,
passing by address is a good practice when a structure has a large number
of members.
</p><p>
When you build and run this program, you'll see the following output:

<pre     class="programlisting">
$ go run listing2.go
2017/02/19 19:44:32 Backing up gitbackup
2017/02/19 19:44:32 Backing up lj_gitbackup
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1a22f98"></a>
Goroutines and Channels</h2></div></div><p>
Consider the previous program (Listing 2). You call the
<tt  >backUp()</tt> function
with every repo in the repositories serially. When you actually create
a backup of a large number of repositories, doing them serially can
be slow. Since each repository backup is independent of any other,
they can be run in parallel. Golang makes it really easy to have
multiple simultaneous units of execution in a program using
goroutines.
</p><p>
A goroutine is what other programming languages refer to as lightweight
threads or green threads. By default, a Golang program is said to be
executing in a main goroutine, which can spawn other goroutines. A main
goroutine can wait for all the spawned goroutines to finish before
finishing up using a variable of <tt  >WaitGroup</tt> type, as you'll see next.
</p><p>
Listing 3 modifies the previous program such that the
<tt  >backUp()</tt> function
is called in a goroutine. The <tt  >main()</tt> function
declares a variable, <tt  >wg</tt>
of type <tt  >WaitGroup</tt> defined in the sync package, and
then sets up a deferred
call to the <tt  >Wait()</tt> function of this variable. The
<tt  >defer</tt> statement is
used to execute any function just before the current function returns.
Thus, you ensure that you wait for all the goroutines to finish before
exiting the program.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1a23468"></a></h2></div></div><div class="sidebar"><p class="title"><b>Listing 3. Goroutine Example</b></p><pre     class="programlisting">
package main

import (
    "log"
    "sync"
)

type Repository struct {
    GitURL string
    Name   string
}

func getRepo(id int) Repository {

    repos := map[int]Repository{
            1: Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            2: Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
    }

    return repos[id]
}

func backUp(r *Repository, wg *sync.WaitGroup) {
    defer wg.Done()
    log.Printf("Backing up %s\n", r.Name)
}

func main() {
    var wg sync.WaitGroup
    defer wg.Wait()

    var repositories []Repository
    repositories = append(repositories, getRepo(1))
    repositories = append(repositories, getRepo(2))
    repositories = append(repositories, getRepo(3))

    for _, r := range repositories {
            if (Repository{}) != r {
                    wg.Add(1)
                    go func(r Repository) {
                            backUp(&amp;r, &amp;wg)
                    }(r)
            }
    }
}
</pre></div><p>
The other primary change in the <tt  >main()</tt> function is
how you call the
<tt  >backUp()</tt> function. Instead of calling this function
directly, you call
it in a new goroutine as follows:

<pre     class="programlisting">

wg.Add(1)
go func(r Repository) {
	backUp(&amp;r, &amp;wg)
}(r)

</pre>
</p><p>
You call the <tt  >Add()</tt> function with an argument 1 to
indicate that you'll be
creating a new goroutine that you want to wait for before you exit. Then,
you define an anonymous function taking an argument,
<tt  >r</tt> of type <tt  >Repository</tt>,
which calls the function <tt  >backUp()</tt> with an additional argument, a reference
to the variable, <tt  >wg</tt>&mdash;the
<tt  >WaitGroup</tt> variable declared earlier.
</p><p>
Consider the scenario where you have a large number of elements
in your repositories list&mdash;a very realistic scenario for this backup
tool. Spawning a goroutine for each element in the repository can
easily lead to having an uncontrolled number of goroutines running
concurrently. This can lead to the program hitting per-process memory
and file-descriptor limits imposed by the operating system.
</p><p>
Thus, you would want to regulate the maximum number of goroutines spawned
by the program and spawn a new goroutine only when the ones executing
have finished. Channels in Golang allow you to achieve this and other
synchronization operations among goroutines. Listing 4 shows how you can
regulate the maximum number of goroutines spawned.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1a23af0"></a></h2></div></div><div class="sidebar"><p class="title"><b>Listing 4. Channels Example</b></p><pre     class="programlisting">
package main

import (
    "log"
    "sync"
)

type Repository struct {
    GitURL string
    Name   string
}

func getRepo(id int) Repository {

    repos := map[int]Repository{
            1:  Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            2:  Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
            3:  Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            4:  Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
            5:  Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            6:  Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
            7:  Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            8:  Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
            9:  Repository{GitURL: "ssh://github.com/amitsaha/gitbackup", 
             &#8618;Name: "gitbackup"},
            10: Repository{GitURL: "ssh://github.com/amitsaha/
            &#8618;lj_gitbackup", Name: "lj_gitbackup"},
    }

    return repos[id]
}

func backUp(r *Repository, wg *sync.WaitGroup) {
    defer wg.Done()
    log.Printf("Backing up %s\n", r.Name)
}

func main() {
    var wg sync.WaitGroup
    defer wg.Wait()

    var repositories []Repository
    repositories = append(repositories, getRepo(1))
    repositories = append(repositories, getRepo(2))
    repositories = append(repositories, getRepo(3))
    repositories = append(repositories, getRepo(4))
    repositories = append(repositories, getRepo(5))
    repositories = append(repositories, getRepo(6))
    repositories = append(repositories, getRepo(7))
    repositories = append(repositories, getRepo(8))
    repositories = append(repositories, getRepo(9))
    repositories = append(repositories, getRepo(10))

    // Create a channel of capacity 5
    tokens := make(chan bool, 5)

    for _, r := range repositories {
            if (Repository{}) != r {
                    wg.Add(1)
                    // Get a token
                    tokens &lt;- true
                    go func(r Repository) {
                            backUp(&amp;r, &amp;wg)
                            // release the token
                            &lt;-tokens
                    }(r)
            }
    }
}
</pre></div><p>
You create a channel of capacity 5 and use it to implement a token
system. The channel is created using <tt  >make</tt>:

<pre     class="programlisting">
tokens := make(chan bool, 5)
</pre>
</p><p>
The above statement creates a &ldquo;buffered channel&rdquo;&mdash;a channel with a
capacity of 5 and that can store only values of type &ldquo;bool&rdquo;. If a
buffered channel is full, writes to it will block, and if a channel is
empty, reads from it will block. This property allows you to implement
your token system.
</p><p>
Before you can spawn a goroutine, you write a boolean value, true into
it (&ldquo;taking&rdquo; a token) and then take it back once you are done with it
(&ldquo;releasing&rdquo; the token). If the channel is full, it means the maximum
number of goroutines are already running and, hence, your attempt to write
will block and a new goroutine will not be spawned. The write
operation is performed via:

<pre     class="programlisting">

tokens &lt;- true

</pre>
</p><p>
After the control is returned from the <tt  >backUp()</tt>
function, you read a
value from the channel and, hence, release the token:

<pre     class="programlisting">

&lt;-tokens

</pre>
</p><p>
The above mechanism ensures that you never have more than five goroutines
running simultaneously, and each goroutine releases its token before it
exits so that the next goroutine may run. The file, listing5.go in the
GitHub repository mentioned at the end of the article uses the runtime
package to print the number of goroutines running using this mechanism,
essentially allowing you to verify your implementation.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1bb6580"></a>
gitbackup&mdash;Backing Up GitHub and GitLab Repositories</h2></div></div><p>
In the example programs so far, I haven't explored using any third-party
packages. Whereas Golang's built-in tools completely support having an
application using third-party repositories, you'll use a tool called
<tt  >gb</tt> for developing your &ldquo;gitbackup&rdquo; project. One main reason I like
<tt  >gb</tt> is how it's really easy to fetch and
update third-party
dependencies via its &ldquo;vendor&rdquo; plugin. It also does away with the need
to have your go application in your <tt  >GOPATH</tt>, a
requirement that the built-in go tools assume.
</p><p>
Next, you'll fetch and build <tt  >gb</tt>:


<pre     class="programlisting">
$ go get github.com/constabulary/gb/...
</pre>
</p><p>
The compiled binary <tt  >gb</tt> is placed in the directory
$GOPATH/bin. You'll
add <tt  >$GOPATH/bin</tt> to the <tt  >$PATH</tt> environment variable and start a new shell
session and type in <tt  >gb</tt>:


<pre     class="programlisting">
$ gb
gb, a project based build tool for the Go programming language.

Usage:

     gb command [arguments]
     ..
</pre>
</p><p>
Next, install the gb-vendor plugin:

<pre     class="programlisting">
$ go get github.com/constabulary/gb/cmd/gb-vendor
</pre>
</p><p>
<tt  >gb</tt> works on the notion of projects. A project has an
&ldquo;src&rdquo; subdirectory
inside it, with one or more packages in their own sub-directories. Clone
the &ldquo;gitbackup&rdquo; project from <a href="https://github.com/amitsaha/gitbackup" target="_self">https://github.com/amitsaha/gitbackup</a>, and
you will notice the following directory structure:

<pre     class="programlisting">
$ tree -L 1 gitbackup
gitbackup
|--src
|  |--gitbackup
	   |--main.go
    	|--main_test.go
    	|--remote.go
    ..
</pre>
</p><p>
The &ldquo;gitbackup&rdquo; application is composed of only a single package,
&ldquo;gitbackup&rdquo;, and it has two program files and unit tests. Let's take a look
at the remote.go file first. Right at the beginning, you import 
third-party repositories in addition to a few from the standard library:
</p><div class="itemizedlist"><ul type="disc"><li><p>
github.com/google/go-github/github: this is the Golang interface to the
GitHub API.
</p></li><li><p>
golang.org/x/oauth2: used to send authenticated requests to the GitHub API.
</p></li><li><p>
github.com/xanzy/go-gitlab: Golang interface to the GitLab API.
</p></li></ul></div><p>
You define a struct of type <tt  >Response</tt>, which matches
the <tt  >Response</tt> structure
implemented by both the GitHub and GitLab libraries above. The struct
<tt  >Repository</tt> describes each repository that you fetch from either GitLab
or GitHub. It has two string fields: GitURL, representing the git clone
URL of the repository, and Name, the name of the repository.
</p><p>
The <tt  >NewClient()</tt> function accepts the service name
(<tt  >github</tt> or <tt  >gitlab</tt>)
as a parameter and returns the corresponding client, which then will be
used to interface with the service. The return type of this function is
<tt  >interface{}</tt>, a special Golang type indicating that this function can
return a value of any type. Depending on the service name specified, it
either will be of type <tt  >*github.Client</tt> or
<tt  >*gitlab.Client</tt>. If a different
service name is specified, it will return nil. To be able to fetch
your list of repositories before you can back them up, you will need to
specify an access token via an environment variable.
</p><p>
The token for GitLab is specified via the
<tt  >GITLAB_TOKEN</tt> environment
variable and for GitHub via the <tt  >GITHUB_TOKEN</tt> environment variable. In
this function, you check if the correct environment variable has been
specified using the <tt  >Getenv()</tt> function from the os package. The function
returns the value of the environment variable if specified and an
empty string if the specified environment variable wasn't found. If
the corresponding environment variable isn't found, you log a message
and exit using the <tt  >Fatal()</tt> function from the log package.
</p><p>
The <tt  >NewClient()</tt> function is used by the
<tt  >getRepositories()</tt> function, which returns a slice of
<tt  >Repository</tt> objects obtained via an API call to
the service. There are two conditional blocks in the function to account
for the two supported services. The first conditional block handles
repository listing for GitHub via the
<tt  >Repositories.List()</tt> function
implemented by the github.com/gooogle/go-github package. The first
argument to this function is the GitHub user name whose repositories
you want to fetch. If you leave it as an empty string, it returns the
repositories of the currently authenticated user. The second argument
to this option is a value of type
<tt  >github.RepositoryListOptions</tt>, which
allows you to specify the type of repositories you want returned via the
<tt  >Type</tt> field. The call to the function
<tt  >Repositories.List()</tt> is as follows:

<pre     class="programlisting">
repos, resp, err := client.(*github.Client)
&#8618;.Repositories.List("", &amp;options)
</pre>
</p><p>
Recall that the <tt  >newClient()</tt> function returns a value
of type <tt  >interface{}</tt>,
which is an empty interface. Hence, if you attempt to make your function
call as <tt  >client.Repositories.List()</tt>, the compiler will complain with an
error message:

<pre     class="programlisting">
# gitbackup
remote.go:70: client.Repositories undefined (type interface {} 
 &#8618;is interface with no methods)
</pre>
</p><p>
So, you need to perform a &ldquo;type assertion&rdquo; through which you get access
to the underlying value of client, which is either of the
<tt  >*github.Client</tt> or
<tt  >*gitlab.Client</tt> type.
</p><p>
You query the list of repositories from the service in an infinite loop
indicated by the <tt  >for</tt> loop:

<pre     class="programlisting">
for {
	// This is an infinite loop
}
</pre>
</p><p>
The function returns three values: the first is a list of repositories,
the second is an object of type <tt  >Response</tt>, and the
third is an error value. If the
function call was successful, the value of <tt  >err</tt> is
nil. You then iterate
over each of the returned objects, create a
<tt  >Repository</tt> object containing
two fields you care about and append it to the slice repositories. Once you
have exhausted the list of repositories returned, you check the
<tt  >NextPage</tt>
field of the <tt  >resp</tt> object to check whether it is equal to 0. If it is
equal to 0, you know there isn't anything else to read; you break from
the loop and return from the function with the list of repositories you
have so far. If you have a non-zero value, you have more repositories,
so you set the <tt  >Page</tt> field in the
<tt  >ListOptions</tt> structure to this value:

<pre     class="programlisting">
options.ListOptions.Page = resp.NextPage
</pre>
</p><p>
The handler for the &ldquo;gitlab&rdquo; service is almost the same as the
&ldquo;github&rdquo; service with one additional detail.
&ldquo;gitlab&rdquo; is an open-source
project, and you can have a custom installation running on your own
host. You can handle it here via this code:

<pre     class="programlisting">
if len(gitlabUrl) != 0 {
    gitlabUrlPath, err := url.Parse(gitlabUrl)
    if err != nil {
        log.Fatal("Invalid gitlab URL: %s", gitlabUrl)
    }
    gitlabUrlPath.Path = path.Join(gitlabUrlPath.Path, "api/v3")
    client.(*gitlab.Client).SetBaseURL(gitlabUrlPath.String())
}
</pre>
</p><p>
If the value in <tt  >gitlabUrl</tt> is a non-empty string, you
assume that you need to
query the GitLab hosted at this URL. You attempt to parse it first using
the <tt  >Parse()</tt> function from the &ldquo;url&rdquo; package and exit with an error
message if the parsing fails. The GitLab API lives at &lt;DNS of gitlab
installation&gt;/api/v3, so you update the <tt  >Path</tt> object of the parsed URL
and then call the function <tt  >SetBaseURL()</tt> of the
<tt  >*gitlab.Client</tt> to set
this as the base URL.
</p><p>
Next, let's look at the main.go file. First though,
you should learn where &ldquo;gitbackup&rdquo; creates the backup of
the git repositories. You can pass the location via the
<tt  >-backupdir</tt>
flag. If not specified, it defaults to $HOME/.gitbackup. Let's
refer to it as <tt  >BACKUP_DIR</tt>. The repositories are backed up in
BACKUP_DIR/gitlab/ or BACKUP_DIR/github. If a repository is not found in
BACKUP_DIR/&lt;service_name&gt;/&lt;repo&gt;, you know you'll have to make a new clone of
the repository (<tt  >git clone</tt>). If the repository
exists, you update it (<tt  >git
pull</tt>). This operation is performed in the
<tt  >backUp()</tt> function in main.go:

<pre     class="programlisting">
func backUp(backupDir string, repo *Repository, wg *sync.WaitGroup) {
    defer wg.Done()

    repoDir := path.Join(backupDir, repo.Name)
    _, err := os.Stat(repoDir)

    if err == nil {
        log.Printf("%s exists, updating. \n", repo.Name)
        cmd := exec.Command("git", "-C", repoDir, "pull")
        err = cmd.Run()
        if err != nil {
            log.Printf("Error pulling %s: %v\n", repo.GitURL, err)
        }
    } else {
        log.Printf("Cloning %s \n", repo.Name)
        cmd := exec.Command("git", "clone", repo.GitURL, repoDir)
        err := cmd.Run()
        if err != nil {
            log.Printf("Error cloning %s: %v", repo.Name, err)
        }
    }
}
</pre>
</p><p>
The function takes three arguments: the first is a string that points
to the location of the backup directory, followed by a reference to a
<tt  >Repository</tt> object and a reference to a
<tt  >WaitGroup</tt>. You set up a deferred
call to <tt  >Done()</tt> on the
<tt  >WaitGroup</tt>. The next two lines then check whether
the repository already exists in the backup directory using the
<tt  >Stat()</tt>
function in the os package. This function will return a nil error value
if the directory exists, so you execute the <tt  >git pull</tt> command by
using the <tt  >Command()</tt> function from the exec package. If the directory
doesn't exist, you execute a <tt  >git clone</tt> command instead.
</p><p>
The <tt  >main()</tt> function sets up the flags for the
&ldquo;gitbackup&rdquo; program:
</p><div class="itemizedlist"><ul type="disc"><li><p>
<tt  >backupdir</tt>: the backup directory. If not specified, it defaults to
$HOME/.gitbackup.
</p></li><li><p>
<tt  >github.repoType</tt>: GitHub repo types to back up; <tt  >all</tt> will back up all
of your repositories. Other options are <tt  >owner</tt>
and <tt  >member</tt>.
</p></li><li><p>
<tt  >gitlab.projectVisibility</tt>: visibility level of GitLab projects to
clone. It defaults to <tt  >internal</tt>, which refers
to projects that can be cloned by any logged in user. Other options
are <tt  >public</tt> and <tt  >private</tt>.
</p></li><li><p>
<tt  >gitlab.url</tt>: DNS of the GitLab service. If you are creating a backup
of your repositories on a custom GitLab installation,
you can just specify this and ignore specifying the &ldquo;service&rdquo; option.
</p></li><li><p>
<tt  >service</tt>: the service name for the Git service from
which you are backing up your
repositories. Currently, it recognizes &ldquo;gitlab&rdquo;
and &ldquo;github&rdquo;.
</p></li></ul></div><p>
In the <tt  >main()</tt> function, if the
<tt  >backupdir</tt> is not specified, you default
to use the $HOME/.gitbackup/&lt;service_name&gt; directory. To find the home
directory, use the package github.com/mitchellh/go-homedir. In
either case, you create the directory tree using the
<tt  >MkdirAll()</tt> function
if it doesn't exist.
</p><p>
You then call the <tt  >getRepositories()</tt> function defined in remote.go
to fetch the list of repositories you want to back up. Limit the
maximum number of concurrent clones to 20 by using the token system I
described earlier.
</p><p>
Let's now build and run the project from the clone of the
&ldquo;gitbackup&rdquo;
repository you created earlier:

<pre     class="programlisting">
$ pwd
/Users/amit/work/github.com/amitsaha/gitbackup
$ gb build
..
$ ./bin/gitbackup -help
Usage of ./bin/gitbackup:
  -backupdir string
        Backup directory
  -github.repoType string
    	Repo types to backup (all, owner, member) (default "all")
  -gitlab.projectVisibility string
    	Visibility level of Projects to clone (default "internal")
  -gitlab.url string
    	DNS of the GitLab service
  -service string
    	Git Hosted Service Name (github/gitlab)
</pre>
</p><p>
Before you can back up repositories from either GitHub or GitLab, you
need to obtain an access token for each. To be able to back up
a GitHub repository, obtain a GitHub personal access
token from <a href="https://github.com/settings/tokens/new" target="_self">https://github.com/settings/tokens/new</a> with only
the &ldquo;repo&rdquo;
scope. For GitLab, you can get an access token from https://&lt;location of
gitlab&gt;/profile/personal_access_tokens with the &ldquo;api&rdquo; scope.
</p><p>
The following command will back up all repositories from github:

<pre     class="programlisting">
$ GITHUB_TOKEN=my$token ./bin/gitbackup -service github
</pre>
</p><p>
Similarly, to back up repositories from a GitLab installation to a
custom location, do this:

<pre     class="programlisting">
$ GITLAB_TOKEN=my$token ./bin/gitbackup -gitlab.url 
 &#8618;git.mydomain.com -backupdir /mnt/disk/gitbackup
</pre>
</p><p>
See the README at <a href="https://github.com/amitsaha/gitbackup" target="_self">https://github.com/amitsaha/gitbackup</a> to learn more,
and I welcome improvements to it via pull requests. In the time between the
writing of this article and its publication, gitbackup has changed a bit. The code
discussed in this article is available in the tag <a href="https://github.com/amitsaha/gitbackup/releases/tag/lj-0.1" target="_self">https://github.com/amitsaha/gitbackup/releases/tag/lj-0.1</a>. To learn about
the changes since this tag in the current version of the repository, see my blog
post at <a href="http://echorand.me/notes-on-using-golang-to-write-gitbackup.html" target="_self">echorand.me/notes-on-using-golang-to-write-gitbackup.html</a>.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1bbaf08"></a>
Conclusion</h2></div></div><p>
I covered some key Golang features in this article and applied them
to write a tool to back up repositories from GitHub and GitLab. Along the
way, I explored
interfaces, goroutines and channels, passing command-line arguments
via flags and working with third-party packages.
</p><p>
The code listings discussed in the article are available at
<a href="https://github.com/amitsaha/lj_gitbackup" target="_self">https://github.com/amitsaha/lj_gitbackup</a>. See the Resources
section 
to learn more about Golang, GitHub and the GitLab API.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1bbb0c0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
Getting Started with Golang and gb: <a href="http://bit.ly/2lKEJJm" target="_self">bit.ly/2lKEJJm</a>
</p><p>
Golang by Example: <a href="https://gobyexample.com" target="_self">https://gobyexample.com</a>
</p><p>
Golang Type Assertions: <a href="https://golang.org/doc/effective_go.html#interface_conversions" target="_self">https://golang.org/doc/effective_go.html#interface_conversions</a>
</p><p>
GitHub Repos API: <a href="https://developer.github.com/v3/repos" target="_self">https://developer.github.com/v3/repos</a>
</p><p>
GitLab Projects API: <a href="https://docs.gitlab.com/ce/api/projects.html" target="_self">https://docs.gitlab.com/ce/api/projects.html</a>
</p><p>
Golang Interface for GitHub: <a href="https://github.com/google/go-github" target="_self">https://github.com/google/go-github</a>
</p><p>
Golang Interface for GitLab: <a href="https://github.com/xanzy/go-gitlab" target="_self">https://github.com/xanzy/go-gitlab</a>
</p><p>
gb: <a href="https://getgb.io" target="_self">https://getgb.io</a>
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1530580.0x1bbb7f8"></a></h2></div></div><div class="sidebar"><p class="title"><b></b></p><p>Send comments or feedback via <a href="http://www.linuxjournal.com/contact" target="_self">www.linuxjournal.com/contact</a> or to
<a href="mailto:info@linuxjournal.com">info@linuxjournal.com</a>.
</p></div></div></div>
<div class="authorblurb"><p>
Amit Saha is a software engineer and the author of <span   class="emphasis"><em>Doing Math with
Python</em></span> (No Starch Press). He blogs at <a href="http://echorand.me" target="_self">echorand.me</a> and can be
reached via email at <a href="mailto:amitsaha.in@gmail.com">amitsaha.in@gmail.com</a>.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../279/toc279.html">Issue Table of Contents</a>
    <a class="link3" href="../279/12160.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>