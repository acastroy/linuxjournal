<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
At the Forge</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;An attractive, new language that makes JavaScript&#10;programming fun and easy.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x1c97580.0x1d8eac0"></a>
At the Forge</h1></div><div><h3 class="subtitle"><i>
Introducing CoffeeScript
</i></h3></div><div><div class="author"><h3 class="author">
Reuven
 M. 
Lerner
</h3></div><div class="issuemoyr">Issue #208, August 2011</div></div><div><p>
An attractive, new language that makes JavaScript
programming fun and easy.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d8f300"></a></h2></div></div><p>
For many years, JavaScript had a bad reputation among developers.
Sure, we would use it when we needed to do something dynamic in the
browser, but we also would avoid it as much as possible. As I (and
others) have written numerous times in the past year, however,
JavaScript is going through a multidimensional renaissance. It
executes quickly, and it increasingly is standardized and stable across
browsers and implementations. You can use it in the traditional role
of browser-side applications, either by itself or using a framework,
such as jQuery. You even can build entire MVC applications in the
browser using systems like Backbone.js, as I described in this
space the past two months. And on the server, you can use
node.js to create high-performance applications.
</p><p>
It's great that JavaScript has improved in many ways. At the same
time, the language contains many legacy issues&mdash;not in terms of
capabilities, but in terms of the syntax and grammar. You can do
great things with JavaScript, but it's easy to write code that has
unexpected side effects, whose variables don't have the scope you
expect, or whose functions operate just differently enough from your
intention to cause problems.
</p><p>
(Another thing that hasn't improved is its name and the fact that
although everyone calls it &ldquo;JavaScript&rdquo;, it's officially known as
&ldquo;ECMAScript&rdquo;, named for the standards body that approved it.)
</p><p>
One of the more interesting solutions to this problem has been the
introduction of languages that are supersets of JavaScript. One of
the best-known examples is Objective-J, which bolts an
Objective-C-like syntax, object structure and class library onto
JavaScript. The Cappuccino framework for in-browser MVC applications
is written in Objective-J and provides a programming experience
similar to that of the Cocoa platform for the Macintosh. Another
solution has been to run a preprocessor on JavaScript code, as in the
case of Google Closure. Closure compiles JavaScript into JavaScript,
but in so doing, optimizes and minimizes your JavaScript code.
</p><p>
Another approach, taken by Jeremy Ashkenas (who, incidentally, also
created the Backbone.js framework) was to create an entirely new
language that compiles into JavaScript. This language, which he
called CoffeeScript, is not designed to be run directly (although you
can do so, with the right tools). Rather, CoffeeScript code is
compiled into JavaScript code, which then is executed.
</p><p>
Why would you want to compile a program into JavaScript? First,
because modern JavaScript engines are quite speedy. Compiling to
JavaScript ensures that the execution will be fast, and that it will
work on a wide variety of platforms and in many contexts&mdash;similar in
many ways to the growing number of languages (for example, Clojure and Scala)
that compile to JVM bytecodes. Second, if you can compile into
JavaScript, you can take advantage of the libraries and frameworks
that already work with JavaScript.
</p><p>
The other reason to use a language other than JavaScript, but that
compiles into JavaScript, is that you can use a syntax that's more
accessible and less prone to errors. I'm a longtime user of both
Ruby and Python, and I found that CoffeeScript incorporated many of my
favorite features from both languages to create a language with
easy-to-understand syntax and powerful features. If you know Ruby,
Python and JavaScript, you'll likely be able to learn this
language in a relatively short time period.
</p><p>
Now, it's true that CoffeeScript has been around for about 18 months
at the time of this writing, and that it already has attracted a number of
fans. But, several events have made it even more interesting during the
past few months. First, Brendan Eich, Mozilla's CTO and the
inventor of JavaScript, said earlier this year that CoffeeScript may
well provide some useful syntax ideas for the next version of
JavaScript, known as &ldquo;Harmony&rdquo;. Douglas Crockford, well known for his
ideas, writing and lectures about JavaScript, apparently has lent his
support to CoffeeScript as well.
</p><p>
Even more significant, from my perspective, is that the Ruby on
Rails core team has announced that CoffeeScript will be a standard
part of Rails, starting with version 3.1. (Version 3.1 also will feature
jQuery as the standard framework, replacing Prototype, and
the incorporation of SASS, a CSS macros language.) I'm not going to
explore the details of CoffeeScript and Rails here, but the fact that
a large, growing, active and influential Web framework is adopting
CoffeeScript will give JavaScript language architects like Eich a
chance to see how it works &ldquo;in the wild&rdquo; and gather feedback from
developers before deciding what will (and won't) go into the next
version of JavaScript.
</p><p>
So, this month, I want to introduce some of the basics of
CoffeeScript. I must admit I was skeptical of learning yet
another new language, especially one that compiles into JavaScript.
But after a bit of playing and experimentation, I
see why people are so excited about it. Just where CoffeeScript will
be in another few years remains to be seen, but it's certainly a
useful tool to have right now, particularly if you're working on Web
applications whose code has become increasingly twisted and complex
with JavaScript functions.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d8f988"></a>
Installing and Running</h2></div></div><p>
You can download and install CoffeeScript in a number of ways. One method
is to download and compile the source from the GitHub account on which
it is stored and developed. Just say:

<pre     class="programlisting">
git clone http://jashkenas.github.com/coffee-script/
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d8fae8"></a></h2></div></div><p>
and you will have the source on your machine. The CoffeeScript
compiler depends on node.js, so it's not surprising that you also
can download and install it using the node.js package manager, npm:

<pre     class="programlisting">
npm install coffee-script
</pre>
</p><p>
Finally, some Linux packages (of various flavors) exist for
CoffeeScript, for those who would prefer to install it alongside other
packages, with dependencies taken care of.
</p><p>
Once you've installed it, you can involve the interactive command-line
prompt, and start coding at the <tt  >coffee&gt;</tt> prompt.
</p><p>
You can print something immediately, using the built-in console.log
function:

<pre     class="programlisting">
coffee&gt; console.log "Hello, world"
</pre>
</p><p>
What's console.log? It's a built-in function on the &ldquo;console&rdquo;
object&mdash;for example:


<pre     class="programlisting">
coffee&gt; console.log.toString()
console.log.toString()
function () {
  process.stdout.write(format.apply(this, arguments) + '\n');
}
</pre>
</p><p>
As you can see, this lets you take a look at the JavaScript behind the
scenes. If you do the same thing with the &ldquo;console&rdquo; object, you see
something that looks even more like the JavaScript you know and love
(or not):

<pre     class="programlisting">
coffee&gt; console.toString()
console.toString()
[object Object]
</pre>
</p><p>
In some ways, I haven't yet done anything different from standard
JavaScript. JavaScript, after all, is all about functions&mdash;those
that you can pass as parameters, and those that you can execute with
parentheses, much like in Python. You can start to see the differences
as soon as you define a function though:


<pre     class="programlisting">
coffee&gt; hello_world = (name) -&gt; console.log "Hello there, #{name}!"
</pre>
</p><p>
First and foremost, you can see that defining a function in CoffeeScript is
really a variable assignment. The function-definition syntax is still
a bit weird by my standards, using <tt  >-&gt;</tt> to separate the parameters and
body of an anonymous function. Parameters are named in parentheses,
with commas separating them if necessary.
</p><p>
In this particular function body, I'm also using Ruby-style string
interpolation to print the user's name. If you're tired of using + or
a third-party library just to interpolate string values, this is
likely to be a useful feature for you.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d90278"></a>
Basic Syntax</h2></div></div><p>
To execute the function, just give the CoffeeScript REPL
(read-eval-print loop) the name of the function, followed by
parentheses (that is, execution):

<pre     class="programlisting">
coffee&gt; hello_world()
</pre>
</p><p>
CoffeeScript functions return their final value, much as Ruby methods
do. In the case of this hello_world function, that means the
function is returning &ldquo;undefined&rdquo;. You can make that a bit better by
having the function return the string, rather than print it:


<pre     class="programlisting">
coffee&gt; hello_world = (name) -&gt; "Hello there, #{name}!"
</pre>
</p><p>
Then, you can say:

<pre     class="programlisting">
coffee&gt; console.log hello_world('Reuven')
Hello there, Reuven!
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d905e8"></a></h2></div></div><p>
or:

<pre     class="programlisting">
coffee&gt; hello_world('Reuven')
'Hello there, Reuven!'
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x1d90748"></a></h2></div></div><p>
depending on whether you want to get the string back or just print it
to the console.
</p><p>
CoffeeScript provides the basic JavaScript data types, but it adds a
great deal of syntactic sugar, as well as additional methods, that
make those data types easier to deal with. For example, CoffeeScript
uses Python-style triple-quoted strings.
</p><p>
The &ldquo;existential&rdquo; operator, a question mark (?), allows you to
determine whether a variable contains something other than null or
undefined values. This is better than just checking for the truth of
a value, which will lead to (literal!) false negatives if a value
contains 0 or the empty string. For example:

<pre     class="programlisting">
v = 0

if v
    console.log "yes"
else
    console.log "no"

if v?
    console.log "yes"
else
    console.log "no"
</pre>
</p><p>
The above code example shows how CoffeeScript implements if/else
control blocks. There also is an &ldquo;unless&rdquo; operator, which (as you
might expect) inverts the output from <tt  >if</tt>. CoffeeScript also
provides postfix &ldquo;if&rdquo; and &ldquo;unless&rdquo;
statements&mdash;something you might
recognize from Perl and Ruby.
</p><p>
You also can see another element of CoffeeScript above, this one taken
from Python. Whitespace and indentation are significant, and allow you
to remove much of the curly braces and begin/end of many other
languages. Unlike Python, however, colons aren't necessary after the
&ldquo;if&rdquo; and &ldquo;else&rdquo; statements.
</p><p>
CoffeeScript arrays are like JavaScript arrays, but with all sorts of
nice syntax added. Want a ten-element array? Just use this:

<pre     class="programlisting">
a = [0..9]
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x2189020"></a></h2></div></div><p>
and you'll get it, using the built-in &ldquo;range&rdquo; operator. (This doesn't
work for letters though.) You can retrieve ranges as well:

<pre     class="programlisting">
a[5..7]
</pre>
</p><p>
You can assign to a range, without worrying about the precise length
of what you're splicing in:

<pre     class="programlisting">
a[5..7] = ['a', 'b']
</pre>
</p><p>
You also can retrieve substrings using this syntax:

<pre     class="programlisting">
coffee&gt; alphabet[5..10]
alphabet[5..10]
'fghijk'
</pre>
</p><p>
CoffeeScript strings, like JavaScript strings, are immutable. Thus, you
cannot assign to a substring:

<pre     class="programlisting">
coffee&gt; alphabet[5..10] = [5]
alphabet[5..10] = [5]
[ 5 ]

coffee&gt; alphabet
alphabet
'abcdefghijklmnopqrstuvwxyz'
</pre>
</p><p>
JavaScript objects, which can be used like hashes (aka
&ldquo;dictionaries&rdquo;
or &ldquo;associative arrays&rdquo;) work just as they do in JavaScript, but with
some easier syntax. For example, in JavaScript, you would write:

<pre     class="programlisting">
person = {
first_name: 'Reuven',
last_name: 'Lerner'
}
</pre>
</p><p>
In CoffeeScript, you can say:

<pre     class="programlisting">
person =
    first_name: 'Reuven'
    last_name: 'Lerner'
</pre>
</p><p>
Once again, using Python-style indentation instead of curly braces
makes it more compact but no less readable.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x2189650"></a>
Loops and Comprehensions</h2></div></div><p>
You can loop through arrays with for..in:

<pre     class="programlisting">
for number in a
    console.log number
</pre>
</p><p>
I should point out that this will print each number on a line by
itself and will return an array of undefined values (because
console.log doesn't return a value, and &ldquo;for&rdquo; returns an array).
</p><p>
Objects can be accessed using the similar for..of loop:

<pre     class="programlisting">
for key, value of person
  console.log "key = '#{value}'"
</pre>
</p><p>
Note that for..of loops work on any JavaScript object. Because every
object can contain properties, and because arrays are objects, you 
even can assign properties to arrays:

<pre     class="programlisting">
a.foo = 'bar'
</pre>
</p><p>
Using a for..in loop, you'll continue to see the values in the
&ldquo;a&rdquo;
array. But using a for..of loop, you'll get not only the array
elements (whose keys are the indexes), but also &ldquo;foo&rdquo;.
Additionally, note that
if you're interested only in the properties defined on an object,
rather than on its prototype, you can add the &ldquo;own&rdquo; keyword:

<pre     class="programlisting">
for own key, value of person
  console.log "key = '#{value}'"
</pre>
</p><p>
In this particular case, there will be no difference. But if
&ldquo;person&rdquo; were
to have a prototype, and if the prototype were to have keys of its own,
you would see the prototype's keys and values, and not just those for
the &ldquo;person&rdquo; object.
</p><p>
But the need for these for..in and for..of loops is reduced
dramatically in CoffeeScript because of comprehensions, an idea that
comes from Python that takes some getting used to, but that offers
a great deal of power and simplicity once you do so, allowing you to
combine map, reduce and filter in a single statement. For example,
you can take a list of numbers:


<pre     class="programlisting">
coffee&gt; a = [100..110]
[ 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110 ]
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x2189d88"></a></h2></div></div><p>
And you then can multiply each number by 5, much as you would do with
&ldquo;map&rdquo;
in Ruby or Python, but using &ldquo;comprehension&rdquo; syntax:


<pre     class="programlisting">
coffee&gt; i*5 for i in a
[ 500, 505, 510, 515, 520, 525, 530, 535, 540, 545, 550 ]
</pre>
</p><p>
You also can select out some values. Suppose, for example, you 
want to operate only on those elements that are odd. You can say:

<pre     class="programlisting">
coffee&gt; i*5 for i in a when i%2
[ 505, 515, 525, 535, 545 ]
</pre>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x218a0a0"></a>
Objects</h2></div></div><p>
As I wrote above, everything in JavaScript (and, thus, in CoffeeScript)
is an object, and every object has properties. (Another way to think
about this is to say that everything in JavaScript is a hash, with
key-value pairs.) Understanding and working with this can be a bit
confusing at first, particularly because of the way the
&ldquo;this&rdquo; keyword operates. CoffeeScript offers several solutions to
this problem, as well as the scoping and variable issues that drive
JavaScript programmers crazy.
</p><p>
First, scoping of all variables is lexical and is obvious from
the indentation. You can attach variables to the global object, or
other objects, but you will end up doing this only when you want, not
by mistakenly forgetting to add a &ldquo;var&rdquo; somewhere.
</p><p>
Second, properties can be accessed and assigned to as if they were
variables, using Ruby-style @varname syntax. So, when you say
<tt  >x=5</tt> in a
CoffeeScript program, you're assigning the value 5 to the lexical
value x. When you say <tt  >@x=5</tt> though, you're assigning the value 5 to
the property x on the current object.
</p><p>
Finally, &ldquo;this&rdquo; is scoped dynamically in JavaScript, changing value to
reflect the object to which the current function is attached. This
means that if you aren't careful, you can write callback functions
that reference &ldquo;this&rdquo;, but accidentally end up referring to the wrong
object. CoffeeScript lets you define functions not only with
<tt  >-&gt;</tt> (the
&ldquo;thin arrow&rdquo;), but also with <tt  >=&gt;</tt> (the
&ldquo;fat arrow&rdquo;). The difference is
that when you define functions with <tt  >=&gt;</tt>, they are bound to the value of
&ldquo;this&rdquo; when it was defined, allowing access to the defining context's
properties using @propname syntax.
</p><p>
All of these things come together in CoffeeScript's object model,
which extends JavaScript's such that you can work with something
resembling a traditional class-instance model, rather than the
built-in, JavaScript-style prototype-based model. Prototypes still
exist and work&mdash;and indeed, CoffeeScript's classes compile into
JavaScript prototypes. But, you can get beyond prototype-style
inheritance by declaring classes with a constructor. Here is a simple
example of the sort of thing you can do:


<pre     class="programlisting">
class Person
    constructor: (firstName='NoFirst', lastName='NoLast') -&gt;
        @firstName = firstName
        @lastName = lastName
        Person.count++

    @count: 0

p1 = new Person()
console.log p1
console.log Person.count

p2 = new Person('Reuven')
console.log p2
console.log Person.count

p3 = new Person('Reuven', 'Lerner')
console.log p3
console.log Person.count
</pre>
</p><p>
When you run the above file, you get the following output:

<pre     class="programlisting">
{ firstName: 'NoFirst', lastName: 'NoLast' }
1
{ firstName: 'Reuven', lastName: 'NoLast' }
2
{ firstName: 'Reuven', lastName: 'Lerner' }
3
</pre>
</p><p>
This not only shows how you can use CoffeeScript classes in a way
similar to traditional classes, but also that you can have default
values for function parameters by declaring their values before the
<tt  >-&gt;</tt>
sign. You also can see how naturally the use of the @propname syntax
fits into this object model. The above constructor looks almost like a
Ruby method, rather than a JavaScript one, with a clear distinction
between local variables and instance variables.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x218a990"></a>
Conclusion</h2></div></div><p>
CoffeeScript is an attractive, new language that makes JavaScript
programming fun and easy. You can think of it as JavaScript with a
new syntax or as an easy-to-learn language that integrates into
JavaScript applications, with many ideas taken from Python and Ruby.
It removes many of the syntactic bloat and issues associated with
traditional JavaScript, simultaneously providing a language that's
easier to write and maintain, but also faster to execute, than raw,
unoptimized JavaScript. CoffeeScript is a language we all should 
watch in the coming months and years. It probably won't replace
JavaScript altogether, but it definitely will make it easier to
accomplish certain tasks.
</p><p>
Next month, I'll look at how CoffeeScript can be integrated into your
browser-side Web applications, especially those using jQuery. That's
the direction the Ruby on Rails community seems to be moving
toward with its 3.1 release, and even if your favorite framework
doesn't adopt CoffeeScript, understanding how they work together 
probably will be useful.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x1c97580.0x218aaf0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
The home page for CoffeeScript, including documentation, quick
references, FAQs and annotated source code, is at
<a href="http://jashkenas.github.com/coffee-script" target="_self">jashkenas.github.com/coffee-script</a>. There is an active and
growing community of CoffeeScript users, with an IRC channel
(#coffeescript) and Wiki at GitHub.
</p><p>
For a good introduction to CoffeeScript, see the presentation written by
Jacques Crocker, available at
<a href="http://coffeescript-seattlejs.heroku.com" target="_self">coffeescript-seattlejs.heroku.com</a>.
</p><p>
Finally, the Pragmatic Programmers have released (at the time of this writing)
an excellent pre-release &ldquo;beta book&rdquo;, written by active CoffeeScript
user Trevor Burnham. If you're interested in learning more about this
interesting little language, I highly recommend this book. It's
mostly aimed at beginners, but given the limited number of advanced
CoffeeScript programmers out there, this should not bother you.
</p></div></div></div>
<div class="authorblurb"><p>
Reuven M. Lerner is a longtime Web developer, architect and trainer.
He is a PhD candidate in learning sciences at Northwestern University,
researching the design and analysis of collaborative on-line
communities. Reuven lives with his wife and three children in
Modi'in, Israel.

</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../208/toc208.html">Issue Table of Contents</a>
    <a class="link3" href="../208/11078.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>