<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>That's Vimprovement! A Better vi</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    Be a better editor&mdash;try Vim.&#10;    "><meta name="keywords" content="Vim, macro, editor, text"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x29cc580.0x2ac3ab0"></a>That's Vimprovement! A Better vi</h1></div><div><div class="author"><h3 class="author">Steve Oualline</h3></div><div class="issuemoyr">Issue #82, February 2001</div></div><div><p>
    Be a better editor&mdash;try Vim.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac45b0"></a></h2></div></div><p>The Linux system comes with a vi clone
called Vim. However, this editor can do more than just mimic vi. It
has literally hundreds of additional functions, including commands
for a help system, multiple windows, syntax coloring, program
compilation and error corrections, advanced searching and many
more.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac46b8"></a>Getting Started</h2></div></div><p>By default, Vim starts in vi-compatibility mode. This means
that many of the advanced features are turned off. To turn on these
Vim improvements you need to create a $HOME/.vimrc file.</p><p>Listing 1 contains a sample .vimrc file. You can also create
one by copying your .exrc file if you have one. A zero length file
works as well.</p><p><a href="4424l1.html" target="_self">Listing 1. Sample
.vimrc</a></p><p>There are two flavors of the Vim editor. The command
<span   class="bold"><b>vim</b></span> starts the console version of
the editor. In this version, you edit inside the terminal window in
which you executed the command. The
<span   class="bold"><b>gvim</b></span> command creates its own
window. This second command is preferred because you get features,
such as a command menu and toolbar, not found on the console
version.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac49d0"></a>Help</h2></div></div><p>One of the most useful innovations that Vim has is the
on-line, integrated help.</p><p>
<div       class="mediaobject"><a href="4424f1.large.jpg"><img src="4424f1.jpg"></a><div class="caption"><p>Figure 1. Vim Help Window</p></div></div>
</p><p>The <b  >:help</b> command displays a help window.
For specific help <b  >:help /</b> displays the help text
for the search (/) command (see Figure 1).</p><p>You can move through this text using the normal editing
commands, such as h, j, k, l, &lt;Page-Up&gt;, &lt;Page-Down&gt;,
etc.</p><p>As you scroll through the text, you'll see some lines that
look like</p><pre     class="programlisting">
/&lt;CR&gt; Search forward for the [count]'th latest used
  pattern |last-pattern| with latest used |{offset}|.
</pre><p>The text enclosed in vertical bars (|) is a Vim hyperlink.
Position the cursor over one of these items (say |last-pattern|)
and press CTRL-]. This will make the screen jump to the given
subject.
</p><p>To go back to where you were before the jump, use the command
CTRL-T.</p><p>To get out of the help system, use the normal Vim exit
commands :q or ZZ.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac5000"></a>Creating a File</h2></div></div><p>To see how some of the new Vim commands can help you, start
by creating a simple program file containing the following
text:</p><pre     class="programlisting">
#include "even.h"
int even(int value)
{
  if (value &amp; 1) == 1)       // Deliberate mistake
      return (1);
  return (0);
}
</pre><p>The first thing to notice is the changing colors of the text.
This is called syntax highlighting. Each component of a program
(keyword, string, constant, preprocessor directive, etc.) gets a
different color. In our initialization file, this was enabled by
the <b  >:syntax on</b> command. If you do a
<b  >:syntax off</b>, the highlighting disappears.
</p><p>The next thing to note as you type in the file is that you
don't have to do any indenting. All the lines are automatically
indented for you. This is because of the <b  >cindent</b>
option being turned on by the magic lines:</p><pre     class="programlisting">
:autocmd FileType c,cpp     :set cindent
</pre><p>This applies to C and C++ files only. (Unfortunately a full
discussion of autocommands is beyond the scope of this article. You
can do a <b  >:help autocmd</b> for full instructions.)
</p><p>Note: The actual commands in the sample .vimrc file are a
little more fancy than the ones presented in this section, but they
do the same thing.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac5478"></a>Undo/Redo</h2></div></div><p>Now, let's have a little fun. Position the cursor on the
&ldquo;r&rdquo; of one of the return statements and type xxxxxx. The return
disappears. Now type &ldquo;u&rdquo; to undo the last change. The &ldquo;n&rdquo;
returns.</p><p>The old vi editor had only one level of undo. Vim has many.
Type &ldquo;u&rdquo; again, and notice that you've got &ldquo;rn&rdquo; back. Type
&ldquo;u&rdquo; four more times and the whole word returns.</p><p>So how do you undo an undo? Through the new &ldquo;redo&rdquo;
command:<b  >' CTRL-r</b>. By typing this a couple of
times, you redo the delete, which causes parts of &ldquo;return&rdquo; to
disappear.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac5688"></a>Multiple Windows</h2></div></div><p>Now that you have a C file, you should create a header. It
would be nice to be able to copy and paste the prototype from the C
file into the header. With vi you couldn't do this. With Vim, it's
easy.</p><p>First, bring up both files in the editor. The command
<b  >:split even.h</b> splits the current window in two.
The top-half gets the file even.h, and the bottom even.c (see
Figure 2).</p><p>
<div       class="mediaobject"><a href="4424f2.large.jpg"><img src="4424f2.jpg"></a><div class="caption"><p>Figure 2. Multiple Windows</p></div></div>
</p><p>To move the cursor from the top window to the bottom window
use the command <b  >CTRL-Wj</b>. To move up a window,
use the command <b  >CTRL-Wk</b>.</p><p>To close a window, use the <b  >ZZ</b> or
<b  >:quit</b> command.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ac5c60"></a>Copy and Paste Using Visual Mode</h2></div></div><p>Vim has one new major mode: visual mode. In visual mode,
highlight the text you want to edit, then type an editing command.
In this example, you need to copy the first line of the function
<b  >even</b> from the bottom window and paste it in the
top window.</p><p>Start by sending the cursor to the bottom window
(<b  >CTRL-Wj</b>) and positioning it on the first line
of the function <b  >even</b>. Next, enter line visual
mode by typing the <b  >V</b> command. The current line
is highlighted, which indicates that this line will be affected by
any editing command you type. At this point you can use the cursor
commands to move the cursor down a few lines. As you move the
cursor, the text that you pass over is highlighted. Move the cursor
up, and it's unhighlighted. Go past the starting point, and the
text above will be highlighted.</p><p>Highlighting is done on a line-by-line basis. That's because
you've entered visual line mode. If you had typed
<b  >v</b>, for character visual mode, you could
highlight text on a character by character basis. Finally, there is
block visual mode (<b  >CTRL-V</b>) that highlights a
rectangle on the screen. This is good if you are working with text
tables because you can manipulate columns of figures on the
screen.</p><p>Now, to copy a single line from the bottom window to the top
one, use line visual mode (V) and highlight that line. Then use the
yank <b  >y</b> command to copy it into the unnamed
register. Next go to the top window and do a <b  >p</b>
to put (paste) the text into the top window. All you need to do now
is add a &ldquo;;&rdquo; to the end of the line and you have an even header.
Figure 3 shows these commands in action.</p><p>
<div       class="mediaobject"><a href="4424f3.large.jpg"><img src="4424f3.jpg"></a><div class="caption"><p>Figure 3. Copying a Line</p></div></div>
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ebe590"></a>Compiling the Program</h2></div></div><p>In order to compile our program we need a Makefile. (This
exercise is left to the reader.)</p><p>Once our Makefile is in place we use Vim's integration with
make to compile the program. All we need to do is issue the
<b  >:make</b> command from within Vim and the editor
will run make and capture the output.</p><p>Our program contains an error:</p><pre     class="programlisting">
even.c:4: parse error before `=='
</pre><p>Vim captures the output of the <b  >:make</b>
command and parses it. From this it can see that we have an error
on line 4 of even.c, so it moves the cursor to this line and
displays the error message at the bottom of the screen. (It will
even switch files if it has to in order to locate the error.)
</p><p>This makes it easy to fix the error. To see the next error,
issue the <b  >:cn</b> command. If you want to see the
current error again, use the <b  >:cc</b> command. The
previous <b  >:cp</b>. Finally, if you're done editing
this file and want to see the first error in the next file use the
<b  >:cnf</b> command.</p><p>Vim is smart regarding the location of errors. When you add
or delete lines at the start of the file, Vim adjusts the location
of errors at the end of the file to reflect these changes. This
avoids the problem you have with conventional editors like vi,
where fixing an error at the start of a file throws off the line
numbers for the rest of the file.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ebeab8"></a>Finding out Where a Function Is Used</h2></div></div><p>The grep command is great for finding out where a function is
used and defined. Simply enter the command:</p><pre     class="programlisting">
$ grep -n even *.c
</pre><p>and you get a printout of each line that contains the word
even.
</p><p>Vim has a <b  >:grep</b> command that does the same
thing. Actually this command is very similar to the
<b  >:make</b> command. It runs grep, captures the output
and lets you navigate through the files using
<b  >:cn</b>, <b  >:cp</b>,
<b  >:cc</b>, and <b  >:cnf.</b>--just like
<b  >:make</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ebef30"></a>Fixing Indentation</h2></div></div><p>If you turn on the cindent option, Vim will indent your
program correctly when you insert new text. But what about the text
that's already there? That's where the <b  >= command</b>
comes in.</p><p>It will run a block of text through Vim's internal
indentation program. (Actually, you can select which program is to
be used for indentation through the equalprog option.)</p><p>Let's see how this can work to indent a basic C statement
block. There are two ways of invoking the <b  >=
command</b>. The first is to use
<b  >={motion}</b>. The second is to enter visual mode,
select a block of text and then press <b  >=</b>.</p><p>So, one way to indent a block of code is to go to the first
&ldquo;{&rdquo; of the block. Now enter <b  >=%</b>. The
<b  >=</b> tells Vim to indent the text from here to
where the next command takes the cursor. The next command in this
case is <b  >%</b>, which tells Vim to go to the matching
&ldquo;}&rdquo;.</p><p>If you wanted to do things using visual mode, you would
position the cursor on the first &ldquo;{&rdquo;, then enter line visual mode
with the <b  >V</b> command. Next position the cursor on
the corresponding &ldquo;}&rdquo; using any set of commands that get you
there. Finally, the highlighted block is indented with the
<b  >= command</b>.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ebf4b0"></a>Searching</h2></div></div><p>Vim has some interesting searching options. The first is the
incremental searching option, which is enabled with the
command:</p><pre     class="programlisting">
:set incsearch
</pre><p>Normally when you do a search, say for include, you would
enter the entire command: <b  >/include&lt;CR&gt;</b> and
Vim would start searching for the string. When incremental
searching is enabled, Vim starts searching when you type the first
character of the search. In other words, when you type
<b  >/i</b>, Vim searches for the first &ldquo;i&rdquo; in the
text. Type the next character &ldquo;n&rdquo;, for /in and Vim looks for
&ldquo;in&rdquo;. As you type each character the search moves on (if needed)
to find the string that you've typed so far.
</p><p>The other major innovation in searching is the highlight
search (hlsearch) option. If this is enabled, then when Vim finds a
string that matches a search, it highlights it. Not only is the
current match highlighted, but all matches are highlighted.</p><p>This is useful if you're searching for a misspelled variable
name or word, because all occurrences of the incorrect word are
highlighted.</p><p>If you want highlighting to temporarily disappear, you can
issue the the <b  >:nohl</b> command. This clears the
highlighting until the next search command is entered.</p><p>Vim also maintains a search history. Let's say you've done a
number of searches. Now press / to start a search, and then the
&lt;UP&gt; key. The previous search is displayed. Press &lt;UP&gt;
again, and you get the next oldest search. Thus using the
&lt;UP&gt; and &lt;DOWN&gt; keys you can scroll through a set of
your recent searches.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ebf8d0"></a>Keyboard Macros</h2></div></div><p>One of the most powerful commands in Vim is the . (dot)
command. It repeats your last edit. But this command is limited. It
will only repeat a single command.</p><p>But what if you have something more complex to do? That's
where Vim's keyboard macros come in. They allow you to record a
series of commands in a register and then execute them.</p><p>To see how this works, let's suppose you have the following
lines that you want to edit:</p><pre     class="programlisting">
stdio.h
time.h
unistd.h
stdlib.h
</pre><p>You want to make each of these into a #include line, e.g.,
<b  >#include &lt;stdio.h&gt;</b>
</p><p>You start by entering the command <b  >qa</b>. This
causes all subsequent commands to be recorded in register a. (Any
register from a to z can be used.)</p><p>Next do the edits. Go to the beginning of the line (^) insert
<b  >#include &lt;</b>, then finish by adding a
<b  >&gt;</b> to the end of the line. Finally go down a
line to be ready for the next edit.</p><p>All these commands are now recorded in the a register. The
<b  >q</b> command tells Vim to stop recording. The text
now looks like:</p><pre     class="programlisting">
#include &lt;stdio.h&gt;
time.h
unistd.h
stdlib.h
</pre><p>with the cursor positioned on the second line. To execute the
macro, use the command <b  >@a</b>. The results are:
<pre     class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
unistd.h
stdlib.h
</pre>


The <b  >@</b> command takes a repeat, so you can finish
off our work using the <b  >2@a</b> command.
<pre     class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</pre>


</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2ec0060"></a>Tags&mdash;A Program's Table of Contents</h2></div></div><p>The command <b  >ctags</b> (which comes with Vim)
can be used to generate a program table of contents for a set of C
files. (This is now a tags file.)</p><p>A typical <b  >ctags</b> command is:</p><pre     class="programlisting">
ctags *.c
</pre><p>This creates a tags file containing the location of all the
functions in the C files in the current directory.
</p><p>Once generated the tags file can be of great use to people
editing with Vim.</p><p>Let's suppose you are editing a file and are looking at the
<b  >read_paragraph</b> function. As you go through the
code you discover that <b  >read_paragraph</b> calls
<b  >read_sentence</b>. You'd like to see what this
function does.</p><p>If you position the cursor on the function name, and press
CTRL-], Vim jumps to the definition of that function. You quickly
discover that <b  >read_sentence</b> calls
<b  >read_word</b>, so you position the cursor over
<b  >read_word</b> and press CTRL-]. Again the editor
jumps to the definition of that function.</p><p>Vim keeps track of where you've been through the use of tag
stack. To see where you are in this list, use the
<b  >:tags</b> command.</p><pre     class="programlisting">
:tags
# TO tag        FROM line  in file/text
1  1 read_sentence       3  read_sentence();
2  1 read_word           8  read_word();
&gt;
</pre><p>In this example, we've gone from <b  >read_word</b>
(not listed), to <b  >read_sentence</b> and then
<b  >read_word</b>. To go back, use the CTRL-T command.
It pops you up one level in the tag stack.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2dd2480"></a>Advanced Tagging</h2></div></div><p>When you jump to a tag using the CTRL-] command, the entire
screen jumps. If you use the command CTRL-W CTRL-], the current
window is split and you do a tag jump in the new window.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2dd2588"></a>Multiple Tags</h2></div></div><p>Suppose you have five or six small programs in a directory,
and you want to jump to the definition of one of the
<b  >main</b> functions. If you do a:</p><pre     class="programlisting">
:tag main
</pre><p>command, the editor will jump to the first definition of
<b  >main</b> that it can find. This may or may not be
the one you want.
</p><p>The <b  >:tselect</b> command displays all the tags
that match a given name and lets you select the one you want. For
example:</p><pre     class="programlisting">
:tselect main
# pri kind tag               file
&gt; 1 F C f    main              a_test.cpp
    int main( int argc, char* argv[] )
2 F   f    main              acp.cpp
    int main( int argc, char* argv[] )
3 F   f    main              add.cpp
    int main(int argc, char* argv[])
Enter nr of choice (&lt;CR&gt; to abort): 3
</pre><p>What if you only know part of a name? In other words, you
want to go to the function whose name is &ldquo;something-
process-something-data&rdquo;. The <b  >:tags</b> command can
take a regular expression. In this case the command:
<pre     class="programlisting">
:tag /process.*data
</pre>


goes to the first tag matching this expression. If several
functions match the expression, you can use
<b  >:tselect</b> to go to the right one.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2dd2a58"></a>Word Wrapping</h2></div></div><p>Programs contain code and comments. Code has its own
structure. You do not want an editor that line wraps when you write
code. But comments are merely text and it's okay to wrap text. In
fact in most cases, it is highly desirable to have an editor that
wraps long text lines.</p><p>The Vim editor understands the difference between commands
and code. It can be configured to wrap comments and leave the code
alone. This is done by putting the following lines in our .vimrc
file:</p><pre     class="programlisting">
:autocmd FileType c,cpp
\     set formatoptions=croql cindent
\     comments=sr:/*,mb:*,ex:*/,://
</pre><p>(Note: continuation lines in *begin* with \.)
</p><p>The <b  >:autocmd</b> command tells Vim that these
commands are to be executed whenever it determines that it is
working on a C or C++ file. (File names ends in .c or .cpp.)</p><p>The <b  >formatoptions</b> tells Vim that we want
to automatically wrap comments but don't want code wrapped. The
next line:</p><pre     class="programlisting">
set comments=sr:/*,mb:*,ex:*/,://
</pre><p>tells Vim what a comment looks like. In this case we've
defined the standard C comment (/*, */) and the C++ comment (//).
We've also told Vim that if we are in the middle of a C-style
comment, to please begin each line with a &ldquo;*&rdquo;.
</p><p>With these options set, when you type /*&lt;RETURN&gt;, Vim
automatically puts in a &ldquo; *&rdquo; to begin the next line. Given the
limited space allowed in this article, all I can really tell you is
that this is a really neat feature, and you should play around with
it. If you need more details, you can check out the on-line help
text.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x29cc580.0x2dd2ed0"></a>Conclusion</h2></div></div><p>Vim is a very versatile editor. In this article we've touched
on a few of the more interesting features of this editor. But we
only scratched the surface. There are still hundreds of commands
and options that we've not discussed. You can find out about these
by reading the help text and other documentation that comes with
the editor.</p><p>By introducing you to some of the new features in Vim we've
given you a start toward more effective editing. How far you go
from here is up to you.</p><p><a href="4424s1.html" target="_self">Sidebar</a></p></div></div>
<div class="authorblurb"><p>
        <div       class="mediaobject"><img src="4424aa.jpg"></div>

        <span   class="bold"><b>Steve
      Oualline</b></span> is the author of Practical C Programming,
      <span   class="emphasis"><em>Practical C++ Programming</em></span> and <span   class="emphasis"><em>Vim
      (Vi Improved)</em></span>. He wrote his first program when he was 11
      years old and has been working in the software industry since then.
      He currently resides in San Diego where he spends his days working
      at Nokia Mobile Phones and his weekends working as a real engineer
      on a small tourist railroad in Poway, California.</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../082/toc082.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>