<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Configuring, Tuning and Debugging Apache</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;     RPMs, mod_perl, apachectl, telnet, mod_status, DSO, apxs, Apache::Status...Scared yet? Mr. Lerner tells us about all of these so we can better manage our web servers.&#10;    "><meta name="keywords" content="Apache, debugging, RPM, web, server, module"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x285a580.0x2951ab0"></a>Configuring, Tuning and Debugging Apache</h1></div><div><div class="author"><h3 class="author">Reuven M. Lerner</h3></div><div class="issuemoyr">Issue #78, October 2000</div></div><div><p>
     RPMs, mod_perl, apachectl, telnet, mod_status, DSO, apxs, Apache::Status...Scared yet? Mr. Lerner tells us about all of these so we can better manage our web servers.
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x2952660"></a></h2></div></div><p>As longtime users know, Linux, Apache and
other free software packages are both more stable and more easily
configured than their closed-source counterparts. However, this
obviously does not mean that free software advocates are immune
from software bugs and configuration problems. And indeed, the
complexity of much open-source software can sometimes be
frustrating; it's often unclear which option to modify, or even
where to begin.
</p><p>This month, we will look at some of the tools and techniques
that webmasters can use when trying to configure, tune and debug
their Apache configurations. This cannot be a comprehensive list,
simply because so many things can go wrong. However, being able to
identify the cause of a problem often makes it relatively easy to
come up with a solution, or at least to begin working toward
one.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x29527c0"></a>Removing RPMs</h2></div></div><p>I have been using Red Hat Linux for about five years, back
from the days in which Red Hat was a small company in Connecticut,
rather than a well-known start-up whose name even my mother
recognizes. During that time, I have become a big fan of RPM, the
Red Hat Package Manager. I still remember when I had to modify
makefiles by hand in order to compile software downloaded from the
Internet; the fact that I can download a binary version of a
program, install it with a single command, and then remove it just
as easily, continues to amaze me. (I'm told that Debian's packaging
system is even more sophisticated, but I have not yet had the
opportunity to try it out.)</p><p>System administrators who learn to love RPMs are often
reluctant to begin compiling programs from source. Not only does
this take more time and more knowledge, but compiling and
installing a program from its source code makes removal difficult,
months or years later. However, there are certain programs that I
insist on compiling from source, despite the inherent
disadvantages. One of these is Apache, which is normally installed
as part of the Red Hat installation.</p><p>Apache itself is a relatively small program. The bulk of the
functionality resides in individual modules which are normally
incorporated into Apache at compile time. So if you want Apache to
automatically correct misspelled URLs, you can include mod_speling
(and no, that isn't a typo) in your compilation. If you will be
running a server without any CGI programs, you can remove mod_cgi.
And the list continues, making it possible to customize Apache
according to your exact needs.</p><p>Thus, I strongly recommend that everyone compile Apache from
scratch. This process is normally quite straightforward, and should
take no more than a few minutes on a typical modern computer. The
first step toward compiling Apache is to remove any RPMs that might
already be on the system, to avoid confusing either the RPM
database or yourself regarding a file's exact origins.</p><p>To remove the Apache RPM from a Red Hat system, use the
following command: <b  >rpm -e apache</b>.</p><p>To get a better idea of what is going on as your disk drive
crunches away, you may turn on the &ldquo;very verbose&rdquo; option:
<b  >rpm -evv apache</b>.</p><p>On most systems, this command will not be sufficient by
itself. RPM keeps track of not only which files are installed, but
also of the dependencies between packages. Since a typical Red Hat
installation includes RPMs for
<span   class="bold"><b>mod_perl</b></span> (which is often broken)
and <span   class="bold"><b>mod_php</b></span>, you may need to erase
these as well:</p><pre     class="programlisting">
rpm -evv apache mod_perl mod_php
</pre><p>If removing a package will break a dependency, RPM will exit
with a fatal error, indicating which dependencies will not be
satisfied if you remove the package in question. You should then
consider whether the package (e.g., mod_perl) is only useful with
another package (e.g., Apache) or if removing it would cause too
many other problems.
</p><p>Once you have removed any existing Apache RPMs, you can begin
to compile and install Apache on your system. (Of course, you can
always compile Apache while the RPM exists, removing the RPM just
before you install the compiled version.) Download the latest
version, which at the time of this writing was 1.3.12, from a local
mirror of
<a href="http://www.apache.org" target="_self">http://www.apache.org/</a>.
Once you have done that, you can unpack it with:</p><pre     class="programlisting">
tar -zxvvf apache_1.3.12.tar.gz
</pre><p>The <b  >z</b> option uncompresses the tar archive
with <b  >gunzip</b> before proceeding, and the
<b  >vv</b> flags ask for &ldquo;very verbose&rdquo; output. Both
of these options work only with GNU tar, which is the standard tar
version on Linux systems.
</p><p>Once you have unpacked the source code, you can compile
Apache with the following commands:</p><pre     class="programlisting">
cd apache_1.3.12  # Switch into the Apache directory
./configure           # Get a default configuration
make                  # Compile the source code
make install          # Install Apache under /usr/local/apache/
</pre><p>The above four steps will place the Apache-related programs
in /usr/local/apache/bin, logfiles in /usr/local/apache/logs, HTML
files in /usr/local/apache/htdocs, and CGI programs in
/usr/local/apache/cgi-bin. The &ldquo;make install&rdquo; command must be
performed while logged in as root.
</p><p>To run Apache, use the
<span   class="bold"><b>apachectl</b></span> program which is
installed by default in /usr/local/apache/bin.
<span   class="bold"><b>apachectl</b></span> is a shell script which
makes it relatively easy to start or stop Apache, ensuring that
only one Apache process will run on a system at a given time. To
start Apache, use:</p><pre     class="programlisting">
/usr/local/bin/apachectl start
You may need to insert this line in one of your startup files, such as
/etc/rc.d/rc.local, to ensure that Apache starts
up when your
computer is booted. This is especially true if you removed the RPM
version of Apache using the above instructions, since the RPM comes
with a startup file that is automatically placed (and invoked) inside of
/etc/rc.d/init.d. <span   class="bold"><b>apachectl</b></span> can also be used to shut down the server:
</pre><pre     class="programlisting">
/usr/local/bin/apachectl stop
</pre><p>One of the first things that Apache does when it starts up is
to look through its configuration file, traditionally called
httpd.conf and located (by default) in /usr/local/apache/conf. This
file contains a number of commands, known as &ldquo;directives&rdquo;,
followed by one or more values. We can thus set the name of the
server explicitly with the directive:
<pre     class="programlisting">
ServerName www.lerner.co.il
</pre>


Each Apache module is allowed to define its own directives which
control the program's behavior when invoking that module. For
example, <span   class="bold"><b>mod_userdir</b></span> installs the
UserDir directive, indicating which directory name should be
treated specially inside of each user's home directory, for the
purposes of creating sites on the Web.
</p><p>But what happens if mod_userdir is not installed? Then Apache
will not know what to do with the UserDir directive, and will exit
with a fatal error. The solution is to run <b  >apache
configtest</b>, which reads httpd.conf and checks it to
ensure that all of the directives are known and have legal values.
If all of the directives have legal definitions, apachectl will
respond with &ldquo;OK&rdquo;.</p><p>Another partial solution to this issue is to put all
module-specific directives inside of an &lt;IfModule&gt; section.
&lt;IfModule&gt; tells Apache that it should pay attention to one
or more directives only if a particular module is actually loaded.
Thus, we can always define our UserDir directive, assuming it is
wrapped in the following section:</p><pre     class="programlisting">
&lt;IfModule mod_userdir.c&gt;
    UserDir public_html
&lt;/IfModule&gt;
</pre><p>&lt;IfModule&gt; is particularly useful when working with
modules compiled as DSOs, because of the flexibility it adds.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x2953528"></a>Using Telnet</h2></div></div><p>Once your Apache server is compiled, installed, configured
and running, you might still encounter some problems.
<b  >apachectl configtest</b> is a good way to ensure
that all of the directives are legal&mdash;but this does not ensure that
they will work, nor that they are the values you really
want.</p><p>A good tool for checking that a server is working in the
right way is <span   class="bold"><b>telnet</b></span>. Telnet is
probably familiar to most Linux users as a way to log into one
computer while sitting at another. However, telnet can open a TCP
connection on any port, not just the default port 23 used for the
&ldquo;telnet&rdquo; protocol. You can thus use telnet for SMTP (port 25),
POP (port 110) and even HTTP (port 80). This is a great way to test
web servers to see if they're running, as well as run some basic
tests.</p><p>The key to this technique is understanding that every TCP/IP
service is associated with an IP address and port on both the
origin and destination computers. Thus, a telnet connection between
two computers will almost certainly include two IP addresses, an
arbitrary port on the client, and the well-known port 23 on the
server. Similarly, an SMTP connection carrying e-mail between two
computers will normally include a connection from an arbitrary port
on the client to port 25 on the server. For a list of well-known
ports, including many that should not be changed without good
reason (such as FTP, SMTP, telnet), look at the standard file
/etc/services on any computer running Linux.</p><p>To use the <span   class="bold"><b>telnet</b></span> program to
connect to an arbitrary port, simply indicate the port number (or
name, if one appears in /etc/services). For example, to connect to
the HTTP server running on port 80 of the computer
www.lerner.co.il, simply say <b  >telnet www.lerner.co.il
80</b>.</p><p>If the server is running on a different port, as defined by
the Apache Listen and Port directives, simply specify a different
number. For example, if the server is running on port 8080, we can
connect to it with <b  >telnet www.lerner.co.il
8080</b>.</p><p>Of course, a single Apache process can handle input on two or
more port numbers, so long as they are specified correctly in
httpd.conf.</p><p>If no server is running on the specified port, then telnet
will exit with a fatal &ldquo;connection refused&rdquo; error. In such a
case, consult the Apache error logs, normally placed in
/usr/local/apache/logs/error_log, to determine the source of the
problem.</p><p>If an HTTP server is indeed running on the specified port,
then telnet will display a message indicating how to exit back into
the telnet command prompt (usually with
<b  >CONTROL-]</b>), and will then connect you. What
prompt you see depends on the type of server to which you connect;
while SMTP, FTP and POP all greet an incoming user with the name of
the server computer, HTTP is unusually silent. The assumption is
that you know the name of the server to which you have connected,
and that the connection was obviously successful.</p><p>At this point, you can issue an HTTP request. The simplest
form of request is <b  >GET /</b>, followed by a single
newline character. This is an HTTP request of the most primitive
sort, which is no longer used but is built into HTTP servers in
order to ensure backward compatibility with older clients. Soon
after pressing <b  >ENTER</b>, you should see the
contents of the root (or &ldquo;index&rdquo;) page of the site to which you
connected. It may be difficult to read the unparsed HTML at first,
but remember that this is a simple debugging method.</p><p>A more sophisticated request uses HTTP/1.0, the first version
of HTTP to include headers in the request and response. The request
and response are each preceded by one or more &ldquo;header&rdquo; lines,
containing a header name, a colon and a text string. The headers
and request/response body are separated by a single blank
line.</p><p>Our simple request can thus be rewritten as <b  >GET /
HTTP/1.0</b>, with the latter part tacked on to indicate that
our client understands a more sophisticated version of HTTP. We
then have to press <b  >ENTER</b> twice&mdash;once to indicate
the end of this line, and a second time to indicate that we don't
want to send any headers between the command line and the body of
the HTTP request.</p><p>You can also submit name-value pairs to the server with
telnet, separating each name from its corresponding value with
&ldquo;=&rdquo;, and each pair with an ampersand. Normally, such arguments
are passed in a GET request to a CGI program or other dynamic
content producer. For example:</p><pre     class="programlisting">
GET /cgi-bin/foo.pl?name1=val1&amp;name2=val2 HTTP/1.0
After pressing <b  >ENTER</b> twice, you should see a set of response
headers, followed by whatever output is produced by the CGI program
<span   class="bold"><b>foo.pl</b></span>.
You can also pass headers along with the request. After pressing
<b  >ENTER</b> following the initial GET line, type one or more
headers, with a new line after each one. For example:
</pre><pre     class="programlisting">
GET /cgi-bin/foo.pl?name1=val1&amp;name2=val2 HTTP/1.0
Accepts: text/html
Accept-language: text/html
Following the final header, press <b  >ENTER</b> twice&mdash;once to finish the
header, and again to indicate that the request is complete.
</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294a808"></a>How Many Servers?</h2></div></div><p>Even moderately popular web sites tend to run more than one
copy of Apache at a time. Older servers would wait until a new
connection came in before deciding whether to &ldquo;fork&rdquo; off a new
copy of the existing server process. The authors of Apache
abandoned this method in favor of &ldquo;pre-forking&rdquo;, meaning that
Apache creates a large number of child processes immediately upon
startup.</p><p>Each child process handles only one HTTP connection at a
given time, meaning that there must always be at least as many
Apache processes running as the number of simultaneous connections
a site should handle. This maximum number is set with the
MaxClients directive, which defaults to 150. If MaxClients is set
too low, then one or more users may end up waiting until an Apache
process finishes handling the previous connection, and is available
to service a new one.</p><p>Apache dynamically changes the number of servers available
depending on the number of requests that it gets, based on hints in
httpd.conf. The MinSpareServers and MaxSpareServers directives tell
Apache how many extra servers to keep around in preparation for
incoming requests. If the number of spare servers ever goes below
MinSpareServers, Apache spawns several new servers. By contrast, if
there are more unused servers than defined in MaxSpareServers,
Apache will kill off the extra ones.</p><p>If the server starts and responds successfully, but is taking
a long time to accept connections, it could be that you have not
told Apache to start enough servers. Try increasing either
MaxSpareServers or MaxClients so that fewer people will have to
wait for a free server to handle their request.</p><p>Of course, adding new servers is a potentially large drain on
the computer's resources, consuming more CPU time and memory.
<span   class="bold"><b>mod_perl</b></span> is a particularly large
user of memory; so you should be more conservative when adding new
Apache processes that include mod_perl. Use the standard Linux
<span   class="bold"><b>free</b></span> command, which displays the
amount of available physical and virtual memory, to get a better
understanding of where the memory is going. I also like to use
<span   class="bold"><b>top</b></span>, which displays, among other
things, the amount of CPU and memory each process is
consuming.</p><p>Because web servers need to respond to requests as quickly as
possible, and because virtual memory is far slower than physical
RAM, you should pay particularly close attention to virtual memory
usage and minimize its use.</p><p>Small web sites that run one or more database servers (such
as MySQL or PostgreSQL) on the same computer as a web server can
find themselves in an unenviable bind. As the number of visitors to
a dynamically generated site increases, the number of Apache
processes must also increase. But in order to service all of these
visitors, the number of database connections must also increase. At
a certain point, a site becomes a victim of its own success, with
the database and web site competing for system resources. For this
reason, most popular database-backed sites separate the two
functions onto at least two computers, with one or more database
servers connected to one or more HTTP servers.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294ac28"></a>mod_status</h2></div></div><p>One nice way to get a snapshot of the current Apache status
is with the <span   class="bold"><b>mod_status</b></span> module.
<span   class="bold"><b>mod_status</b></span> describes the current
state of every HTTP server, whether it is waiting for a new
connection, reading the request, handling the request or writing a
response.</p><p><span   class="bold"><b>mod_status</b></span> is compiled into
Apache by default, meaning that all you need to do in order to
activate it is to set the appropriate directives, and set the
default handler, or request-handling subroutine, to be
&ldquo;server-status&rdquo;. Any URL defined to have a handler of
&ldquo;server-status&rdquo; then produces a status listing, ignoring the rest
of the user's request.</p><p>It is thus most common for mod_status to be activated for
only one URL. For example, we can create the virtual
&ldquo;/server-status&rdquo; URL on our web server, such that anyone visiting
/server-status will be shown the output from mod_status. We also
indicate that Apache should always produce a full status listing,
rather than the simple version. Here is one such simple
configuration:</p><pre     class="programlisting">
&lt;Location /server-status&gt;
    SetHandler server-status
&lt;/Location&gt;
ExtendedStatus On
</pre><p>Once I put those four lines inside of httpd.conf and restart
Apache&mdash;or send it a HUP signal&mdash;I get the following output from
the /server-status URL:
<pre     class="programlisting">
Server Version: Apache/1.3.12 (UNIX) mod_perl/1.24
Server Built: Mar 29 2000 12:25:42
Current Time: Friday, 21-Jul-2000 16:02:51 IDT
Restart Time: Friday, 21-Jul-2000 16:02:48 IDT
Parent Server Generation: 2
Server uptime: 3 seconds
Total accesses: 0 - Total Traffic: 0 kB
CPU Usage: u0 s0 cu0 cs0
0 requests/sec - 0 B/second -
1 requests currently being processed, 4 idle servers
</pre>


The status information begins with a fair amount of text indicating
how long the server has been running, and how many times people
have accessed the server. It also indicates just how many bytes are
being served by this web process and how many servers are sitting
idle. <span   class="bold"><b>mod_status</b></span> thus provides a
nice window into the world of the Apache server, allowing us to see
whether we have defined MaxSpareServers in the most
resource-efficient manner.
</p><p><span   class="bold"><b>mod_status</b></span> then produces
output in the following format, which can seem cryptic at
first:</p><pre     class="programlisting">
W____.............................................
 .................................................
 .................................................
 .................................................
</pre><p>Each &ldquo;.&rdquo; character represents a potential Apache server
process which is currently not running. Those that are waiting for
a new connection are represented by &ldquo;_&rdquo;; those that are reading
input from the user's HTTP request are represented by &ldquo;R&rdquo;; and
writing their output to the user's browser are represented by
&ldquo;W&rdquo;. Not all letters may be visible at a given time; the current
Apache status changes dynamically, and the output you see from
mod_status will change to reflect that.
</p><p>Following this display, we get a play-by-play view of what
each active process is doing. We can see which connections are
taking a long time to be processed, which connections are the most
popular each month, and nearly any other facet.</p><p>Of course, it is normally a bad idea to open up your status
information to the entire world. Luckily, you can use the
&ldquo;Order&rdquo;, &ldquo;Deny&rdquo; and &ldquo;Allow&rdquo; directives to restrict access to
a set of IP addresses or to an entire domain. For example:</p><pre     class="programlisting">
&lt;Location /server-status&gt;
    SetHandler server-status
    Order deny,allow
    Deny from all
    Allow from .lerner.co.il
&lt;/Location&gt;
</pre><p>With the above configuration, mod_status will display results
only for IP addresses in my domain. Requests coming from another
domain will get an HTTP response indicating that access is
forbidden to them.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294b308"></a>Thinking Ahead with DSO</h2></div></div><p>Until now, we have assumed our Apache installation is
statically compiled, with all of the modules placed inside of
Apache at compile time. This is the traditional way to compile
Apache, and the default if you simply perform a
&ldquo;./configure&rdquo;.</p><p>The problem with the above configuration is that it is
relatively inflexible. What happens if you discover that you forgot
to configure Apache to include a particular module? You will have
to recompile the entire program, specifying which modules you do
and don't want to include when running
<span   class="bold"><b>configure</b></span>. This does not seem bad
at first&mdash;after all, how often will you want to add a new module to
the system?</p><p>However, the problem is deeper than that, in at least two
ways. Why should Apache consume memory for modules that might not
be used? In addition, why should I have to recompile Apache every
time a new version of just one module is released?</p><p>In order to solve this problem, the Apache developers now
support a system known as DSO, or &ldquo;dynamic shared objects&rdquo;. DSOs
make it possible to compile Apache with only two statically linked
modules, <span   class="bold"><b>mod_core</b></span> (which provides
core functionality) and <span   class="bold"><b>mod_so</b></span>
(which handles the loading of DSOs). All other modules can be built
such that they are loaded only when necessary. Because modules are
not an inherent part of Apache, they can also be upgraded without
having to recompile the web server itself. As we will see below,
this functionality can come in handy if you need to upgrade or
debug an already-running and configured Apache server.</p><p>To compile Apache with DSOs, you will need to decide which
modules you wish to compile statically, and which you will compile
as DSOs. My preference is to make everything a DSO, but to compile
only the modules that Apache installs by default. We can do this by
changing our invocation of &ldquo;configure&rdquo;:</p><pre     class="programlisting">
 ./configure --enable-shared=max
</pre><p>This will automatically enable
<span   class="bold"><b>mod_so</b></span>, and will compile Apache
with all of the default modules. After compiling Apache with
<b  >make</b> and installing it with <b  >make
install</b>, Apache will continue to work as before. The only
difference is that it can now load modules dynamically, adding new
modules to the already-compiled HTTP server as they are needed.
</p><p>The default httpd.conf created by an Apache server compiled
with <b  >--enable-shared</b> looks slightly different
from that created for a statically compiled Apache server. For one,
most of the directives are hidden inside &lt;IfModule&gt; sections,
making it possible for Apache to load even if some of its modules
have not been loaded yet. In addition, each module must first be
loaded with the LoadModule directive, and then enabled with the
AddModule directive. For example:</p><pre     class="programlisting">
LoadModule perl_module libexec/libperl.so
AddModule mod_perl.c
</pre><p>LoadModule takes two arguments, the name of the module and
the file in which the <b  >.so</b> file sits. The name
must match the name with which the DSO module was compiled, while
the file name should point to a directory relative to
/usr/local/apache. In the above example, and by default, DSO
modules are placed in /usr/local/apache/libexec.
</p><p>In contrast with most of the other directives in httpd.conf,
LoadModule and AddModule are sensitive to the order in which they
are placed. LoadModule must come before AddModule, and each module
must be loaded and added before its directives will work. In
addition, some modules must be loaded before others, and will not
work otherwise. If it is possible to let an automatic configuration
tool take care of the insertion of LoadModule and AddModule, let it
do so. This may save your web server from hard-to-track-down
configuration problems.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294ba40"></a>apxs</h2></div></div><p>Once Apache is compiled with DSO support, new modules can be
added at any time. However, these modules must be compiled with the
same configuration information that was present when the Apache
server itself was compiled. This is handled automatically by
<span   class="bold"><b>apxs</b></span>, the &ldquo;Apache Extension&rdquo;
program, written by Ralf S. Engelschall.
<span   class="bold"><b>apxs</b></span> makes it possible to compile
an Apache module into a DSO (.so file), and then to install it into
the appropriate Apache configuration. Unfortunately, there seems to
be little or no documentation for apxs, meaning that it can be
difficult to understand exactly what this program does or how it
works.</p><p>For example, let us assume we have already compiled and
installed Apache with DSO support. Several weeks later, we notice
that many of the hits on our site are resulting in &ldquo;file not
found&rdquo; errors, because users cannot spell the odd names we have
used in our URLs. One solution is obviously to revamp the site such
that users will be able to spell things more easily. But an easier
solution is to install mod_speling, so capitalization and spelling
are largely ignored.</p><p>To compile mod_speling as a DSO, type:</p><pre     class="programlisting">
/usr/local/apache/bin/apxs -c mod_speling.oc
</pre><p><span   class="bold"><b>apxs</b></span> will invoke gcc,
compiling mod_speling. The result will not be directly executable,
but rather a library that can be invoked by Apache. If the
compilation was successful, then we can install mod_speling with
the following command:
<pre     class="programlisting">
/usr/local/apache/bin/apxs -i -n -a mod_speling.so
</pre>


Using <b  >apachectl configtest</b> is particularly
useful when installing new DSO modules. It ensures that the module
we have added is indeed there and working, and that Apache now
understands any new directives we added outside of &lt;IfModule&gt;
sections.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294be60"></a>mod_perl</h2></div></div><p><span   class="bold"><b>mod_perl</b></span>, the Apache module
which makes it possible to write new modules in Perl and to
configure existing ones using the popular language, can be complied
as a DSO. This requires the use of apxs, as in the case of
mod_speling. However, mod_perl is much more complicated than a
single module, and depends on many outside pieces of information
for its compilation. <span   class="bold"><b>mod_perl</b></span> is
thus configured and compiled similarly to stand-alone Perl modules,
with <b  >perl Makefile.PL</b>, followed by a
<b  >make</b>, <b  >make test</b> and
<b  >make install</b>.</p><p>In order to compile a new version of mod_perl into an
existing version of Apache, issue the following command:</p><pre     class="programlisting">
perl Makefile.PL \
USE_APXS=1 WITH_APXS=/usr/local/apache/bin/apxs
</pre><p>If you want to enable mod_perl for all of the different
Apache handlers, rather than just the default PerlHandler (for
creating dynamic content), turn on the
<b  >EVERYTHING</b> switch. For example:
<pre     class="programlisting">
perl Makefile.PL \
USE_APXS=1 WITH_APXS=/usr/local/apache/bin/apxs  \
EVERYTHING=1
</pre>


Once you have created the Makefile in this way, you can compile and
install mod_perl into the existing Apache server with:
<pre     class="programlisting">
make
make test
make install
</pre>


This method works not only for installing a new copy of mod_perl
into Apache, but also for upgrading an existing copy. You can then
test to see if mod_perl has been compiled into the server by
telneting to the server's address and port number, and issuing the
command:
<pre     class="programlisting">
HEAD / HTTP/1.0
This will return the HTTP headers associated with the / document on
the server. Among other things, there should be a "Server" header
indicating what kind of server is running. <span   class="bold"><b>mod_perl</b></span> adds a tag to
this output string, so you should see output like the following:
</pre>


<pre     class="programlisting">
Server: Apache/1.3.12 (UNIX) mod_perl/1.24
</pre>


Because mod_perl updates come out at different times than Apache
updates, I have found it to be extremely useful to install and
upgrade mod_perl in this way.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x294c490"></a>Apache::Status</h2></div></div><p>While mod_status can tell us what is happening with each
Apache process, it cannot tell us what is happening inside a
particular module. In general, this is not such a bad thing; do I
really care what is happening inside mod_mime or
mod_speling?</p><p>But in the case of mod_perl, where so many complex things are
going on, it would be nice to be able to find out what is going on.
Perl Apache::Status module, which works with mod_perl, provides
this information.</p><p>In order to activate Apache::Status, we need to insert
another section into httpd.conf. As with mod_status, we will create
a new <b  >Location</b> section which associates a
particular handler with a virtual URL, traditionally known as
&ldquo;/perl-status&rdquo;:</p><pre     class="programlisting">
PerlModule Apache::Status
&lt;Location /perl-status&gt;
    SetHandler  perl-script
    PerlHandler Apache::Status
&lt;/Location&gt;
</pre><p>Once we have restarted the server or sent it a HUP signal,
requesting the URL /perl-status will produce a menu of options,
such as &ldquo;Environment&rdquo; and &ldquo;Inheritance tree&rdquo;. Other Perl
modules for mod_perl, such as <b  >HTML::Mason</b>, can
install their own hooks for <b  >Apache::Status</b>,
making it possible to look through their environments. For example,
Mason provides a simple interface for viewing the current
configuration, as well as a list of components that have been
compiled and cached.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x2c5fda0"></a>A Short Story</h2></div></div><p>Over the days preceding my writing of this column, I used all
of the above techniques to track down a problem with my
installation of <b  >HTML::Mason</b>. The colocated
server that I help run was having some problems handling a growing
load. Every few hours, all of the Mason-based sites on the server
would fail, followed one or two hours later by the non-Mason sites.
Actually, &ldquo;fail&rdquo; is too strong a word&mdash;the browser would send a
request to the server, but would time out (after ten minutes or so)
of waiting to receive a connection. What was going on, and how was
I going to fix it?</p><p>My first reaction was to think that our server was running
out of RAM. I used &ldquo;top&rdquo; and &ldquo;free&rdquo; to inspect the system, but
did not see anything out of the ordinary. On the one hand, this was
a relief. At the same time, this meant we were somehow running out
of available servers, even though I had configured the system for a
maximum of 150 simultaneous clients. My server might be popular,
but 150 simultaneous accesses is highly unusual, even for me.
Something else was obviously going on here.</p><p>There was clearly some connection to Mason, and perhaps to
mod_perl. I decided it was about time to upgrade mod_perl to the
latest version (1.24), using the technique I described above. So I
upgraded the copy of HTML::Mason and several other related modules,
restarted Apache with apachectl, and hoped the problem would go
away.</p><p>Unfortunately, the simple upgrade did not do the trick. The
system still stopped responding to requests after several hours of
activity. I used Apache::Status to look at the state of mod_perl,
and nothing seemed to be out of the ordinary.</p><p>I looked at the system status with mod_status, and discovered
that over time, many of the Apache processes were getting stuck in
the &ldquo;write&rdquo; state. In other words, the list of Apache processes
was slowly, but surely, being transformed from a list of &ldquo;.&rdquo;
(unallocated) processes to a list of &ldquo;W&rdquo; (writing an HTTP
response) processes. Every invocation of a Mason component on the
system was using up another Apache process, and never letting it
go! It was no surprise, then, that the system was locking up after
only a few hours; if the Mason-related parts of the site had been
more popular, the system would have gone down even more
quickly.</p><p>I looked through the Mason configuration file and determined
that my use of the Apache::Session module, which allows mod_perl
programs to track a user's movements and actions (as we saw in my
article, &ldquo;Session Management with Mason&rdquo; in the August
<i  >Linux Journal</i>) was failing to return. So each
time a Mason component was invoked, everything would work
fine&mdash;until the component needed to return, at which point the
executing program would simply spin its wheels, waiting to connect
to the MySQL database.</p><p>My solution was not particularly elegant, but did the trick:
I decided to stop using the MySQL version of Apache::Session (known
as Apache::Session::MySQL) and start using the simple file-based
version (known as Apache::Session::File). I restarted the server,
and was delighted to discover that everything was working as it
should.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x285a580.0x2c60168"></a>Conclusion</h2></div></div><p>Apache is a wonderful, robust and easily configurable HTTP
server. However, it is also a complex piece of software that
requires some experience in order to tune correctly. When mod_perl
is added to the mix, the complexity increases even more. Luckily,
it is possible to install Apache such that installing and upgrading
modules can be easy and painless.</p><p>Moreover, a number of modules and tools (such as mod_status
and Apache::Status) make it possible to view the internals of
Apache as it is executing. By taking advantage of these tools, we
can find and fix problems with our servers, spending our time on
more interesting issues than trying to figure out why a server does
not run.</p></div></div>
<div class="authorblurb"><p>
        <div       class="mediaobject"><img src="4222aa.jpg"></div>


      <span   class="bold"><b>Reuven M. Lerner</b></span>
      owns a consulting firm
      specializing in web and Internet technologies, based in Modi'in,
      Israel. As you read this, he should (finally) be done
      writing Core Perl, published by Prentice-Hall. You can
      reach him via e-mail at reuven@lerner.co.il, or at the ATF home
      page,
      <a href="http://www.lerner.co.il/atf" target="_self">http://www.lerner.co.il/atf/</a>.</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../078/toc078.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>