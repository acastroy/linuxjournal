<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Basic fvwm Configuration</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;    This article&#10;    will attempt to introduce you to one of the most&#10;    versatile and popular X-Windows managers: fvwm (which, I've&#10;    been told, originally stood for &ldquo;Frugal Virtual Window&#10;    Manager&rdquo;).&#10;    "><meta name="keywords" content="applications, programming, system, admin, configuration"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x19c3580.0x1abaab0"></a>Basic fvwm Configuration</h1></div><div><div class="author"><h3 class="author">John M. Fisk</h3></div><div class="issuemoyr">Issue #27, July 1996</div></div><div><p>
    This article
    will attempt to introduce you to one of the most
    versatile and popular X-Windows managers: fvwm (which, I've
    been told, originally stood for &ldquo;Frugal Virtual Window
    Manager&rdquo;).
    </p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x19c3580.0x1abb500"></a></h2></div></div><p>This article is primarily intended for,
and dedicated to, all the novices and newcomers who have joined the
worldwide community of Linux users. Welcome aboard! This article
will attempt to introduce you to one of the most versatile and
popular X-Windows managers: <span   class="bold"><b>fvwm</b></span>
(which, I've been told, originally stood for &ldquo;Frugal Virtual
Window Manager&rdquo;). Its well-deserved popularity is based, among
other things, on its relatively parsimonious memory consumption, an
extensively customizable 3 Motif-ish appearance, a virtual desktop,
and the ability to extend functionality through the use of modules.
</p><p>Before we begin, let me state a couple of
presuppositions:</p><p>1. You've installed X-Windows and the fvwm window manager and
have them working, and</p><p>2. You're willing to tinker a bit.</p><p>If this is you, keep reading!</p><p>First, some background: the concept of a window manager is,
in essence, a rather simple one. X-Windows itself oversees certain
rudimentary tasks such as managing the display hardware (monitor,
keyboard, and mouse), handling mouse and keyboard events, and
creating the windows which appear on the display. Just exactly
<span   class="emphasis"><em>how</em></span> windows appear and behave is left up to
the <span   class="emphasis"><em>window manager</em></span>. Window managers, such as
fvwm, control how you interact with programs by providing
decorative window frames, window controls, menus, virtual desktops,
and so forth. Change to a different window manager and you can
create a completely different look and feel even though the
programs which run under them are identical.</p><p>fvwm was developed by Robert Nation as a derivative of one of
the original MIT window managers,
<span   class="bold"><b>twm</b></span> (the <span   class="emphasis"><em>Tabbed Window
Manager,</em></span> which started life as <span   class="emphasis"><em>Tom's Window
Manager</em></span> in honor of its author, Tom LaStrange). fvwm is
currently maintained by Chuck Hines. The latest official release is
fvwm-1.24r, although a beta version&mdash;pre2.0pl40 (as of mid-December
1995)--is currently available as well. These can be found at:
ftp://sunsite.unc.edu/pub/Linux/X11/window-managers/
ftp://ftp.hpc.uh.edu/pub/fvwm/ ftp://ftp.x.org/contrib/</p><p>In addition, there are a number of excellent WWW pages
dedicated to fvwm which provide a wealth of information, screen
shots, and sample .fvwmrc configuration files. These
include:</p><p>T.J. Kelly's <span   class="bold"><b>The fvwm Home
Page</b></span>:
<a href="http://www.cs.hmc.edu/~tkelly/docs/proj/fvwm.html" target="_self">www.cs.hmc.edu/~tkelly/docs/proj/fvwm.html</a></p><p>Todd Postma's <span   class="bold"><b>fvwm Info</b></span>:
<a href="http://xenon.chem.uidaho.edu/~fvwm" target="_self">http://xenon.chem.uidaho.edu/~fvwm/</a></p><p>Jens Frank's <span   class="bold"><b>fvwm
Documentation</b></span>:
<a href="http://namu19.gwdg.de/fvwm/fvwm.html" target="_self">namu19.gwdg.de/fvwm/fvwm.html</a></p><p>Erik Kahler's <span   class="bold"><b>fvwm Home
Page</b></span>:
<a href="http://mars.superlink.net/user/ekahler/fvwm.html" target="_self">mars.superlink.net/user/ekahler/fvwm.html</a></p><p>At this point it's probably worth mentioning that if you're
serious about customizing fvwm, it's a good idea to get the sources
even if you don't intend to compile your own version. Why? Some
Linux distributions do not include full documentation for every
program. Getting the sources for fvwm ensures that you'll have the
complete documentation, including manual pages for the various fvwm
modules. Also, if you do choose to compile fvwm yourself, you can
determine which features you wish to include.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x19c3580.0x1abbef8"></a>So Let's Begin!</h2></div></div><p>Some of the basics we'll try to cover include:</p><p>1. Managing configuration files</p><p>2. Starting programs at load up</p><p>3. Adding items to the fvwm popup menus</p><p>4. Color customization</p><p>Keep in mind that the information presented here is intended
to be used as a primer. I'd recommend skimming through the manual
pages for fvwm in addition to reading this article. The definitive
source of information is the manual page and documentation that
comes with the program source distribution.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x19c3580.0x1abc1b8"></a>Managing Configuration Files</h2></div></div><p>The first thing that you'll need to know about fvwm is where
the configuration file is found. When fvwm starts, it first looks
for .fvwmrc in your home directory. For example, if your username
is johndoe, fvwm looks for the file /home/johndoe/.fvwmrc. If this
file is absent it then looks for the system-wide configuration file
/usr/lib/X11/fvwm/system.fvwmrc. If neither of these files are
present, it simply exits.</p><p>One of the first things you'll want to do is make a copy of
the default system-wide configuration file and put it in your home
directory:</p><pre     class="programlisting">
$ cp /usr/lib/X11/fvwm/system.fvwmrc ~/.fvwmrc
</pre><p>Be sure to copy this to ~/.fvwmrc and
<span   class="bold"><b>not</b></span> ~/system.fvwmrc. Creating a
copy of the file in your home directory is a good idea for a couple
reasons:</p><p>1. If your .fvwmrc file gets corrupted, fvwm will fall back
to using the system-wide configuration file.</p><p>2. If ~/.fvwmrc inadvertently gets deleted, you can use the
system.fvwmrc file to re-create it.</p><p>3. On a multi-user system, it allows each user to customize
her/his own .fvwmrc file.</p><p>The other issue to think about at the outset is sequential
customizations. Chances are, over the course of several weeks or
months, you'll make numerous small and large changes to the config
file as you get fvwm customized to work the way you want it. What
happens when you accidently overwrite or delete system.fvwmrc or
your .fvwmrc? Serious bummer.</p><p>Managing system configuration files is important for anyone
who is running, and likely administering, his own Linux system. It
is wise to have a well-thought-out plan for how changes are
implemented and changes tracked. Never do what you cannot undo.
fvwm uses a single configuration file, making this a fairly simple
task. Here are a few suggestions.</p><p>Before making any changes in a default configuration file,
make a backup of it and give it a distinctive suffix, such as
.dist. For example, before you edit the system.fvwmrc file for the
first time, you'd make a copy of it by:</p><pre     class="programlisting">
# cp system.fvwmrc system.fvwmrc.dist
</pre><p>The .dist suffix alerts you to the fact that this is an
original file from the distribution. To further safeguard it, you
should copy this to a directory owned by root (the superuser) and
set the permissions on that directory to read and execute only,
except for root. To do this, you could, for example, make a
directory in your /etc or /usr/local directory called backups/ and
then copy all default config files to this directory.</p><p>To do this, log in as root and enter:</p><pre     class="programlisting">
# mkdir /etc/backups
# chmod 755 /etc/backups
</pre><p>Setting the <span   class="emphasis"><em>directory</em></span> permissions, as
root, to 755 allows root full read, write, and execute permissions,
while preventing write permissions for everyone else. With read and
execute permissions, users may change to the directory and do a
file listing but cannot (since they don't have write permission to
that directory) delete a file.</p><p>After you've created a backup directory and set the
appropriate permissions you should, as root, make backup copies of
important configuration files with the .dist suffix. You can also
set the permissions for each <span   class="emphasis"><em>file</em></span> to read-only
by:</p><pre     class="programlisting">
# chmod 744 /etc/backups/system.fvwmrc.dist
</pre><p>This limits permissions on the file to read only for all
users except root. Making backups of default configuration files is
helpful only if it actually <span   class="emphasis"><em>works</em></span>. Obviously,
you'll want to make a backup copy of a working configuration file.
This, however, still doesn't address the question of what to do
about keeping track of each of your changes. Here are a few
suggestions.</p><p>1. After you have modified a configuration file, and ensured
that it works correctly, make a copy of it and number each file
consecutively such as:</p><pre     class="programlisting">
fvwmrc.01
fvwmrc.02
fvwmrc.03 ...
</pre><p>Comments can be added by starting a line with the
<b  >#</b> (hash) character and should probably include
the date and what modifications were made. If space is a problem,
you can compress all the files you are not currently using.</p><p>2. Use <span   class="bold"><b>RCS</b></span>, the &ldquo;Revision
Control System&rdquo;, to keep track of your changes. Before you make
any changes to the file, run the RCS
<span   class="bold"><b>check-in</b></span> program:</p><pre     class="programlisting">
$ ci -l .fvwmrc
</pre><p>It will ask you for a description of the file; type:</p><pre     class="programlisting">
fvwm configuration file
<span   class="bold"><b>.</b></span>
</pre><p>The <b  ><i><tt>.</tt></i></b> on a line
by itself finishes the description.</p><p>Then, every time you make a change to the file, run the same
command. It will ask you for a description of the change you just
made; type something like:</p><pre     class="programlisting">
Added Calculator, xjed, and Emacs to the
"Application" pop-up menu.
<span   class="bold"><b>.</b></span>
</pre><p>so that you can find this change later.</p><p>RCS keeps track of all the changes you have made to .fvwmrc
in a file called &ldquo;.fvwmrc,v&rdquo;. Instead of storing a complete copy
of each new version of the file, it stores only the changes you
have made, plus the latest version of the file.</p><p>How do you find the change later? The command line</p><pre     class="programlisting">
$ rlog .fvwmrc | less
</pre><p>will give you a history of all the changes you have made.
Each change has a <span   class="bold"><b>revision number</b></span>,
starting at 1.1.</p><p>If you want to compare the current copy of the file with the
version you previously checked in, use this command:</p><pre     class="programlisting">
$ rcsdiff -u .fvwmrc | less
</pre><p>You can retrieve any version of the file you want
(overwriting the current version) with</p><pre     class="programlisting">
$ co -r<span   class="emphasis"><em>revision</em></span> .fvwmrc
</pre><p>If you want more information on how to use RCS, it is
available with:</p><pre     class="programlisting">
$ man rcsintro
</pre><p>which provides a good overview of the concepts and commands
you'll need to know. [<i  >Linux Journal</i> also
published an overview of RCS in issue 10, page 36&mdash;ED]</p><p>Using the RCS system is only slightly more complex a method
of version control than simply making copies of every modified
file. However, the basics are easily mastered and can be used for
any file&mdash;programming project, article, term paper, etc.&mdash;that is
undergoing sequential revision.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x19c3580.0x1ab3de0"></a>Getting Things Going</h2></div></div><p>Now that you've copied the .fvwmrc file to your home
directory and decided how you'll track your changes to it, you're
ready to start tinkering! One of the first things you might be
interested in is automatically launching programs when fvwm starts.
You may want to start an xterm or two, a clock or calendar, xbiff
(to warn you when mail arrives), and so forth. fvwm allows you to
define an <b  >InitFunction</b> within .fvwmrc that
handles program launching at initialization. Before discussing
this, however, we need to briefly mention xinit.</p><p><span   class="bold"><b>xinit</b></span> is the program
responsible for starting the X Window System and, like fvwm, it
uses an .xinitrc file. A user may create a personalized copy of
this file in her or his home directory as ~/.xinitrc, or simply use
the system wide default located in /usr/lib/X11/xinit/xinitrc. To
see how xinit launches programs at startup, let's look at the
default xinitrc file that came with Slackware 2.2.0:</p><pre     class="programlisting">
# start some nice programs
xsetroot -solid SteelBlue &amp;
fvwm
</pre><p>In this simple example, xsetroot sets the color of the root
window to SteelBlue. Once it is done, fvwm is started. A slightly
more complicated example is given in the manual page for
xinit:</p><pre     class="programlisting">
xrdb -load $HOME/.Xresources
xsetroot -solid gray &amp;
xclock -g 50x50-0+0 -bw 0 &amp;
xload -g 50x50-50+0 -bw 0 &amp;
xterm -g 80x24+0+0 &amp;
xterm -g 80x24+0-0 &amp;
twm
</pre><p>In this example, several programs are launched before twm is
started. The important thing to point out is that the stanzas which
launch programs, such as xclock and the xterm, need to end with an
ampersand (<b  >&amp;</b>) so as to have them running in
the background. It is also important that the window manager be
started last and that it runs in the foreground (i.e., do not add
an ampersand at the end of the line).</p><p>fvwm provides a similar method for launching programs at
startup using the <b  >InitFunction</b>. To see how,
let's look at a sample entry in .fvwmrc:</p><pre     class="programlisting">
Function "InitFunction"
# Module  "I"  FvwmBanner
# Get the fvwm GoodStuff button bar running
  Module  "I"  GoodStuff
# Module  "I"  FvwmPager 0 3
# Then, the analog clock - Swallowed by GoodStuff
  Exec  "I"  exec xclock -g 140x160-145+138 &amp;
  Wait  "I"  xclock
# Start xmailbox - swallowed by GoodStuff
  Exec  "I"  exec xmailbox &amp;
  Wait  "I"  xmailbox
# Fire up xload - also swallowed by GoodStuff
  Exec  "I"  exec xload -geometry 80x80+100+100 &amp;
  Wait  "I"  xload
# Now, start up xcalendar
  Exec  "I"  exec xcalendar -g 345x382+793+372 &amp;
  Wait  "I"  xcalendar
# Finally, fire up a full screen xterm
  Exec  "I"  exec xterm -sb -j -ls -g 84x48+4+4 &amp;
  Wait  "I"  xterm
EndFunction
</pre><p>Since it's easiest to explain by example, let's see what
you'd need to do to add a second xterm to the startup. To begin
with, <b  >InitFunction</b> generally uses two-line
stanzas for launching programs, and these take the form:</p><pre     class="programlisting">
  Exec  "I"  exec <span   class="emphasis"><em>program_name -options</em></span> &amp;
  Wait  "I"  <span   class="emphasis"><em>program_title</em></span>
</pre><p>For example, the stanzas which start xcalendar look
like:</p><pre     class="programlisting">
# Now, start up xcalendar
  Exec  "I"  exec xcalendar -g 345x382+793+372 &amp;
  Wait  "I"  xcalendar
</pre><p>Lines which begin with the hash (<b  >#</b>)
character are treated as comments and ignored by fvwm. The first
line begins with the reserved word <b  >Exec</b> and has
four arguments:</p><p>1. An <b  >"I"</b> (in double quotes).</p><p>2. The word <b  >exec</b>.</p><p>3. The command used to start the program.</p><p>4. Any command line options followed by an ampersand
(<b  >&amp;</b>).</p><p>The next line begins with the word <b  >Wait</b>
which causes an fvwm function to pause while a window with the name
given on the command line is drawn to the display. In this case,
the <b  >InitFunction</b> pauses while a window with the
title <b  >xcalendar</b> is drawn to the display. Once
the window has been drawn, fvwm continues.</p><p>Be aware that this is a bit of a fib, but a useful one for
the moment. The <b  >Wait</b> function is primarily used
when programs are launched on more than one desktop&mdash;something we
won't touch on for the moment. Assuming you use a single desktop,
as in this present example, the <b  >Wait</b> stanza may
be safely omitted.</p><p>Going back to our assignment to start another xterm, we could
launch a second xterm by adding the following:</p><pre     class="programlisting">
  Exec  "I"  exec xterm &amp;
  Wait  "I"  xterm
</pre><p>which would be sufficient to get a second xterm going.</p><p>If you added this entry and started fvwm, you'd find that
when fvwm got to the point in the initialization process where the
second xterm was started, it would draw the outline of the xterm
window and wait for you to position it before proceeding. That's
not very convenient if you have to do this every time fvwm starts.
The way around this is to add a command line option specifying the
xterm's geometry, which allows you to control where to place the
window from the command line.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x19c3580.0x1ab4c50"></a>A Word About Geometry</h2></div></div><p>A geometry entry for an application might look something like
this:</p><pre     class="programlisting">
 -geometry 420x360+5+20
</pre><p>If this looks a bit cryptic, don't worry, it's actually
pretty simple. Converting this statement into plain English
yields:</p><p>&ldquo;The application window is 420 pixels wide by 320 pixels
high, with its left border 5 pixels from the display's left edge
and its top border 20 pixels from the display's top edge.&rdquo;</p><p>Pretty simple, eh? There are actually only a couple of rules
to keep in mind when specifying a window's geometry. First,
dimensions are generally in terms of pixels, although there are
times, notably with xterms and some text editors, in which the
width and height dimensions will be in terms of characters. You'll
notice in the example .xinitrc file above that the width and height
dimensions for the xterm were given as 80x24, or 80 characters wide
by 24 columns high. If you bear in mind that your entire display
screen is probably 640x480 or 800x600 or 1024x768 pixels, depending
on your resolution, you can get a feel for how much of the screen
is taken up by an application window that is, say, 400x300
pixels.</p><p>The second set of numbers specify the horizontal (x-offset)
and vertical (y-offset) distances from the edge of the display
screen. Again, this is pretty straightforward: think of the screen
in terms of graphing paper in which the upper left hand corner is
0,0 and the values increase as you move from left to right and from
top to bottom.</p><p>If your screen were 640x480 pixels, your top left corner
would be considered 0,0; the bottom left corner would be 0,480
(remember that the vertical position increases as you move from top
to bottom); the top right corner would be 640,0; and the bottom
right corner would be 640,480. The other thing to keep in mind is
that horizontal and vertical positions are generally (but not
always, as we'll see in a minute) specified in terms of the left
and top sides of the application window.</p><p>For example, suppose that you wanted to put an xterm window
in the upper left hand side of the screen. You decide that you want
it 10 pixels from the left hand side of the display and 50 pixels
from the top. You also want the window to be 400 pixels wide by 320
pixels high. Simple enough. You'd use the following geometry option
to accomplish this:</p><pre     class="programlisting">
-geometry 400x320+10+50
</pre><p>Notice the general form this takes:</p><pre     class="programlisting">
-geometry <span   class="emphasis"><em>WIDTH</em></span>x<span   class="emphasis"><em>HEIGHT</em></span>+<span   class="emphasis"><em>horizPOS</em></span>+<span   class="emphasis"><em>verticalPOS</em></span>
</pre><p>Using a plus <b  >+</b> sign before the pixel value
indicates the position of the window with respect to its
<span   class="emphasis"><em>left</em></span> hand or <span   class="emphasis"><em>top</em></span> edges.
However, using a minus <b  >-</b> sign specifies the
opposite meaning: the horizontal position is the distance in pixels
between the application window's <span   class="emphasis"><em>right</em></span> hand
side and the <span   class="emphasis"><em>right</em></span> side of the display, and
the vertical position is the distance in pixels between the
application window's <span   class="emphasis"><em>bottom</em></span> edge and the
<span   class="emphasis"><em>bottom</em></span> edge of the display.</p><p>If this seems a bit confusing try playing with it a bit.
Start up fvwm and in an xterm enter the following commands:</p><pre     class="programlisting">
xterm -g +5+5 &amp;
xterm -g -5-5 &amp;
xterm -g -5+5 &amp;
xterm -g +5-5 &amp;
</pre><p>Try these out and see where the xterm gets put. Note that you
can generally abbreviate <b  >-geometry</b> to a simple
<b  >-g</b>.</p><p>We've wandered a bit from our discussion about launching
programs at startup. In practical terms, figuring out the correct
geometry for all of the applications you want to have started is
pretty easy. The first step is to get pencil and paper ready
because you'll want to jot some notes.</p><p>Customizing the start-up desktop usually begins by starting
all of the applications that you want present when fvwm begins. Try
out various command line options to get the look and feel that you
want. Reading a program's manual page often helps you determine
what options are available at run time. Once you get an application
running, you can generally resize it by clicking the mouse on one
of the &ldquo;L&rdquo; shaped window corners and dragging it to a larger or
smaller size. Clicking and dragging on the titlebar or side borders
lets you position the window.</p><p>Once you have everything started, positioned, and sized the
way you want it, jot down each application and the command line
options, if any, that you used. To get each window's geometry,
we'll use a great little program called
<span   class="bold"><b>xwininfo</b></span>.</p><p>Start it from an xterm by entering:</p><pre     class="programlisting">
$ xwininfo
</pre><p>at the command prompt. Notice that you don't use an ampersand
for this command. Your mouse cursor will change to a cross-hair and
the following instructions will be displayed:</p><pre     class="programlisting">
xwininfo: Please select the window about which you
          would like information by clicking the
          mouse in that window.
</pre><p>Clicking on an application window produces the output like
the following:</p><pre     class="programlisting">
xwininfo: Window id: 0x2c00007 "ez ~/fvwm_LJ.ez*"
  Absolute upper-left X:  92
  Absolute upper-left Y:  28
  Relative upper-left X:  0
  Relative upper-left Y:  0
  Width: 528
  Height: 724
  Depth: 8
  Visual Class: PseudoColor
  Border width: 0
  Class: InputOutput
  Colormap: 0x21 (installed)
  Bit Gravity State: ForgetGravity
  Window Gravity State: NorthWestGravity
  Backing Store State: WhenMapped
  Save Under State: no
  Map State: IsViewable
  Override Redirect State: no
  Corners:  +92+28  -532+28  -532-148  +92-148
  -geometry 528x724+85+0
</pre><p>In this instance, I clicked on the EZ editor's window, which
produced a veritable cornucopia of information. Specifically, the
geometry setting that you were looking for is in the last line. Do
this for all the applications that you want started, and your work
is pretty much done. Find the section in .fvwmrc that defines the
<b  >InitFunction</b>, add or modify the entries so as to
start the applications that you want&mdash;don't forget to put that
ampersand at the end of each <b  >Exec</b> line!&mdash;and you
should be all set. Once you've gotten things the way you want them,
don't forget to make a backup of your newly modified .fvwmrc
file.</p><p>One more thing before we leave the subject of launching
programs at start up. fvwm comes with a number of
<span   class="emphasis"><em>modules</em></span>, which are separate programs which
must be spawned by fvwm&mdash;you can't start these from a command line.
There are a number of modules which can generally be found in the
/usr/lib/X11/fvwm directory. A couple of the more common modules to
launch at start up include FvwmBanner, which places a decorative
banner across the root window; FvwmPager, which serves as a virtual
desktop manager when you have multiple desktops going; and the
GoodStuff button bar. The entry in <b  >InitFunction</b>
to start an fvwm module is a bit different than a regular
application in that it is simpler:</p><pre     class="programlisting">
  Module  "I"  GoodStuff
  Module  "I"  fvwmPager 0 3
</pre><p>You'll notice that there's no <b  >Exec</b> or
<b  >Wait</b> statement needed. Simply use the reserved
word <b  >Module</b>, followed by <b  >"I"</b>
and then the name of the module to launch with any options.</p><p>That wasn't too bad, was it? This should give you the basics
that let you customize your startup desktop. Next month, I'll cover
launching programs once fvwm has started&mdash;and more!</p></div></div>
<div class="authorblurb"><p>
      <span   class="bold"><b>John Fisk</b></span>
      (<a href="mailto:fiskjm@ctrvax.vanderbilt.edu">fiskjm@ctrvax.vanderbilt.edu</a>)
      After three years as a General Surgery resident and Research
      Fellow at the Vanderbilt University Medical Center, he
      decided to &ldquo;hang up the stethoscope&rdquo; and pursue a career in
      Medical Information Management. He's currently a full-time student
      at the Middle Tennessee State University and hopes to complete a
      graduate degree in Computer Science before entering a Medical
      Informatics Fellowship. In his dwindling free time he and his wife
      Faith enjoy hiking and camping in Tennessee's beautiful Great Smoky
      Mountains. An avid Linux fan since his first Slackware 2.0.0
      installation a year and a half ago.
    </p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../027/toc027.html">Issue Table of Contents</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>