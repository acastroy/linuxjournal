<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
SQL vs. NoSQL
</title><link rel="stylesheet" href="../css/archive.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.57.0"><meta name="description" content="&#10;NoSQL databases are all the rage, but the case to switch from SQL databases&#10;is not always as clear cut as you might have been led to believe.&#10;Know what's what, and then decide.&#10;"><link rel="stylesheet" href="../../css/archive.css" type="text/css"><script type="text/javascript" src="../../js/archive.js"></script><script type="text/javascript" src="../../js/highlight.js"></script></head><body onload="search_highlight();">
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="tophrdiv">
  </div>
  
  <div id="top_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  <div class="article" lang="en"><div class="titlepage"><div><h1 class="title"><a name="N0x14b9580.0x15b0ac0"></a>
SQL vs. NoSQL
</h1></div><div><div class="author"><h3 class="author">
Daniel 
 
Bartholomew
</h3></div><div class="issuemoyr">Issue #195, July 2010</div></div><div><p>
NoSQL databases are all the rage, but the case to switch from SQL databases
is not always as clear cut as you might have been led to believe.
Know what's what, and then decide.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x15b1250"></a></h2></div></div><p>
The articles on NoSQL databases in Reuven M. Lerner's At the Forge column
appearing in recent issues of <span   class="emphasis"><em>LJ</em></span> have been
enjoyable. Because this
is the Enterprise issue, I think it would be helpful to take a step back
and look at the Linux database landscape and examine in particular the
ongoing &ldquo;battle&rdquo; between SQL and NoSQL databases. By way of disclosure,
I work for Monty Program, a company whose primary product is MariaDB,
a community-enhanced branch of MySQL. That being said, I approached this
topic with as open a mind as possible.
</p><p>
The rivalry between SQL and NoSQL has been building during the past
year to the point where some people are predicting the end of the SQL
era. Actually, the two camps are largely complementary, because they're
designed to solve different problems.

</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x15b1568"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Acronyms</b></p><p>
Whenever the topic of databases arises, an alphabet soup is thrown
around that would make NASA proud. Some of the acronyms I use
a lot in this article include:
</p><div class="itemizedlist"><ul type="disc"><li><p>
RDBMS: Relational Database Management System.
</p></li><li><p>
SQL: Structured Query Language, also used to refer to databases that
use SQL as their query language.
</p></li><li><p>
NoSQL: used to refer to a class of databases that are non-relational
and do not use SQL as their query language. They could perhaps be better
called Distributed Database Management Systems (or DDBMSes), but for now,
the popular term is NoSQL.
</p></li><li><p>
ACID: Atomicity, Consistency, Isolation, Durability (see the What Is ACID?
sidebar).
</p></li><li><p>
CAP: Consistency, Availability, Partition tolerance (see the What Is CAP?
sidebar).
</p></li></ul></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x15b1b40"></a>
The Case for NoSQL</h2></div></div><p>
So, what is the big deal about NoSQL databases? For one, they've
introduced new ways (or perhaps re-introduced old ways) of thinking about
what databases are and what they
can do. For another, they're shiny and new, and all the cool kids seem to
be using them. You could argue that Google's BigTable is the database
that inspired the NoSQL movement. Or, maybe it was Amazon's S3. Both of
them are closed source, but they were (or are) impressive enough to
inspire open-source interpretations.
</p><p>
The current NoSQL field includes HBase, Cassandra, Redis, MongoDB,
Voldemort, CouchDB, Dynomite, Hypertable and several others. Some
have followed the model of BigTable, others follow S3's model, some are a
mix of the two, and others are charting their own path. Some of these
projects are more mature than others, but each of them is trying to
solve similar problems.
</p><p>
Instead of having tables with columns and rows like you would find
in a traditional RDBMS, most NoSQL databases are simple &ldquo;key-value stores&rdquo;. Each piece of data that goes into the database is given
a key, and when you want the data back, you use the key to get it. This
simplicity is beneficial, because it helps busy sites achieve extremely
low latency, even under high load, when paired with a large number of
servers and a fast network. The simplicity of the key-value model also
simplifies development.
</p><p>
A step beyond simply having keys and values are the so-called document
databases. A document, in this case, is a collection of various fields
of information. Each individual document can have a different number
of fields of varying lengths. These databases are useful if you have a
lot of semi-structured data, and they are a good fit for object-oriented
programming models (for example, you can consider the database as a
storage area for objects).
</p><p>
Why do traditional database users dislike these
newcomers? D. Richard
Hipp, the creator of SQLite, in a talk given at my local LUG, derisively
called NoSQL databases &ldquo;post-modern databases&rdquo;, because instead of giving
you a definite answer to your question, they give you &ldquo;an
opinion&rdquo; or their
&ldquo;best guess&rdquo;. His purpose was to paint NoSQL databases in a bad light,
and for most of the old-school database world, the NoSQL, non-relational,
BASE model (see the What Is ACID? sidebar) is more than a bit heretical.
</p><p>
The heresy comes because historically, databases almost always
have tried to implement the relational model and be fully ACID-compliant.
If your transactions weren't ACID, or your database wasn't relational, the
argument went, you couldn't call yourself a &ldquo;real&rdquo; database. Look
at the MySQL vs. PostgreSQL flame wars for ample evidence of this thinking.
</p><p>
The problem though, is that being relational and ACID is not necessary
for some use cases and can add unnecessary overhead, which you don't
want if you are running a popular, heavily trafficked Web site. Many
early users of MySQL knew this and were mocked for choosing MySQL over
&ldquo;real&rdquo; databases like PostgreSQL. It is ironic now that MySQL has
gained what every &ldquo;expert&rdquo; said it should have (ACID transactions),
that a new movement has started up claiming that all the old database technology
isn't actually necessary.
</p><p>
What is necessary for top-tier Web sites, according to proponents of NoSQL,
is massive scalability, low latency, the ability to grow the capacity
of your database on demand and an easier programming model. These,
and others, are things which, according to them, SQL RDBMSes just don't
provide in a cost-effective manner.
</p><p>
Most classic RDBMSes initially were designed to run on a single large
server. That is how it was done in the late 1970s and early
1980s, and the idea exists in the design of many RDBMSes to this day.
The P in CAP (see the What Is CAP? sidebar) is meaningless when the database is on a single server
(the server is either up or down, rarely or never only partly up),
and traditional RDBMSes have focused mainly on Consistency, aka ACID,
with Availability thrown in if you mirror between database servers or
use hardware with no single points of failure.
</p><p>
Some NoSQL databases also focus on the C and A parts of CAP. Unlike
traditional RDBMSes though, these databases are designed from the ground
up to be run on dozens, hundreds or even thousands of nodes in a single
data center. Partial partition tolerance for these databases is obtained by
mirroring database clusters between multiple data centers. The advantage
these databases have over a traditional RDBMS is that with the work
spread over all of those machines, you can achieve ultra-low latency
even when there are extremely high numbers of reads and writes, and
with all those machines, you can analyze massive amounts of data quickly.
</p><p>
Other NoSQL databases focus on the A and P parts of CAP and are
designed to span multiple data centers. True to CAP, strong consistency
is impossible for these databases. Weak consistency is an especially
heretical thought to the RDBMS old guard. Instead, these NoSQL databases
implement eventual consistency, whereby any changes are 
replicated to the entire database eventually, but at any given time, a
single node or group of nodes may not have the latest data. Like the NoSQL
databases,
which focus on C and A, the focus for A and P databases is on low latency,
high throughput and anything else that makes the Web site more responsive
and a richer experience for users.
</p><p>
In addition to sometimes abandoning consistency in favor of scalability
and latency, another way NoSQL databases break with tradition is in their
abandonment of the relational model. To be fair, some data truly does not
naturally fit the relational model. This could be because the data changes
form or size often, or because the data is completely unstructured.
</p><p>
The final break with tradition in NoSQL databases is the thing that gave
them their name. They don't use SQL. The reasons for dropping SQL usually
revolve around it not fitting in with modern object-oriented development
processes or some perceived difficulty in working with SQL. Sometimes
the excuse given for not using SQL is a simple &ldquo;SQL sucks&rdquo;, which isn't
really a reason. Stupid reasons aside, the SQL language was designed
for use with relational databases, and NoSQL databases are mostly
non-relational, so it makes sense that they don't use it.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x15b23d8"></a>
The Case for SQL</h2></div></div><p>
So what about plain-old SQL RDBMSes? Should they be retired from active
service? Are they a relic from an earlier time? Not so fast.
</p><p>
First and foremost, ACID transactions most definitely are required
in certain use cases. Databases used by banks and stock markets,
for example, always must give correct data. Where money is concerned,
guessing is not allowed. It is true that no one really cares if your
latest tweet takes a couple minutes to show up in your Twitter feed,
but the same cannot be said for a billing system or accounting
database.
</p><p>
Another thing in favor of RDBMSes is their use of SQL. It's a common
language, and if you need to move from one database to another, you 
usually can get away with making only minor changes to your application, and
it will &ldquo;just work&rdquo;. True, it may not be possible in all
cases, depending
on how you used or abused the SQL queries in your application, but the
foundation for moving easily between different SQL databases is there,
and the tools and libraries you can use to interact with your data are
plentiful and robust. A unified
NoSQL standard query language or API will never exist because every NoSQL database is
so different.
</p><p>
On the NoSQL side, the only thing in common is that there is nothing in
common. Each NoSQL database has its own set of APIs, libraries and
preferred languages for interacting with the data they contain. With an
RDBMS, it is trivial to get data out in whatever format you need using
whatever programming language you like best. Your choice of a NoSQL database might
limit you to one or a handful of programming languages and access methods.
</p><p>
Another thing RDBMSes have going for them is the relational model. The
R in RDBMS traces its history back to research by E. F. Codd published
in the June 1970 issue of <span   class="emphasis"><em>Communications of the ACM</em></span>.
Since then, it has been expanded upon,
improved and clarified. The relational model for databases is
so popular because it is an excellent way to organize information. It
maps very well to an enormous variety of real-world data storage needs,
and when properly normalized, it is fast and efficient.
</p><p>
In the relational model, data is stored in tables with rows and columns. An
address table, for example, might have columns for street name and number,
city, postal code, state or province, and country. A name table might
have columns for given names, family name, prefixes (Dr, Rev, Ms and so
on) and suffixes (Jr, Sr, Esq and so on). Each row in the individual
tables would represent an individual address or name.
</p><p>
The relational part (see the What Does Relational Mean in a Relational Database? sidebar)
comes into play as you define which addresses relate
to which names using a key. A key is a field (the intersection of a row
and column) or combination of fields in a single row that is guaranteed
to identify uniquely that particular row in the table it is in. For the
address table, you might have a column for keys from the name table. You
can use this key to look up just those addresses in the address table that
&ldquo;belong&rdquo; (by virtue of the key) to a certain name in the name table.
</p><p>
My example is pretty simplistic, but when combined with ACID
transactions in an RDBMS, you achieve tremendous power, flexibility
and reliability. There is a reason that businesses began using them
decades ago and why open-source RDBMSes dominate the Web.
</p><p>
And, what about the Web? The primary argument many people use against
RDBMSes is that they &ldquo;don't scale&rdquo;, which simply isn't true. It is true
that some individual RDBMSes do not scale very well or are harder to
scale, but that doesn't mean every RDBMS cannot. RDBMSes are in use at
every large company. The largest RDBMS installations routinely handle
enormous traffic and petabytes of data.
</p><p>
This scaling myth is perpetuated and given credence every time popular
Web sites announce that such-and-such RDBMS doesn't meet their needs, and
so they are moving to NoSQL database X. The opinion of some in the RDBMS
world is that many of these moves are not so much because the database
they were using is deficient in some fundamental way, but because it was being
used
in a way for which it wasn't designed. To make an analogy,
it's like people using flat-head screwdrivers to tighten Phillips-head
screws, because it worked well enough to get the job done, but now they've
discovered it is better to tighten Phillips screws with an actual Phillips
screwdriver, and isn't it wonderful, and we should throw away all flat-head
screwdrivers, because their time is past, and Phillips is the future.
</p><p>
One recent SQL-to-NoSQL move involved Digg.com moving from MySQL
to Cassandra. As part of the move, Digg folks blogged about how they
were using MySQL and why it didn't meet their needs. Others were skeptical.
Dennis Forbes, in a series of posts on his site (see Resources),
questioned whether Digg needed to use a NoSQL solution like Cassandra at all.
His claims centered on what he considered very poor database usage
on the part of Digg combined with inadequate hardware. In his mind, if
Digg had just designed its database properly or switched to using SSDs
in its servers, it would have had no problems. His best quote is this:
&ldquo;The way that many are using NoSQL is like discovering the buggy whip
at the beginning of the automotive era.&rdquo; Ouch.
</p><p>
Relational databases sometimes can be tricky to design properly. You
have to know and understand your data deeply. But when they are designed
properly, the performance can be orders of magnitude better compared to
poorly designed databases. You also should not overlook the hardware
on which your database runs. Databases love as much memory and processing
power as you can throw at them, and the traditional spinning-platter
disk drive has long been a limiting factor. Does the high performance
of SSDs herald a new age of RDBMS performance? Many experts say yes.
SSDs may be a game-changer in the database world.
</p><p>
Relational SQL databases have been around for several decades. They
have proven reliability and performance and a feature set that meets the
requirements of 99% of the use cases out there. They even make excellent
key-value databases, if that's the type of data you have. There are
only very few companies that can't make a relational database work
for them. You may not like to hear it, but with the law of averages,
chances are your company is not one of them.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x15b2b68"></a>
Conclusion</h2></div></div><p>
My advice? Don't think of SQL vs. NoSQL as an either/or question. Options
are a good thing. Many alternatives exist, so if you
are having issues with your chosen database, experiment with different
products on both sides and run your own benchmarks.
</p><p>
Also look into how you are using your database. If the database was
&ldquo;bootstrapped&rdquo; while you were creating your killer application
or service, and it is starting to give you problems, you might have an easily solvable
design issue at the root of your troubles. If databases are not your
thing, consult with an expert. RDBMSes have been around a long time, and
there are plenty of experts.
</p><p>
Whatever you decide to do, don't think of NoSQL as your escape from the
SQL RDBMS world. NoSQL databases are not a panacea. I asked my boss,
Monty Widenius, the creator of MySQL, what his opinion on the whole
NoSQL vs. SQL thing was. His answer: &ldquo;Non-SQL gives you a very sharp
knife to solve a selected set of issues. If you find SQL too hard to use,
you should not try Non-SQL.&rdquo;
</p><p>
His basic point is that if you don't understand SQL RDBMSes, you'll
probably end up hurting yourself by jumping into NoSQL. Key-value
stores like those found in NoSQL databases do work for certain kinds of
data, but they don't work well at all for other kinds. It is instructive
to point out that the companies that use and have championed NoSQL
databases have not given up on SQL RDBMSes. They continue to use them in
vital roles.
</p><p>
Finally, many of the NoSQL ideas are based on old technology. Key-value
stores have been around for more than 20 years, for example. New
this time around are things like map-reduce (some claim that even
this is an old idea), which spread the workload over many computers. In
that sense, NoSQL databases really should be called distributed-DBMSes
(DDBMSes?). Basically, distributed RDBMSes, without the R.
</p><p>
Whatever you call them, NoSQL databases are solving problems that were
considered &ldquo;solved&rdquo; by many in the RDBMS world a long time
ago. They're
just solving the problems in a different way, and they have a different
set of requirements. If this new-old way solves an issue you're having,
great! On the flip side, if your current RDBMS is meeting your needs,
don't feel like you need to jump on the bandwagon.
</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x19ab180"></a></h2></div></div><div class="sidebar"><p class="title"><b>
What Is CAP?</b></p><p>
The CAP Theorem, also called Brewer's Theorem, first was proposed by Eric
Brewer in a July 2000 keynote at the ACM Symposium on the Principles of
Distributed Computing. It was formally proved in 2002 by Seth Gilbert
and Nancy Lynch of MIT. The CAP Theorem states that it is impossible for any
shared-data system to <span   class="emphasis"><em>guarantee</em></span>
simultaneously all of the following
three properties: consistency, availability and partition tolerance.
</p><p>
Consistency in CAP is not the same as consistency in ACID (that would
be too easy). According to CAP, consistency in a database means that
whenever data is written, everyone who reads from the database will
always see the latest version of the data. A database without strong
consistency means that when the data is written, not everyone who reads
from the database will see the new data right away; this is usually
called eventual-consistency or weak consistency.
</p><p>
Availability in a database according to CAP means you always
can expect the database to be there and respond whenever you query it for
information. High availability usually is accomplished through large
numbers of physical servers acting as a single database through sharing
(splitting the data between various database nodes) and replication
(storing multiple copies of each piece of data on different nodes).
</p><p>
Partition tolerance in a database means that the database 
still can be read from and written to when parts of it are completely
inaccessible. Situations that would cause this include things like
when the network link between a significant number of database nodes
is interrupted. Partition tolerance can be achieved through some sort
of mechanism whereby writes destined for unreachable nodes are sent to
nodes that are still accessible. Then, when the failed nodes come back,
they receive the writes they missed. In Cassandra, this is called hinted
handoff. A database with good partition tolerance can span multiple
data centers, whereas one with weak partition tolerance basically is bound
to a single data center.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x19ab4f0"></a></h2></div></div><div class="sidebar"><p class="title"><b>
What Is ACID?</b></p><p>
ACID is the classic measure of determining whether your database is good. A transaction in a database is a single logical operation. An example
would be inserting an address or updating a phone number in an employee
database. Every database provides methods to do operations like those,
but ACID formalizes the process.
</p><p>
Atomicity means that the transaction either succeeds or fails. If the
transaction fails, it should fail completely, and the database should be
left in the state it was in before the transaction started.
</p><p>
Consistency means that the database is in a known good state both before
and after the transaction.
</p><p>
Isolation means that transactions are independent of one another, and
if two transactions are trying to modify the same data, one of them must
wait for the other to finish before it can begin.
</p><p>
Durability means that once the transaction has completed, the changes made
by the transaction will persist, even if there is a system failure. A
transaction log of some sort usually is used for this purpose. In MariaDB
and MySQL, this is called the binary log.
</p><p>
So, what is the opposite of ACID? BASE (Basically Available, Soft-state,
Eventual consistency), of course. BASE is a retronymn coined by Dan
Pritchett in an article in the <span   class="emphasis"><em>ACM Queue</em></span> magazine for describing a
database that does not implement the full ACID model, with the main
difference being that it is eventually consistent. The idea is that if
you give up some consistency, you can gain more availability and greatly
improve the scalability of your database.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x19ab910"></a></h2></div></div><div class="sidebar"><p class="title"><b>
What Does Relational Mean in a Relational Database?</b></p><p>
In common usage, the relational part of Relational Database
refers to (or is often assumed to refer to) the way tables are
related to each other via keys.
For the truly pedantic though, this is in in fact incorrect.
Relational here does not refer to <span   class="emphasis"><em>relationships</em></span> between
tables, rather it refers to the mathematical concept of a relation,
which is in essence what relational databases call tables.
A relational database is a database based on the relational model.
</p></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><h2 class="title"><a name="N0x14b9580.0x19abb78"></a></h2></div></div><div class="sidebar"><p class="title"><b>
Resources</b></p><p>
<span   class="bold"><b>SQL Databases:</b></span>
</p><p>
MariaDB: <a href="http://askmonty.org" target="_self">askmonty.org</a>
</p><p>
PostgreSQL: <a href="http://www.postgresql.org" target="_self">www.postgresql.org</a>
</p><p>
<span   class="bold"><b>NoSQL Databases:</b></span>
</p><p>
Cassandra: <a href="http://cassandra.apache.org" target="_self">cassandra.apache.org</a>
</p><p>
CouchDB: <a href="http://couchdb.apache.org" target="_self">couchdb.apache.org</a>
</p><p>
HBase: <a href="http://hadoop.apache.org/hbase" target="_self">hadoop.apache.org/hbase</a>
</p><p>
Redis: <a href="http://code.google.com/p/redis" target="_self">code.google.com/p/redis</a>
</p><p>
Voldemort: <a href="http://project-voldemort.com" target="_self">project-voldemort.com</a>
</p><p>
MongoDB: <a href="http://www.mongodb.org" target="_self">www.mongodb.org</a>
</p><p>
Hypertable: <a href="http://hypertable.org" target="_self">hypertable.org</a>
</p><p>
Dynomite: <a href="http://wiki.github.com/cliffmoon/dynomite/dynomite-framework" target="_self">wiki.github.com/cliffmoon/dynomite/dynomite-framework</a>
</p><p>
BigTable: <a href="http://labs.google.com/papers/bigtable.html" target="_self">labs.google.com/papers/bigtable.html</a>
</p><p>
<span   class="bold"><b>Brewer's CAP Theorem:</b></span>
</p><p>
Brewer's CAP Theorem by Julian Browne: <a href="http://www.julianbrowne.com/article/viewer/brewers-cap-theorem" target="_self">www.julianbrowne.com/article/viewer/brewers-cap-theorem</a>
</p><p>
CAP Theorem: <a href="http://devblog.streamy.com/2009/08/24/cap-theorem" target="_self">devblog.streamy.com/2009/08/24/cap-theorem</a>
</p><p>
Towards Robust Distributed Systems by Dr Eric A. Brewer: <a href="http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf" target="_self">www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf</a>
</p><p>
Brewer's Conjecture and the Feasibility of Consistent Available
Partition-Tolerant Web Services (2002) by Seth Gilbert and Nancy Lynch:
<a href="http://citeseer.ist.psu.edu/544596.html" target="_self">citeseer.ist.psu.edu/544596.html</a>
</p><p>
E. F. Codd's &ldquo;A Relational Model of Data for Large Shared Data
Banks&rdquo;: <a href="http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_self">www.seas.upenn.edu/~zives/03f/cis550/codd.pdf</a>
</p><p><span   class="bold"><b>
Other Links:</b></span>
</p><p>
Dennis Forbes on Software and Technology: <a href="http://www.yafla.com/dforbes" target="_self">www.yafla.com/dforbes</a>
</p><p>
Looking to the future with Cassandra by Ian Eure: <a href="http://about.digg.com/blog/looking-future-cassandra" target="_self">about.digg.com/blog/looking-future-cassandra</a>
</p><p>
NOSQL debrief by Johan Oskarsson: <a href="http://blog.oskarsson.nu/2009/06/nosql-debrief.html" target="_self">blog.oskarsson.nu/2009/06/nosql-debrief.html</a>
</p><p>
BASE: An Acid Alternative by Dan Pritchett: <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_self">queue.acm.org/detail.cfm?id=1394128</a>
</p><p>
Should you go Beyond Relational Databases? by Martin Kleppmann: <a href="http://carsonified.com/blog/dev/should-you-go-beyond-relational-databases" target="_self">carsonified.com/blog/dev/should-you-go-beyond-relational-databases</a>
</p><p>
NoSQL Q and A: <a href="http://www.dbms2.com/2009/12/11/nosql-q-and-a" target="_self">www.dbms2.com/2009/12/11/nosql-q-and-a</a>
</p><p>
NoSQL Video by Brian Aker: <a href="http://www.youtube.com/watch?v=LhnGarRsKnA" target="_self">www.youtube.com/watch?v=LhnGarRsKnA</a>
</p></div></div></div>
<div class="authorblurb"><p>
Daniel Bartholomew works for Monty Program as a technical writer and system
administrator. He lives with his wife and children in North Carolina and 
often can be
found hanging out on both #linuxjournal and
#maria on Freenode IRC.
</p></div>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../195/toc195.html">Issue Table of Contents</a>
    <a class="link3" href="../195/10770.html">Article</a>
  </div>
  <div class="bottomhrdiv">
  </div>
  
  <div id="bottom_search">
  <table class="page_search" summary="">
    <tr>
      <td valign="top" align="left">
        <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
      </td>
      <td valign="top" align="right">
        <form method="get" action="/zoom/search.cgi">
          <input type="hidden" name="zoom_sort" value="0" />
          <input type="hidden" name="zoom_xml" value="0" />
          <input type="hidden" name="zoom_per_page" value="10" />
          <input type="hidden" name="zoom_and" value="1" />
          Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
          <input type="submit" value="Submit" />
        </form>
      </td>
    </tr>
  </table>
  </div>
  
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>
  
  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
  </body></html>