<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<link href="https://fonts.googleapis.com/css?family=Lateef" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

  <title>Understanding Bash: Elements of Programming</title>
  <link href="../../css/archive.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../js/archive.js"></script>
<script type="text/javascript" src="../../js/highlight.js"></script>
</head>


<body class="from_sigil">
  
  <div class="headerdiv">
    <a href="../../index.html">
      <img class="topimg" src="../../images/CD_HeaderBanner.png" alt="LJ Archive"/>
    </a>
  </div>


  <div class="tophrdiv">
  </div>

  
  <div id="top_search">
    <table class="page_search" summary="">
      <tr>
        <td valign="top" align="left">
          <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
        </td>
        <td valign="top" align="right">
          <form method="get" action="/zoom/search.cgi">
            <input type="hidden" name="zoom_sort" value="0" />
            <input type="hidden" name="zoom_xml" value="0" />
            <input type="hidden" name="zoom_per_page" value="10" />
            <input type="hidden" name="zoom_and" value="1" />
            Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
            <input type="submit" value="Submit" />
          </form>
        </td>
      </tr>
    </table>
  </div>

  <h1 class="title">Understanding Bash: Elements of Programming</h1>

  <h2 id="sigil_toc_id_45">Ever wondered why programming in Bash is so difficult? Bash employs the same constructs as traditional programming languages; however, under the hood, the logic is rather different. By Vladimir Likic</h2>

  <div class="caption">
    <img alt="Bash" src="12446c.jpg"/>

    <p class="caption"></p>
  </div>

  <p>The Bourne-Again SHell (Bash) was developed by the Free Software Foundation (FSF) under the GNU Project, which gives it a somewhat special reputation within the Open Source community. Today, Bash is the default user shell on most Linux installations. Although Bash is just one of several well known UNIX shells, its wide distribution with Linux makes it an important tool to know.</p>

  <p>The main purpose of a UNIX shell is to allow users to interact effectively with the system through the command line. A common shell action is to invoke an executable, which in turn causes the kernel to create a new running process. Shells have mechanisms to send the output of one program as input into another and facilities to interact with the filesystem. For example, a user can traverse the filesystem or direct the output of a program to a file.</p>

  <p>Although Bash is primarily a command interpreter, it's also a programming language. Bash supports variables, functions and has control flow constructs, such as conditional statements and loops. However, all of this comes with some unusual quirks. This is because Bash attempts to fulfill two roles at the same time: to be a command interpreter and a programming language—and there is tension between the two.</p>

  <p>All UNIX shells, including Bash, are primarily command interpreters. This trait has a deep history, stretching all the way to the very first shell and the first UNIX system. Over time, UNIX shells acquired the programming capabilities by evolution, and this has led to some unusual solutions for the programming environment. As many people come to Bash already having some background in traditional programming languages, the unusual perspective that Bash takes with programming constructs is a source of much confusion, as evidenced by many questions posted on Bash forums.</p>

  <p>In this article, I discuss how programming constructs in Bash differ from traditional programming languages. For a true understanding of Bash, it's useful to understand how UNIX shells evolved, so I first review the relevant history, and then introduce several Bash features. The majority of this article shows how the unusual aspects of Bash programming originate from the need to blend the command interpreter function seamlessly with the capabilities of a programming language.</p>

  <h3 id="sigil_toc_id_46">Bash History</h3>

  <p>The term "shell" originated from the MULTICS project, a collaboration between Massachusetts Institute of Technology (MIT), General Electric and Bell Telephone Laboratories (henceforth Bell Labs) to develop a next-generation time-sharing operating system. Unhappy with the progress, Bell Labs withdrew from the project in 1969, and the Bell Labs team who worked on MULTICS went on to develop their own operating system: UNIX.</p>

  <p>The ancestor of Bash is the Thompson shell, the first UNIX command interpreter, developed by Ken Thompson in 1971. Figure 1 shows an excerpt from the <em>UNIX Programming Manual</em>, 1st edition, that describes the Thompson shell.</p>

  <div class="caption">
    <img alt="Unix Programming Manual page" src="12446f1.jpg"/>

    <p class="caption">Figure 1. An Excerpt from the <em>UNIX Programming Manual</em>, 1st Edition, Published in 1971, Describing the Original Thompson Shell</p>
  </div>

  <p>Between 1973–1975, John R. Mashey extended the original Thompson shell and added several programming capabilities, making it a high-level programming language. In Mashey's own words:</p>

  <blockquote>
    <p>Modifications have been aimed at improving the use of the shell...and making it even more convenient to use as a high-level programming language. In line with the philosophy of much existing UNIX software, an attempt has been made to add new features only when they are shown necessary by actual user experience in order to avoid contaminating a compact, elegant system through "creeping featurism". (From J. Mashey, "Using a Command Language as a High-level Programming Language", CSE '76 Proceedings of the 2nd International Conference on Software engineering, 1976.)</p>
  </blockquote>

  <p>Stephen Bourne started working on a new shell early in 1976. The Bourne shell benefited from the concepts introduced by the Mashey shell, and it brought some new ideas of its own. The Bourne shell officially was introduced in UNIX Version 7, released in 1979.</p>

  <p>The original Thompson shell, the Mashey shell and the Bourne shell were all called sh, and they overlapped or replaced one another in the years 1970–1976 as they were refined and gained additional capabilities. Throughout 1970s, UNIX was mostly being developed at Bell Labs and, in parallel, at the University of California at Berkeley (the variant known as BSD). With the development of UNIX, shells were constantly developed and refined. At the time when the Bourne shell already was in use, Bill Joy at Berkeley developed the C shell (csh). The C shell was the first truly alternative UNIX shell, and it was incorporated in the 2BSD release of Berkeley UNIX. In the early 1980s, David Korn developed the Korn shell (ksh). Compared to the Bourne shell, the C shell emphasized the command interpreter mode, and the Korn shell came with more extensive programming capabilities.</p>

  <p>UNIX development efforts at Bell Labs and Berkeley enriched each other, and the two versions were later merged. In the 1980s, AT&amp;T licensed UNIX to a number of commercial vendors, and this resulted in the disruptive wars for the UNIX market domination. In 1985, Richard Stallman established the Free Software Foundation (FSF), whose main initiative was to build a free-to-use UNIX-like system, one that is not encumbered by the intellectual property issues surrounding UNIX. This is the famous GNU Project ("GNU's not UNIX"). In fact, the original letter from Stallman, sent on the net.unix-wizards mailing list in September 1983, started with the cry: "Free Unix!"</p>

  <p>Since it's impossible to have free UNIX without a shell, that was a priority for the GNU Project. Brian Fox, the Free Software Foundation's first paid programmer, started working on a shell 1988. This became Bash, first released as beta in 1989. Bash is mostly a clone of the Bourne shell (hence "Bourne-Again"), but it also includes additional features inspired by the C shell and Korn shell. Brian Fox was the official maintainer of Bash until 1992. At the time, Chet Ramey already was involved with the work on Bash, and he became the official maintainer in 1993. Chet Ramey continued to maintain and develop Bash for the next 25 years, and he's still Bash's current maintainer.</p>

  <h3 id="sigil_toc_id_47">Doing Two Different Things at Once</h3>

  <p>The original Thompson shell was a simple command interpreter whose mode of operation was as follows:</p>
  <pre><code>
$ command [ arg1 ... [ argN ]
</code>
</pre>

  <p>where <code>command</code> is the name of the executable file (that is, a command to be executed), and the optional arguments <code>arg1 ... argN</code> are passed to the command. The Thompson shell had no programming capabilities. This changed with the development of the Mashey shell (and later the Bourne shell). In his seminal paper "The UNIX Shell", published in 1978, Stephen Bourne wrote:</p>

  <blockquote>
    <p>The UNIX shell is both a programming language and a command language. As a programming language, it contains control-flow primitives and string-valued variables. As a command language, it provides a user interface to the process-related facilities of the UNIX operating system. (S.R Bourne, "The UNIX Shell", <em>The Bell System Technical Journal</em>, Vol 56, No 6, July–August 1978.)</p>
  </blockquote>

  <p>Note the emphasis on the different functionality: a programming language and a command language. In fact, it was the Mashey and Bourne shells that extended the capabilities of the Thompson shell beyond the command interpreter. The shell's original role was a command interpreter, and the programming capabilities of shells were added later. UNIX shells evolved some ingenious ways of consolidating the programming capabilities with the original command interpreter role.</p>

  <h3 id="sigil_toc_id_48">Bash Mode of Operation</h3>

  <p>Today's Bash is more powerful compared to the original Mashey shell and the Bourne shell. However, the purpose of the shell remains exactly the same. Arguably, the most important function of the shell is running commands (that is, submitting an executable file to the kernel for execution). This has several profound ramifications. For a start, Bash treats (almost) anything that is given to it as a command. Consider the following Bash session:</p>
  <pre><code>
$ VAR
bash: VAR: command not found
$ 9
bash: 9: command not found
$ 9 + 1
bash: 9: command not found
$
</code>
</pre>

  <p>This shows that Bash splits the input into words, then attempts to execute the first word as a command (the "words" <code>VAR</code> and <code>9</code>). Here, a "command" may be either a Bash built-in command (such as <code>cd</code>), a utility (such as <code>/bin/ls</code>) or some other executable file. When the string <code>9 + 1</code> was given on input, Bash split it into three "words": <code>9</code>, <code>+</code> and <code>1</code>. It's important to note that Bash keeps all words as strings and has no concept of numbers until forced to do an arithmetic evaluation. As a rather simplified summary, Bash operates as follows:</p>

  <ol>
    <li>Takes the input and splits it into words on white spaces (space or tab).</li>

    <li>Assumes that the first word is a command. If anything follows the first word, it assumes they are arguments to be passed to the command.</li>

    <li>Attempts to execute the command (and pass the arguments to it, if any).</li>
  </ol>

  <p>This view ignores several intermediate steps. For example, Bash scans the input line and performs all sorts of expansions and replacements. It also checks for a built-in command with the name given, and executes that, if it exists. Not to lose sight of the big picture, I often ignore these details.</p>

  <p>So, Bash's most essential purpose is to execute commands, and this has some profound implications. Notably, the programming constructs in Bash, which at first sight may look like a programming language, are derived from this mode of operation. And, that is the central theme of this article.</p>

  <h3 id="sigil_toc_id_49">Bash Built-ins vs. External Commands</h3>

  <p>The point that's often confusing to Bash newcomers is the difference between Bash built-in commands and external commands. On a typical Linux/UNIX system, a number of common commands are both built-in in Bash and <em>also</em> exist as independent executables with the same name. Examples of this include <code>echo</code> (built-in) and <code>/bin/echo</code>, <code>kill</code> (built-in) and <code>/bin/kill</code>, <code>test</code> (built-in) and <code>/usr/bin/test</code> (and there are more). Consider how the Bash built-in <code>echo</code> and <code>/bin/echo</code> behave very similarly:</p>
  <pre><code>
$ echo 'Echoed with a built-in!'
Echoed with a built-in!
$ /bin/echo 'Echoed with external program!'
Echoed with external program!
$
</code>
</pre>

  <p>However, there are also subtle differences (try <code>echo --version</code>). Why this duplication of commands? There are several reasons. The built-in version typically exists for performance reasons: Bash built-ins execute within the shell process that's already running. In contrast, executing an external utility involves loading and executing the external binary by the kernel, which is a much slower process.</p>

  <p>At this point, it's useful to note that some shell commands, by their nature, cannot be external utilities (in other words, they must be shell built-ins). Consider the <code>cd</code> command that changes the current working directory. An external utility wouldn't be able to change the shell's current working directory, so <code>cd</code> must be a Bash built-in. Why? Because invoking a command as an external utility would make the shell its parent process, and a child process cannot change the current working directory of the parent process.</p>

  <p>You could turn this question around and ask, "if <code>echo</code> is already built in to the shell, why does the external utility <code>/bin/echo</code> exist?" That's because one doesn't always work through the shell and may need to invoke <code>echo</code> without the mediating shell process. Second, in principle, there's nothing to enforce that a UNIX shell must have <code>echo</code> as a built-in, and therefore, it's important to have the external utility <code>/bin/echo</code> as a fallback.</p>

  <p>A practical problem users often face is this: how do you know whether the command you just called is the shell built-in or an external utility with the same name? The Bash command <code>type</code> (which is itself a shell built-in) indicates what command would be used if executed. For example:</p>
  <pre><code>
$ type echo
echo is a shell builtin
$ type ls
ls is hashed (/bin/ls)
$
</code>
</pre>

  <p>The basic rule is as follows: if the built-in command with a given name exists, it will be executed. If the built-in command doesn't exist, Bash will search for an external program, and if found, will execute it. If you want to be sure to use the executable, which happens to have the same name as a shell built-in, calling the executable with the full path will do.</p>

  <h3 id="sigil_toc_id_50">Variable Assignment</h3>

  <p>When a command is entered in Bash, Bash expects that the first word it encounters is a command. However, there's one exception: if the first word contains <code>=</code>, Bash will attempt to execute a variable assignment. For example:</p>
  <pre><code>
$ VAR=7
$
</code>
</pre>

  <p>This has assigned the value 7 to the variable named <code>VAR</code>. To retrieve the value of a variable, you need to prefix the variable name with the dollar sign. Thus, to view the value of a variable, you can combine the dollar-sign prefix with <code>echo</code>:</p>
  <pre><code>
$ echo $VAR
7
$
</code>
</pre>

  <p>For a variable assignment, a contiguous string that contains <code>=</code> is important. The following will fail:</p>
  <pre><code>
$ VAR = 1
bash: VAR: command not found
$
</code>
</pre>

  <p>In this case, Bash splits the input <code>VAR = 1</code> into three "words" (<code>VAR</code>, <code>=</code> and <code>1</code>) and then attempts to execute the first word as a command. This clearly isn't what was intended here.</p>

  <h3 id="sigil_toc_id_51">The ? Built-in Variable</h3>

  <p>Although Bash allows you to create arbitrary variables on the fly simply by assigning the values to them, it also has a number of built-in variables. An example of a built-in variable is <code>BASHPID</code>. This contains the process ID of the Bash shell itself:</p>
  <pre><code>
$ echo $BASHPID
2141
$
</code>
</pre>

  <p>Another built-in variable (and one that I cover extensively here) is <code>?</code>. At any point in a Bash session, this variable contains the return value of the last executed command. The return value is always an integer. (And specifically, this is the return value of the C program function <code>main()</code>. Note: in any C program the function <code>main()</code> must return an integer.) By the UNIX convention, the return value of 0 denotes success, and any other value denotes failure. For example, consider the utility <code>/bin/ls</code>:</p>
  <pre><code>
$ touch NEWFILE
$ /bin/ls NEWFILE
NEWFILE
$ echo $?
0
$
</code>
</pre>

  <p>As per the convention, the utility <code>/bin/ls</code> returned 0 on success, which you can see by inspecting the value of <code>?</code>. If <code>ls</code> is unable to execute (for example, unable to access the file), it returns the value <code>&gt;0</code>:</p>
  <pre><code>
$ /bin/ls DOESNOTEXIST
ls: cannot access 'DOESNOTEXIST': No such file or directory
$ echo $?
2
$ echo $?
0
$
</code>
</pre>

  <p>In the last example, note that the first <code>?</code> was set to 2, and the second <code>?</code> was set to 0. Why? Because the second <code>?</code> contains the exit status of the <code>echo</code> command (which executed successfully). Remember, the <code>?</code> variable contains the exit status of the last executed command. You can use the commands <code>true</code> and <code>false</code> to set the value of <code>?</code> to 0 or 1, respectively:</p>
  <pre><code>
$ false
$ echo $?
1
$ false
$ true
$ echo $?
0
$
</code>
</pre>

  <p>That might look rather silly at first, but keep reading.</p>

  <h3 id="sigil_toc_id_52">Bash Blending Behavior</h3>

  <p>Now let's consider how Bash provides an impression of a seamlessly integrated command environment, even when the tasks it executes are inherently quite different. First, note that running a Bash built-in command produces the same effect on the <code>?</code> variable as running an external program:</p>
  <pre><code>
$ false   #  set ? to 1
$ echo 'Calling a built-in command'
Calling a built-in command
$ echo $?
0
</code>
</pre>

  <p>This example shows that calling the built-in command <code>echo</code> changed <code>?</code> to 0 (to confirm this, first run the <code>false</code> command, which sets <code>?</code> to 1). The point is that it behaves the same as calling the external program <code>echo</code>:</p>
  <pre><code>
$ false  #  set ? to 1
$ /bin/echo 'Calling external program'
Calling external program
$ echo $?
0
</code>
</pre>

  <p>Yet, these two scenarios are quite different. In the first scenario, Bash invoked an internal command <code>echo</code>; in the second example, Bash requested from the kernel to run an external executable (<code>/bin/echo</code>) and suspended itself waiting for the executable to complete. The effect on the <code>?</code> variable is exactly the same.</p>

  <p>Even for a variable assignment, Bash will set the <code>?</code> variable accordingly:</p>
  <pre><code>
$ false   #  set ? to 1
$ VAR=one
$ echo $?
0
$
</code>
</pre>

  <p>From this, you can see that Bash treats a variable assignment as a command. If the variable assignment is not successful, <code>?</code> is set to a value &gt;0. For example, the built-in variable <code>BASHPID</code> is read-only, and you can't change it (that is, Bash can't change its own process ID). So this will fail:</p>
  <pre><code>
$ true  #  set ? to 0
$ BASHPID=99
$ echo $?
1
$
</code>
</pre>

  <p>Attempting to execute a non-existent command would also set <code>?</code> to indicate a failure:</p>
  <pre><code>
$ true  # set ? to 0
$ DUMMY
bash: DUMMY: command not found
$ echo $?
127
$
</code>
</pre>

  <p>In this case, Bash filled the special variable <code>?</code> with the number 127. This number is hard-wired in Bash, and it specifically means "command not found".</p>

  <p>To summarize, the above examples show three completely different scenarios: invoking an internal Bash command, running an external program and variable assignment. Yet, Bash views all three as command execution and provides a common behavior with respect to the <code>?</code> special variable. Armed with these insights, now let's examine three basic programming constructs in Bash: the <code>if</code> statement, the <code>while</code> loop and the <code>until</code> loop.</p>

  <h3 id="sigil_toc_id_53">The Conditional <code>if</code> Statement</h3>

  <p>The fundamental element of almost every programming language is the conditional <code>if</code> statement. In the C language, it looks like this:</p>
  <pre><code>
if (TRUTH_TEST) {
   statements to execute
}
</code>
</pre>

  <p>Here <code>TRUTH_TEST</code> is a test that evaluates true or false according to the rules of the C language. This is sometimes called "truth value testing". Here's an example of this in Python:</p>
  <pre><code>
if True:
    print('Yay true!')
</code>
</pre>

  <p>In Bash, the same example looks like this:</p>
  <pre><code>
if true
then
  echo 'Yay true!'
fi
</code>
</pre>

  <p>You can reformat this by using ; to provide a handy one-liner to type in:</p>
  <pre><code>
$ if true; then echo 'Yay true!'; fi
Yay true!
$
</code>
</pre>

  <p>This looks very much like the <code>if</code> conditional statement in any programming language. However, it's not. In the above example, <code>true</code> is a command. In fact, <code>true</code> is a shell built-in:</p>
  <pre><code>
$ type true
true is a shell builtin
$ help true
true: true
    Return a successful result.
    
    Exit Status:
    Always succeeds.
</code>
</pre>

  <p>Let that sink in: <code>true</code> is a command. In fact, that's the same <code>true</code> command that was run above from the command line to set the value of the <code>?</code> variable. What then is the <code>if</code> statement evaluating? It's evaluating the return value of the <code>true</code> command. If you're not convinced, consider that <code>true</code> can be replaced with the external utility <code>/bin/true</code>:</p>
  <pre><code>
$ if /bin/true; then echo 'Yay true!'; fi
Yay true!
$
</code>
</pre>

  <p>Where:</p>
  <pre><code>
$ man true
TRUE(1)                User Commands                   TRUE(1)

NAME
       true - do nothing, successfully

SYNOPSIS
       true [ignored command line arguments]
       true OPTION

DESCRIPTION
       Exit with a status code indicating success.
</code>
</pre>

  <p>If <code>true</code> is a command, you can put any command there, right? Indeed:</p>
  <pre><code>
$ if /bin/echo; then echo 'Yay true!'; fi

Yay true!
$
</code>
</pre>

  <p>Notice how the blank line was printed before the string <code>Yay true!</code>. That's because the <code>if</code> statement actually executed the command <code>/bin/echo</code>, and without any arguments, this prints a newline character. You actually can give an argument to the <code>echo</code> command:</p>
  <pre><code>
$ if /bin/echo 'Hi'; then echo 'Yay true!'; fi
Hi
Yay true!
$
</code>
</pre>

  <p>The two <code>echo</code> commands executed here are different: the first is the external utility <code>/bin/echo</code>; the second, an <code>echo</code> that appears in the body of the <code>if</code> statement, is the shell built-in. Clearly, the second <code>echo</code> could be replaced with the external utility too.</p>

  <p>Moving on, I mentioned previously that Bash will treat the variable assignment as a command. Thus, variable assignment can be used in the same place as the built-in command or external executable:</p>
  <pre><code>
$ if VAR=99; then echo 'Assignment done!'; fi
Assignment done!
$ echo $VAR
99
$
</code>
</pre>

  <p>To sum up, the general form of the <code>if</code> conditional statement is: <code>if CMD1; then CMD2; fi</code> where <code>CDM1</code> and <code>CMD2</code> are commands. The <code>if</code> statement controls flow by evaluating the exit code of the command <code>CMD1</code>: if <code>CMD1</code> was successful (judging by the exit status of 0), then <code>CMD2</code> is executed. This is rather different compared to truth value testing in most traditional programming languages, and it's the source of much confusion. I shall call this <em>source of confusion number 1</em>.</p>

  <h3 id="sigil_toc_id_54">The <code>false</code> Command</h3>

  <p>I just described how <code>true</code> is a command. So not surprisingly, there is a <code>false</code>, the exact opposite of <code>true</code>. For the Bash built-in:</p>
  <pre><code>
$ type false
false is a shell builtin
$ help false
false: false
    Return an unsuccessful result.
    
    Exit Status:
    Always fails.
$
</code>
</pre>

  <p>And, there is an external utility with the same function:</p>
  <pre><code>
$ man false
FALSE(1)               User Commands                 FALSE(1)

NAME
       false - do nothing, unsuccessfully

SYNOPSIS
       false [ignored command line arguments]
       false OPTION

DESCRIPTION
       Exit with a status code indicating failure.
</code>
</pre>

  <p>The commands <code>true</code> and <code>false</code> do nothing, but exit with the status 0 or 1, respectively. Since the <code>if</code> statement evaluates the exit code when deciding whether to execute the body, <code>if true</code> always succeeds, and <code>if false</code> always fails. Note that the exit value of <code>true</code> is 0, and the exit value of <code>false</code> is 1. This is somewhat counterintuitive, and it's the exact opposite of most programming languages. For example, in Python truth value testing, 0 is equated with False (boolean), and 1 is equated with True (boolean).</p>

  <h3 id="sigil_toc_id_55">Bash <code>if</code> Is Testing the Exit Value</h3>

  <p>Let's confirm that the <code>if</code> statement in Bash is merely testing the value of the program's exit value by writing a simple C program, true.c, that returns 1 (note, the real utility <code>true</code> returns 0, or success!):</p>
  <pre><code>
int main() {
   return 1;
}
</code>
</pre>

  <p>This program doesn't do much; it merely returns 1 as the exit status. According to the UNIX convention, the exit status of 1 indicates a failure (no matter that the program may run just fine!). Let's compile and execute this program, and confirm that it returns an "unsuccessful" exit status to the shell:</p>
  <pre><code>
$ gcc true.c -o true
$ ./true
$ echo $?
1
$
</code>
</pre>

  <p>So, if you use this program in the <code>if</code> statement, the output won't be what you may expect:</p>
  <pre><code>
$ if ./true; then echo 'Yay true!'; fi
$
</code>
</pre>

  <p>In other words, the <code>true</code> command has "failed". This example confirms that all the <code>if</code> statement does is evaluate the exit status. It doesn't matter that the program runs just fine, exactly as intended; from the Bash perspective, a non-zero exit status indicates failure. This I shall call the <em>source of confusion number 2</em>.</p>

  <h3 id="sigil_toc_id_56">More Bash Ingenuity</h3>

  <p>Consider the following task: test if the file exists, and if it does, delete it. For this you can use the Bash built-in <code>test</code> command with the <code>-e</code> flag:</p>
  <pre><code>
$ rm dum.txt        # make sure file 'dum.txt' doesn't exist
$ test -e dum.txt   # test if file 'dum.txt' exists
$ echo $?           # confirm that the command test failed
1
$ touch dum.txt     # now create file 'dum.txt'
$ test -e dum.txt   # test if file 'dum.txt' exists
$ echo $?           # confirm the command test was successful
0
$
</code>
</pre>

  <p>Therefore, to test if the file exists, and if yes, delete it:</p>
  <pre><code>
$ touch dum.txt    # create file 'dum.txt'
$ if test -e dum.txt; then rm dum.txt; fi  # file deleted
$
</code>
</pre>

  <p>The key to note here is that <code>if test -e dum.txt; then rm dum.txt; fi</code> actually executes the command <code>test -e dum.txt</code>. In this case, <code>test</code> is a Bash built-in. As you might suspect, there is a <code>/usr/bin/test</code> utility that does the same thing and could be used to the same effect:</p>
  <pre><code>    
$ touch dum.txt  # create file 'dum.txt'
$ if /usr/bin/test -e dum.txt; then rm dum.txt; fi  
 ↪# file deleted
$
</code>
</pre>

  <p>Now, Bash implements <code>[ ]</code> as a synonym for the built-in <code>test</code> command:</p>
  <pre><code>
$ test -e dum.txt  #  command successful if file exists
$ [ -e dum.txt ]   #  exactly the same as previous example! 
</code>
</pre>

  <p>Note, <code>[ -e dum.txt ]</code> is a command. And this, of course, returns 0 on success and 1 on failure. Let's confirm:</p>
  <pre><code>
$ rm dum.txt
$ [ -e dum.txt ]
$ echo $?
1
$ touch dum.txt
$ [ -e dum.txt ]
$ echo $?
0
$
</code>
</pre>

  <p>With this understanding, you can repeat the above example with the <code>[ -e ... ]</code> construct:</p>
  <pre><code>
$ touch dum.txt  # create file 'dum.txt'
$ if [ -e dum.txt ]; then rm dum.txt; fi  # file deleted
$
</code>
</pre>

  <p>The last construct looks even more like the <code>if</code> control statement in most traditional programming languages. However, it's not. <code>[ ]</code> is a command—basically another way to call the built-in <code>test</code> command.</p>

  <h3 id="sigil_toc_id_57">Command Lists</h3>

  <p>The surprises don't quite end there. In Bash, the <code>if</code> statement can take any number of commands separated by a semicolon, after the keyword <code>if</code> and before the body denoted with the keyword <code>then</code>. Something like this: <code>if CMD1; CMD2; ... CMDN; then CMDN+1; CMDN+2; CMDN+M; fi</code>. The <code>if</code> statement evaluates all commands sequentially and executes the body of the loop only if the exit status of the last command is 0 (a success by convention). Consider the following example:</p>
  <pre><code>
$ if false; true; then echo 'Yay true!'; fi  
 ↪# body will execute
Yay true!
$ if true; false; then echo 'Yay true!'; fi  
 ↪# body will not execute
$
</code>
</pre>

  <p>So in Bash, it's completely legal to write something like this:</p>
  <pre><code>
$ if [ -e dum.txt ]; echo 'Hi'; false; then rm dum.txt; fi
Hi
$
</code>
</pre>

  <p>This executes three commands given after <code>if</code>, and it never will execute the body (<code>rm dum.txt</code>) because the last command is <code>false</code>, which always fails (more precisely, returns a non-zero status). In summary, in place of a single command, you can use a list of commands. The overall exit status of such a command list is given by the exit status of the last command in the list. This I shall call the <em>source of confusion number 3</em>.</p>

  <h3 id="sigil_toc_id_58">The Loops <code>while</code> and <code>until</code></h3>

  <p>Understanding the behavior of the <code>if</code> statement is rather useful because the same behavior applies to <code>while</code> and <code>until</code> loops. Consider the following example:</p>
  <pre><code>
$ while true; do echo 'Hi, while looping ...'; done
Hi, while looping ...
Hi, while looping ...
Hi, while looping ...
^C
$
</code>
</pre>

  <p>Let's understand exactly what happened here. First, the <code>while</code> loop executed the <code>true</code> command and evaluated its exit status. Since the exit status of <code>true</code> is always 0, it executed the body of the loop (<code>echo 'Hi, while looping ...'</code>). Then it went back for another cycle of the same. Because the <code>true</code> command always runs with success, this created an infinite loop (which was broken with Ctrl-C). Since <code>true</code> is a command, you can replace it with any command. For example:</p>
  <pre><code>
$ while /bin/echo 'ECHO'; do echo 'Hi, while looping ...'; done
ECHO
Hi, while looping ...
ECHO
Hi, while looping ...
ECHO
Hi, while looping ...
^C
$
</code>
</pre>

  <p>Thus, this <code>while</code> loop merely alternates the execution of the two <code>echo</code> commands: <code>/bin/echo</code>, the external executable, and <code>echo</code>, the Bash built-in.</p>

  <p>As you might suspect, the <code>while</code> construct can accept a command list, and in such a case, it would proceed to execute the body of the loop based on the exit status of the last command in the list. In other words, the general form of the <code>while</code> loop is as follows: <code>while CMD1; CMD2; ... CMDN; do CMDN+1; CMDN+2; CMDN+M; done</code>. For example:</p>
  <pre><code>
$ while true; false; do echo 'Hi, looping ...'; done
$
</code>
</pre>

  <p>In this example, the body of the loop is not executed because the last command is <code>false</code> (which always fails). The <code>until</code> loop works similarly:</p>
  <pre><code>
$ until false; do echo 'Hi, until looping ...'; done
Hi, until looping ...
Hi, until looping ...
Hi, until looping ...
^C
$
</code>
</pre>

  <p>In the case of the <code>until</code> loop, the body of the loop executes as long as the command listed after the keyword <code>until</code> is returning a non-zero exit status. Since the command <code>false</code> returns a non-zero exit status every time, the above example resulted in an infinite loop. And of course, in the general form, the <code>until</code> loop can accept command lists: <code>until CMD1; CMD2; ... CMDN; do CMDN+1; CMDN+2; CMDN+M; done</code>.</p>

  <p>You may ask, if these loops merely execute two commands (or two command lists), how is it useful in practice at all? The commands that are tested in the loop may depend on some dynamic condition (for example, the number of bytes written to a file, or the type of network traffic and so on). The change in conditions may cause the command to fail or succeed. Also you can modify the Bash variable in the body of the loop, which leads to the use of loops similarly as shown here:</p>
  <pre><code>
$ i=1
$ while [ $i -le 3 ]; do echo $i; i=$((i+1)); done
1
2
3
$
</code>
</pre>

  <p>Here <code>((i + 1))</code> forces Bash arithmetic evaluation, and <code>$((i + 1))</code> returns the resulting value; the construct <code>[ $i -le 3 ]</code> is a synonym for <code>test $i -le 3</code> that performs arithmetic comparison. Note that from the perspective of Bash, this is a command that executes successfully or not:</p>
  <pre><code>
$ i=1
$ [ $i -le 3 ]
$ echo $?
0
$ i=9
$ [ $i -le 3 ]
$ echo $?
1
$
</code>
</pre>

  <p>This is why the <code>[ $i -le 3 ]</code> construct can be used after the <code>while</code> keyword, which expects a command (or a command list).</p>

  <h3 id="sigil_toc_id_59">Conclusion</h3>

  <p>Bash is an independently implemented derivative of the Bourne shell produced by the GNU Project, with enhancements inspired by the C shell and the Korn shell. The original UNIX shell (the Thompson shell) was a simple command interpreter. Subsequently, the Mashey shell and the Bourne shell blended in programming capabilities. Since Bash is a direct descendant of the Bourne shell, it inherited all the key ideas of how a programming environment works. This includes how it blends the programming language with the command interpreter. And for that purpose, UNIX shells have evolved some ingenious solutions.</p>

  <p>In Bash, the programming constructs look similar to those found in traditional programming languages. However, how those programming constructs inherently work is quite different. This can be rather confusing to people coming with some knowledge of the traditional programming languages (which is usually the case for Bash users). Here are the three main sources of confusion with Bash programming:</p>

  <ol>
    <li>The surprising aspect of Bash programming is that the constructs <code>if</code>, <code>while</code> and <code>until</code> evaluate the exit status of a command. Basically these constructs evaluate the following: "is the exit status zero?" By the UNIX convention, the exit status of 0 denotes success, and anything else denotes a failure.</li>

    <li>The exit status is an integer returned by the executable—think of this as the value returned by the C function <code>main()</code>. Note that a program that runs just fine may return a non-zero exit status (I showed an example of this above). However, writing such programs is not recommended. It would break the convention, and it most likely will break other things since the entire environment relies heavily on this convention.</li>

    <li>A single command can be replaced by a list of commands separated by a semicolon. In such a case, the exit status of a command list is the status returned by the last executed command.</li>
  </ol>

  <h3 id="sigil_toc_id_60">Acknowledgements</h3>

  <p>My sincere thanks to Chet Ramey for his feedback on the draft of this article. I would also like to thank Isidora C. Likic for checking the text and examples.</p>

  <h3 id="sigil_toc_id_61">Resources</h3>

  <p>Too many articles and books on this topic exist to list in this space, but if you're interested in learning more, we recommend these <em>Linux Journal</em> articles (and there are actually too many <em>LJ</em> articles to list here as well, but here are some to get you started):</p>

  <ul>
    <li><a href="https://www.linuxjournal.com/content/creating-concentration-game-pairs-bash">"Creating the Concentration Game PAIRS with Bash" by Dave Taylor</a></li>

    <li><a href="https://www.linuxjournal.com/content/create-dynamic-wallpaper-bash-script">"Create Dynamic Wallpaper with a Bash Script" by Patrick Wheelan</a></li>

    <li><a href="https://www.linuxjournal.com/content/developing-console-applications-bash">"Developing Console Applications with Bash" by Andy Carlson</a></li>

    <li><a href="https://www.linuxjournal.com/content/hacking-safe-bash">"Hacking a Safe with Bash" by Adam Kosmin</a></li>

    <li><a href="https://www.linuxjournal.com/content/ubuntu-linux-and-bash-windows-program">"Ubuntu Linux and Bash as a Windows Program!" by Dave Taylor</a></li>

    <li><a href="https://www.linuxjournal.com/content/bash-parameter-expansion">"Bash Parameter Expansion" by Mitch Frazier</a></li>

    <li><a href="https://www.linuxjournal.com/content/bash-regular-expressions">"Bash Regular Expressions" by Mitch Frazier</a></li>

    <li><a href="https://www.linuxjournal.com/content/bash-extended-globbing">"Bash Extended Globbing" by Mitch Frazier</a></li>

    <li><a href="https://www.linuxjournal.com/article/7385">"My Favorite bash Tips and Tricks" by Prentice Bisbal</a></li>

    <li><a href="https://www.linuxjournal.com/content/parsing-rss-news-feed-bash-script">Parsing an RSS News Feed with a Bash Script" by Jim Hall</a></li>
  </ul>

  <p><strong>Bash Videos:</strong></p>

  <ul>
    <li><a href="https://www.linuxjournal.com/video/getting-loopy-bash-using-loops">"Getting Loopy with Bash: Using for Loops" by Shawn Powers</a></li>

    <li><a href="https://www.linuxjournal.com/video/bash-startup-scripts-bashrc-and-bashprofile">"Bash Startup Scripts: bashrc and bash_profile" by Shawn Powers</a></li>
  </ul>

  <h3 id="sigil_toc_id_62">About the Author</h3>

  <p>Vladimir Likic holds a PhD in bioinformatics, and he has been using UNIX since 1991 and Linux since 1995. Originally from Europe, he lived in the US for a number of years and now calls Australia home. Follow Vladimir on Twitter: @unix_byte.</p>

  <div class="toclinks">
    <a class="link1" href="../tocindex.html">Archive Index</a>
    <a class="link2" href="../291/toc291.html">Issue Table of Contents</a>
    <a class="link3" href="../291/12446.html">Article</a>
  </div>
  <div class="bottomhrdiv"></div>

  <div id="bottom_search">
    <table class="page_search" summary="">
      <tr>
        <td valign="top" align="left">
          <p class="small_shutdown"><a href="/.exit">Shutdown Archive web server</a></p>
        </td>
        <td valign="top" align="right">
          <form method="get" action="/zoom/search.cgi">
            <input type="hidden" name="zoom_sort" value="0" />
            <input type="hidden" name="zoom_xml" value="0" />
            <input type="hidden" name="zoom_per_page" value="10" />
            <input type="hidden" name="zoom_and" value="1" />
            Search: <input type="text" name="zoom_query" size="20" value="" class="zoom_searchbox" />
            <input type="submit" value="Submit" />
          </form>
        </td>
      </tr>
    </table>
  </div>
  <div class="footerdiv">
    <a href="../../index.html">
      <img class="bottomimg" src="../../images/CD_FooterBanner.png" alt="LJ Archive"/>
    </a>
  </div>

  <div class="copyright">
    Copyright &copy; 1994 - 2018 <cite>Linux Journal</cite>.  All rights reserved.
  </div>
</body>
</html>